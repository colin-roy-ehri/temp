/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/highcharts/highcharts-more.js":
/*!****************************************************!*\
  !*** ./node_modules/highcharts/highcharts-more.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n12 = 0, F = function F() {}; return { s: F, n: function n() { return _n12 >= r.length ? { done: !0 } : { done: !1, value: r[_n12++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n!\n/**\n* Highcharts JS v11.4.7 (2024-08-14)\n*\n* (c) 2009-2024 Torstein Honsi\n*\n* License: www.highcharts.com/license\n*/\nfunction (t) {\n  \"object\" == ( false ? 0 : _typeof(module)) && module.exports ? (t[\"default\"] = t, module.exports = t) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! highcharts */ \"./node_modules/highcharts/highcharts.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (e) {\n    return t(e), t.Highcharts = e, t;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(function (t) {\n  \"use strict\";\n\n  var e = t ? t._modules : {};\n  function i(e, i, s, o) {\n    e.hasOwnProperty(i) || (e[i] = o.apply(null, s), \"function\" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: i,\n        module: e[i]\n      }\n    })));\n  }\n  i(e, \"Extensions/Pane/PaneComposition.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.addEvent,\n      i = t.correctFloat,\n      s = t.defined,\n      o = t.pick;\n    function a(t) {\n      var e;\n      var i = this;\n      return t && i.pane.forEach(function (s) {\n        r(t.chartX - i.plotLeft, t.chartY - i.plotTop, s.center) && (e = s);\n      }), e;\n    }\n    function r(t, e, o, a, r) {\n      var n = !0,\n        l = o[0],\n        h = o[1],\n        p = Math.sqrt(Math.pow(t - l, 2) + Math.pow(e - h, 2));\n      if (s(a) && s(r)) {\n        var _s = Math.atan2(i(e - h, 8), i(t - l, 8));\n        r !== a && (n = a > r ? _s >= a && _s <= Math.PI || _s <= r && _s >= -Math.PI : _s >= a && _s <= i(r, 8));\n      }\n      return p <= Math.ceil(o[2] / 2) && n;\n    }\n    function n(t) {\n      var _ref;\n      this.polar && (t.options.inverted && (_ref = [t.y, t.x], t.x = _ref[0], t.y = _ref[1], _ref), t.isInsidePlot = this.pane.some(function (e) {\n        return r(t.x, t.y, e.center, e.axis && e.axis.normalizedStartAngleRad, e.axis && e.axis.normalizedEndAngleRad);\n      }));\n    }\n    function l(t) {\n      var e = this.chart;\n      t.hoverPoint && t.hoverPoint.plotX && t.hoverPoint.plotY && e.hoverPane && !r(t.hoverPoint.plotX, t.hoverPoint.plotY, e.hoverPane.center) && (t.hoverPoint = void 0);\n    }\n    function h(t) {\n      var e = this.chart;\n      e.polar ? (e.hoverPane = e.getHoverPane(t), t.filter = function (i) {\n        return i.visible && !(!t.shared && i.directTouch) && o(i.options.enableMouseTracking, !0) && (!e.hoverPane || i.xAxis.pane === e.hoverPane);\n      }) : e.hoverPane = void 0;\n    }\n    return {\n      compose: function compose(t, i) {\n        var s = t.prototype;\n        s.getHoverPane || (s.collectionsWithUpdate.push(\"pane\"), s.getHoverPane = a, e(t, \"afterIsInsidePlot\", n), e(i, \"afterGetHoverData\", l), e(i, \"beforeGetHoverData\", h));\n      }\n    };\n  }), i(e, \"Extensions/Pane/PaneDefaults.js\", [], function () {\n    return {\n      pane: {\n        center: [\"50%\", \"50%\"],\n        size: \"85%\",\n        innerSize: \"0%\",\n        startAngle: 0\n      },\n      background: {\n        shape: \"circle\",\n        borderRadius: 0,\n        borderWidth: 1,\n        borderColor: \"#cccccc\",\n        backgroundColor: {\n          linearGradient: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 1\n          },\n          stops: [[0, \"#ffffff\"], [1, \"#e6e6e6\"]]\n        },\n        from: -Number.MAX_VALUE,\n        innerRadius: 0,\n        to: Number.MAX_VALUE,\n        outerRadius: \"105%\"\n      }\n    };\n  }), i(e, \"Extensions/Pane/Pane.js\", [e[\"Series/CenteredUtilities.js\"], e[\"Extensions/Pane/PaneComposition.js\"], e[\"Extensions/Pane/PaneDefaults.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o = s.extend,\n      a = s.merge,\n      r = s.splat;\n    var n = /*#__PURE__*/function () {\n      function n(t, e) {\n        _classCallCheck(this, n);\n        this.coll = \"pane\", this.init(t, e);\n      }\n      return _createClass(n, [{\n        key: \"init\",\n        value: function init(t, e) {\n          this.chart = e, this.background = [], e.pane.push(this), this.setOptions(t);\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(t) {\n          this.options = t = a(i.pane, this.chart.angular ? {\n            background: {}\n          } : void 0, t);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t = this.options,\n            e = this.chart.renderer;\n          this.group || (this.group = e.g(\"pane-group\").attr({\n            zIndex: t.zIndex || 0\n          }).add()), this.updateCenter();\n          var s = this.options.background;\n          if (s) {\n            var _t = Math.max((s = r(s)).length, this.background.length || 0);\n            for (var _e = 0; _e < _t; _e++) s[_e] && this.axis ? this.renderBackground(a(i.background, s[_e]), _e) : this.background[_e] && (this.background[_e] = this.background[_e].destroy(), this.background.splice(_e, 1));\n          }\n        }\n      }, {\n        key: \"renderBackground\",\n        value: function renderBackground(t, e) {\n          var i = {\n              \"class\": \"highcharts-pane \" + (t.className || \"\")\n            },\n            s = \"animate\";\n          this.chart.styledMode || o(i, {\n            fill: t.backgroundColor,\n            stroke: t.borderColor,\n            \"stroke-width\": t.borderWidth\n          }), this.background[e] || (this.background[e] = this.chart.renderer.path().add(this.group), s = \"attr\"), this.background[e][s]({\n            d: this.axis.getPlotBandPath(t.from, t.to, t)\n          }).attr(i);\n        }\n      }, {\n        key: \"updateCenter\",\n        value: function updateCenter(e) {\n          this.center = (e || this.axis || {}).center = t.getCenter.call(this);\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e) {\n          a(!0, this.options, t), this.setOptions(this.options), this.render(), this.chart.axes.forEach(function (t) {\n            t.pane === this && (t.pane = null, t.update({}, e));\n          }, this);\n        }\n      }]);\n    }();\n    return n.compose = e.compose, n;\n  }), i(e, \"Series/AreaRange/AreaRangePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var _t$seriesTypes$area$p = t.seriesTypes.area.prototype,\n      i = _t$seriesTypes$area$p.pointClass,\n      s = _t$seriesTypes$area$p.pointClass.prototype,\n      o = e.defined,\n      a = e.isNumber;\n    return /*#__PURE__*/function (_i) {\n      function _class() {\n        _classCallCheck(this, _class);\n        return _callSuper(this, _class, arguments);\n      }\n      _inherits(_class, _i);\n      return _createClass(_class, [{\n        key: \"setState\",\n        value: function setState() {\n          var t = this.state,\n            e = this.series,\n            i = e.chart.polar;\n          o(this.plotHigh) || (this.plotHigh = e.yAxis.toPixels(this.high, !0)), o(this.plotLow) || (this.plotLow = this.plotY = e.yAxis.toPixels(this.low, !0)), e.lowerStateMarkerGraphic = e.stateMarkerGraphic, e.stateMarkerGraphic = e.upperStateMarkerGraphic, this.graphic = this.graphics && this.graphics[1], this.plotY = this.plotHigh, i && a(this.plotHighX) && (this.plotX = this.plotHighX), s.setState.apply(this, arguments), this.state = t, this.plotY = this.plotLow, this.graphic = this.graphics && this.graphics[0], i && a(this.plotLowX) && (this.plotX = this.plotLowX), e.upperStateMarkerGraphic = e.stateMarkerGraphic, e.stateMarkerGraphic = e.lowerStateMarkerGraphic, e.lowerStateMarkerGraphic = void 0;\n          var r = e.modifyMarkerSettings();\n          s.setState.apply(this, arguments), e.restoreMarkerSettings(r);\n        }\n      }, {\n        key: \"haloPath\",\n        value: function haloPath() {\n          var t = this.series.chart.polar,\n            e = [];\n          return this.plotY = this.plotLow, t && a(this.plotLowX) && (this.plotX = this.plotLowX), this.isInside && (e = s.haloPath.apply(this, arguments)), this.plotY = this.plotHigh, t && a(this.plotHighX) && (this.plotX = this.plotHighX), this.isTopInside && (e = e.concat(s.haloPath.apply(this, arguments))), e;\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return a(this.low) && a(this.high);\n        }\n      }]);\n    }(i);\n  }), i(e, \"Series/AreaRange/AreaRangeSeries.js\", [e[\"Series/AreaRange/AreaRangePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o = e.noop,\n      _i$seriesTypes = i.seriesTypes,\n      a = _i$seriesTypes.area,\n      r = _i$seriesTypes.area.prototype,\n      n = _i$seriesTypes.column.prototype,\n      l = s.addEvent,\n      h = s.defined,\n      p = s.extend,\n      d = s.isArray,\n      c = s.isNumber,\n      u = s.pick,\n      g = s.merge;\n    var f = /*#__PURE__*/function (_a) {\n      function f() {\n        _classCallCheck(this, f);\n        return _callSuper(this, f, arguments);\n      }\n      _inherits(f, _a);\n      return _createClass(f, [{\n        key: \"toYData\",\n        value: function toYData(t) {\n          return [t.low, t.high];\n        }\n      }, {\n        key: \"highToXY\",\n        value: function highToXY(t) {\n          var e = this.chart,\n            i = this.xAxis.postTranslate(t.rectPlotX || 0, this.yAxis.len - (t.plotHigh || 0));\n          t.plotHighX = i.x - e.plotLeft, t.plotHigh = i.y - e.plotTop, t.plotLowX = t.plotX;\n        }\n      }, {\n        key: \"getGraphPath\",\n        value: function getGraphPath(t) {\n          var e = [],\n            i = [],\n            s = r.getGraphPath,\n            o = this.options,\n            a = this.chart.polar,\n            n = a && !1 !== o.connectEnds,\n            l = o.connectNulls,\n            h,\n            p,\n            d,\n            c = o.step;\n          for (h = (t = t || this.points).length; h--;) {\n            p = t[h];\n            var _s2 = a ? {\n              plotX: p.rectPlotX,\n              plotY: p.yBottom,\n              doCurve: !1\n            } : {\n              plotX: p.plotX,\n              plotY: p.plotY,\n              doCurve: !1\n            };\n            p.isNull || n || l || t[h + 1] && !t[h + 1].isNull || i.push(_s2), d = {\n              polarPlotY: p.polarPlotY,\n              rectPlotX: p.rectPlotX,\n              yBottom: p.yBottom,\n              plotX: u(p.plotHighX, p.plotX),\n              plotY: p.plotHigh,\n              isNull: p.isNull\n            }, i.push(d), e.push(d), p.isNull || n || l || t[h - 1] && !t[h - 1].isNull || i.push(_s2);\n          }\n          var g = s.call(this, t);\n          c && (!0 === c && (c = \"left\"), o.step = {\n            left: \"right\",\n            center: \"center\",\n            right: \"left\"\n          }[c]);\n          var _f = s.call(this, e),\n            b = s.call(this, i);\n          o.step = c;\n          var m = [].concat(g, _f);\n          return !this.chart.polar && b[0] && \"M\" === b[0][0] && (b[0] = [\"L\", b[0][1], b[0][2]]), this.graphPath = m, this.areaPath = g.concat(b), m.isArea = !0, m.xMap = g.xMap, this.areaPath.xMap = g.xMap, m;\n        }\n      }, {\n        key: \"drawDataLabels\",\n        value: function drawDataLabels() {\n          var t, e, i, s, o;\n          var a = this.points,\n            n = a.length,\n            l = [],\n            h = this.options.dataLabels,\n            c = this.chart.inverted;\n          if (h) {\n            var _this$hasDataLabels, _this$hasDataLabels2;\n            if (d(h) ? (s = h[0] || {\n              enabled: !1\n            }, o = h[1] || {\n              enabled: !1\n            }) : ((s = p({}, h)).x = h.xHigh, s.y = h.yHigh, (o = p({}, h)).x = h.xLow, o.y = h.yLow), s.enabled || (_this$hasDataLabels = this.hasDataLabels) !== null && _this$hasDataLabels !== void 0 && _this$hasDataLabels.call(this)) {\n              for (t = n; t--;) if (e = a[t]) {\n                var _e2 = e,\n                  _e2$plotHigh = _e2.plotHigh,\n                  _o = _e2$plotHigh === void 0 ? 0 : _e2$plotHigh,\n                  _e2$plotLow = _e2.plotLow,\n                  _a2 = _e2$plotLow === void 0 ? 0 : _e2$plotLow;\n                i = s.inside ? _o < _a2 : _o > _a2, e.y = e.high, e._plotY = e.plotY, e.plotY = _o, l[t] = e.dataLabel, e.dataLabel = e.dataLabelUpper, e.below = i, c ? s.align || (s.align = i ? \"right\" : \"left\") : s.verticalAlign || (s.verticalAlign = i ? \"top\" : \"bottom\");\n              }\n              for (this.options.dataLabels = s, r.drawDataLabels && r.drawDataLabels.apply(this, arguments), t = n; t--;) (e = a[t]) && (e.dataLabelUpper = e.dataLabel, e.dataLabel = l[t], delete e.dataLabels, e.y = e.low, e.plotY = e._plotY);\n            }\n            if (o.enabled || (_this$hasDataLabels2 = this.hasDataLabels) !== null && _this$hasDataLabels2 !== void 0 && _this$hasDataLabels2.call(this)) {\n              for (t = n; t--;) if (e = a[t]) {\n                var _e3 = e,\n                  _e3$plotHigh = _e3.plotHigh,\n                  _t2 = _e3$plotHigh === void 0 ? 0 : _e3$plotHigh,\n                  _e3$plotLow = _e3.plotLow,\n                  _s3 = _e3$plotLow === void 0 ? 0 : _e3$plotLow;\n                i = o.inside ? _t2 < _s3 : _t2 > _s3, e.below = !i, c ? o.align || (o.align = i ? \"left\" : \"right\") : o.verticalAlign || (o.verticalAlign = i ? \"bottom\" : \"top\");\n              }\n              this.options.dataLabels = o, r.drawDataLabels && r.drawDataLabels.apply(this, arguments);\n            }\n            if (s.enabled) for (t = n; t--;) (e = a[t]) && (e.dataLabels = [e.dataLabelUpper, e.dataLabel].filter(function (t) {\n              return !!t;\n            }));\n            this.options.dataLabels = h;\n          }\n        }\n      }, {\n        key: \"alignDataLabel\",\n        value: function alignDataLabel() {\n          n.alignDataLabel.apply(this, arguments);\n        }\n      }, {\n        key: \"modifyMarkerSettings\",\n        value: function modifyMarkerSettings() {\n          var t = {\n            marker: this.options.marker,\n            symbol: this.symbol\n          };\n          if (this.options.lowMarker) {\n            var _this$options = this.options,\n              _t3 = _this$options.marker,\n              _e4 = _this$options.lowMarker;\n            this.options.marker = g(_t3, _e4), _e4.symbol && (this.symbol = _e4.symbol);\n          }\n          return t;\n        }\n      }, {\n        key: \"restoreMarkerSettings\",\n        value: function restoreMarkerSettings(t) {\n          this.options.marker = t.marker, this.symbol = t.symbol;\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t, e;\n          var i = this.points.length,\n            s = this.modifyMarkerSettings();\n          for (r.drawPoints.apply(this, arguments), this.restoreMarkerSettings(s), t = 0; t < i;) (e = this.points[t]).graphics = e.graphics || [], e.origProps = {\n            plotY: e.plotY,\n            plotX: e.plotX,\n            isInside: e.isInside,\n            negative: e.negative,\n            zone: e.zone,\n            y: e.y\n          }, (e.graphic || e.graphics[0]) && (e.graphics[0] = e.graphic), e.graphic = e.graphics[1], e.plotY = e.plotHigh, h(e.plotHighX) && (e.plotX = e.plotHighX), e.y = u(e.high, e.origProps.y), e.negative = e.y < (this.options.threshold || 0), this.zones.length && (e.zone = e.getZone()), this.chart.polar || (e.isInside = e.isTopInside = void 0 !== e.plotY && e.plotY >= 0 && e.plotY <= this.yAxis.len && e.plotX >= 0 && e.plotX <= this.xAxis.len), t++;\n          for (r.drawPoints.apply(this, arguments), t = 0; t < i;) (e = this.points[t]).graphics = e.graphics || [], (e.graphic || e.graphics[1]) && (e.graphics[1] = e.graphic), e.graphic = e.graphics[0], e.origProps && (p(e, e.origProps), delete e.origProps), t++;\n        }\n      }, {\n        key: \"hasMarkerChanged\",\n        value: function hasMarkerChanged(t, e) {\n          var i = t.lowMarker,\n            s = e.lowMarker || {};\n          return i && (!1 === i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width) || _superPropGet(f, \"hasMarkerChanged\", this, 3)([t, e]);\n        }\n      }]);\n    }(a);\n    return f.defaultOptions = g(a.defaultOptions, {\n      lineWidth: 1,\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{series.color}\">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      trackByArea: !0,\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        xLow: 0,\n        xHigh: 0,\n        yLow: 0,\n        yHigh: 0\n      }\n    }), l(f, \"afterTranslate\", function () {\n      var _this = this;\n      \"low,high\" === this.pointArrayMap.join(\",\") && this.points.forEach(function (t) {\n        var e = t.high,\n          i = t.plotY;\n        t.isNull ? t.plotY = void 0 : (t.plotLow = i, t.plotHigh = c(e) ? _this.yAxis.translate(_this.dataModify ? _this.dataModify.modifyValue(e) : e, !1, !0, void 0, !0) : void 0, _this.dataModify && (t.yBottom = t.plotHigh));\n      });\n    }, {\n      order: 0\n    }), l(f, \"afterTranslate\", function () {\n      var _this2 = this;\n      this.points.forEach(function (t) {\n        if (_this2.chart.polar) _this2.highToXY(t), t.plotLow = t.plotY, t.tooltipPos = [((t.plotHighX || 0) + (t.plotLowX || 0)) / 2, ((t.plotHigh || 0) + (t.plotLow || 0)) / 2];else {\n          var _e5 = t.pos(!1, t.plotLow),\n            _i2 = t.pos(!1, t.plotHigh);\n          _e5 && _i2 && (_e5[0] = (_e5[0] + _i2[0]) / 2, _e5[1] = (_e5[1] + _i2[1]) / 2), t.tooltipPos = _e5;\n        }\n      });\n    }, {\n      order: 3\n    }), p(f.prototype, {\n      deferTranslatePolar: !0,\n      pointArrayMap: [\"low\", \"high\"],\n      pointClass: t,\n      pointValKey: \"low\",\n      setStackedPoints: o\n    }), i.registerSeriesType(\"arearange\", f), f;\n  }), i(e, \"Series/AreaSplineRange/AreaSplineRangeSeries.js\", [e[\"Series/AreaRange/AreaRangeSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.seriesTypes.spline.prototype,\n      o = i.merge,\n      a = i.extend;\n    var r = /*#__PURE__*/function (_t4) {\n      function r() {\n        _classCallCheck(this, r);\n        return _callSuper(this, r, arguments);\n      }\n      _inherits(r, _t4);\n      return _createClass(r);\n    }(t);\n    return r.defaultOptions = o(t.defaultOptions), a(r.prototype, {\n      getPointSpline: s.getPointSpline\n    }), e.registerSeriesType(\"areasplinerange\", r), r;\n  }), i(e, \"Series/BoxPlot/BoxPlotSeriesDefaults.js\", [], function () {\n    return {\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">●</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'\n      },\n      whiskerLength: \"50%\",\n      fillColor: \"#ffffff\",\n      lineWidth: 1,\n      medianWidth: 2,\n      whiskerWidth: 2\n    };\n  }), i(e, \"Series/BoxPlot/BoxPlotSeries.js\", [e[\"Series/BoxPlot/BoxPlotSeriesDefaults.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    var a = i.noop,\n      r = o.crisp,\n      n = o.extend,\n      l = o.merge,\n      h = o.pick;\n    var p = /*#__PURE__*/function (_e6) {\n      function p() {\n        _classCallCheck(this, p);\n        return _callSuper(this, p, arguments);\n      }\n      _inherits(p, _e6);\n      return _createClass(p, [{\n        key: \"pointAttribs\",\n        value: function pointAttribs() {\n          return {};\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          var t = this.yAxis,\n            e = this.pointArrayMap;\n          _superPropGet(p, \"translate\", this, 1).apply(this), this.points.forEach(function (i) {\n            e.forEach(function (e) {\n              null !== i[e] && (i[e + \"Plot\"] = t.translate(i[e], 0, 1, 0, 1));\n            }), i.plotHigh = i.highPlot;\n          });\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t, e, i, s, o, a, n, l, _p, d, c, u, g;\n          var f = this.points,\n            b = this.options,\n            m = this.chart,\n            y = m.renderer,\n            x = !1 !== this.doQuartiles,\n            P = this.options.whiskerLength;\n          var _iterator = _createForOfIteratorHelper(f),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var S = _step.value;\n              var _f2 = (l = S.graphic) ? \"animate\" : \"attr\",\n                M = S.shapeArgs,\n                L = {},\n                C = {},\n                k = {},\n                v = {},\n                A = S.color || this.color;\n              if (void 0 !== S.plotY) {\n                var w = void 0;\n                _p = M.width, c = (d = M.x) + _p, u = _p / 2, t = x ? S.q1Plot : S.lowPlot, e = x ? S.q3Plot : S.lowPlot, i = S.highPlot, s = S.lowPlot, l || (S.graphic = l = y.g(\"point\").add(this.group), S.stem = y.path().addClass(\"highcharts-boxplot-stem\").add(l), P && (S.whiskers = y.path().addClass(\"highcharts-boxplot-whisker\").add(l)), x && (S.box = y.path(n).addClass(\"highcharts-boxplot-box\").add(l)), S.medianShape = y.path(a).addClass(\"highcharts-boxplot-median\").add(l)), m.styledMode || (C.stroke = S.stemColor || b.stemColor || A, C[\"stroke-width\"] = h(S.stemWidth, b.stemWidth, b.lineWidth), C.dashstyle = S.stemDashStyle || b.stemDashStyle || b.dashStyle, S.stem.attr(C), P && (k.stroke = S.whiskerColor || b.whiskerColor || A, k[\"stroke-width\"] = h(S.whiskerWidth, b.whiskerWidth, b.lineWidth), k.dashstyle = S.whiskerDashStyle || b.whiskerDashStyle || b.dashStyle, S.whiskers.attr(k)), x && (L.fill = S.fillColor || b.fillColor || A, L.stroke = b.lineColor || A, L[\"stroke-width\"] = b.lineWidth || 0, L.dashstyle = S.boxDashStyle || b.boxDashStyle || b.dashStyle, S.box.attr(L)), v.stroke = S.medianColor || b.medianColor || A, v[\"stroke-width\"] = h(S.medianWidth, b.medianWidth, b.lineWidth), v.dashstyle = S.medianDashStyle || b.medianDashStyle || b.dashStyle, S.medianShape.attr(v));\n                var T = r((S.plotX || 0) + (this.pointXOffset || 0) + (this.barW || 0) / 2, S.stem.strokeWidth());\n                if (w = [[\"M\", T, e], [\"L\", T, i], [\"M\", T, t], [\"L\", T, s]], S.stem[_f2]({\n                  d: w\n                }), x) {\n                  var _i3 = S.box.strokeWidth();\n                  t = r(t, _i3), e = r(e, _i3), w = [[\"M\", d = r(d, _i3), e], [\"L\", d, t], [\"L\", c = r(c, _i3), t], [\"L\", c, e], [\"L\", d, e], [\"Z\"]], S.box[_f2]({\n                    d: w\n                  });\n                }\n                if (P) {\n                  var _t5 = S.whiskers.strokeWidth();\n                  i = r(S.highPlot, _t5), s = r(S.lowPlot, _t5), w = [[\"M\", r(T - (g = \"string\" == typeof P && /%$/.test(P) ? u * parseFloat(P) / 100 : Number(P) / 2)), i], [\"L\", r(T + g), i], [\"M\", r(T - g), s], [\"L\", r(T + g), s]], S.whiskers[_f2]({\n                    d: w\n                  });\n                }\n                w = [[\"M\", d, o = r(S.medianPlot, S.medianShape.strokeWidth())], [\"L\", c, o]], S.medianShape[_f2]({\n                  d: w\n                });\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }, {\n        key: \"toYData\",\n        value: function toYData(t) {\n          return [t.low, t.q1, t.median, t.q3, t.high];\n        }\n      }]);\n    }(e);\n    return p.defaultOptions = l(e.defaultOptions, t), n(p.prototype, {\n      pointArrayMap: [\"low\", \"q1\", \"median\", \"q3\", \"high\"],\n      pointValKey: \"high\",\n      drawDataLabels: a,\n      setStackedPoints: a\n    }), s.registerSeriesType(\"boxplot\", p), p;\n  }), i(e, \"Series/Bubble/BubbleLegendDefaults.js\", [], function () {\n    return {\n      borderColor: void 0,\n      borderWidth: 2,\n      className: void 0,\n      color: void 0,\n      connectorClassName: void 0,\n      connectorColor: void 0,\n      connectorDistance: 60,\n      connectorWidth: 1,\n      enabled: !1,\n      labels: {\n        className: void 0,\n        allowOverlap: !1,\n        format: \"\",\n        formatter: void 0,\n        align: \"right\",\n        style: {\n          fontSize: \"0.9em\",\n          color: \"#000000\"\n        },\n        x: 0,\n        y: 0\n      },\n      maxSize: 60,\n      minSize: 10,\n      legendIndex: 0,\n      ranges: {\n        value: void 0,\n        borderColor: void 0,\n        color: void 0,\n        connectorColor: void 0\n      },\n      sizeBy: \"area\",\n      sizeByAbsoluteValue: !1,\n      zIndex: 1,\n      zThreshold: 0\n    };\n  }), i(e, \"Series/Bubble/BubbleLegendItem.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o = t.parse,\n      a = i.noop,\n      r = s.arrayMax,\n      n = s.arrayMin,\n      l = s.isNumber,\n      h = s.merge,\n      p = s.pick,\n      d = s.stableSort;\n    return /*#__PURE__*/function () {\n      function _class2(t, e) {\n        _classCallCheck(this, _class2);\n        this.setState = a, this.init(t, e);\n      }\n      return _createClass(_class2, [{\n        key: \"init\",\n        value: function init(t, e) {\n          this.options = t, this.visible = !0, this.chart = e.chart, this.legend = e;\n        }\n      }, {\n        key: \"addToLegend\",\n        value: function addToLegend(t) {\n          t.splice(this.options.legendIndex, 0, this);\n        }\n      }, {\n        key: \"drawLegendSymbol\",\n        value: function drawLegendSymbol(t) {\n          var e;\n          var i = p(t.options.itemDistance, 20),\n            s = this.legendItem || {},\n            o = this.options,\n            a = o.ranges,\n            r = o.connectorDistance;\n          if (!a || !a.length || !l(a[0].value)) {\n            t.options.bubbleLegend.autoRanges = !0;\n            return;\n          }\n          d(a, function (t, e) {\n            return e.value - t.value;\n          }), this.ranges = a, this.setOptions(), this.render();\n          var n = this.getMaxLabelSize(),\n            h = this.ranges[0].radius,\n            c = 2 * h;\n          e = (e = r - h + n.width) > 0 ? e : 0, this.maxLabel = n, this.movementX = \"left\" === o.labels.align ? e : 0, s.labelWidth = c + e + i, s.labelHeight = c + n.height / 2;\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions() {\n          var t = this.ranges,\n            e = this.options,\n            i = this.chart.series[e.seriesIndex],\n            s = this.legend.baseline,\n            a = {\n              zIndex: e.zIndex,\n              \"stroke-width\": e.borderWidth\n            },\n            r = {\n              zIndex: e.zIndex,\n              \"stroke-width\": e.connectorWidth\n            },\n            n = {\n              align: this.legend.options.rtl || \"left\" === e.labels.align ? \"right\" : \"left\",\n              zIndex: e.zIndex\n            },\n            l = i.options.marker.fillOpacity,\n            d = this.chart.styledMode;\n          t.forEach(function (c, u) {\n            d || (a.stroke = p(c.borderColor, e.borderColor, i.color), a.fill = p(c.color, e.color, 1 !== l ? o(i.color).setOpacity(l).get(\"rgba\") : i.color), r.stroke = p(c.connectorColor, e.connectorColor, i.color)), t[u].radius = this.getRangeRadius(c.value), t[u] = h(t[u], {\n              center: t[0].radius - t[u].radius + s\n            }), d || h(!0, t[u], {\n              bubbleAttribs: h(a),\n              connectorAttribs: h(r),\n              labelAttribs: n\n            });\n          }, this);\n        }\n      }, {\n        key: \"getRangeRadius\",\n        value: function getRangeRadius(t) {\n          var e = this.options,\n            i = this.options.seriesIndex,\n            s = this.chart.series[i],\n            o = e.ranges[0].value,\n            a = e.ranges[e.ranges.length - 1].value,\n            r = e.minSize,\n            n = e.maxSize;\n          return s.getRadius.call(this, a, o, r, n, t);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t = this.legendItem || {},\n            e = this.chart.renderer,\n            i = this.options.zThreshold;\n          var _iterator2 = _createForOfIteratorHelper((this.symbols || (this.symbols = {\n              connectors: [],\n              bubbleItems: [],\n              labels: []\n            }), t.symbol = e.g(\"bubble-legend\"), t.label = e.g(\"bubble-legend-item\").css(this.legend.itemStyle || {}), t.symbol.translateX = 0, t.symbol.translateY = 0, t.symbol.add(t.label), t.label.add(t.group), this.ranges)),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _s4 = _step2.value;\n              _s4.value >= i && this.renderRange(_s4);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          this.hideOverlappingLabels();\n        }\n      }, {\n        key: \"renderRange\",\n        value: function renderRange(t) {\n          var e = this.ranges[0],\n            i = this.legend,\n            s = this.options,\n            o = s.labels,\n            a = this.chart,\n            r = a.series[s.seriesIndex],\n            n = a.renderer,\n            l = this.symbols,\n            h = l.labels,\n            p = t.center,\n            d = Math.abs(t.radius),\n            c = s.connectorDistance || 0,\n            u = o.align,\n            g = i.options.rtl,\n            f = s.borderWidth,\n            b = s.connectorWidth,\n            m = e.radius || 0,\n            y = p - d - f / 2 + b / 2,\n            x = (y % 1 ? 1 : .5) - (b % 2 ? 0 : .5),\n            P = n.styledMode,\n            S = g || \"left\" === u ? -c : c;\n          \"center\" === u && (S = 0, s.connectorDistance = 0, t.labelAttribs.align = \"center\"), l.bubbleItems.push(n.circle(m, p + x, d).attr(P ? {} : t.bubbleAttribs).addClass((P ? \"highcharts-color-\" + r.colorIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (s.className || \"\")).add(this.legendItem.symbol)), l.connectors.push(n.path(n.crispLine([[\"M\", m, y], [\"L\", m + S, y]], s.connectorWidth)).attr(P ? {} : t.connectorAttribs).addClass((P ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (s.connectorClassName || \"\")).add(this.legendItem.symbol));\n          var M = n.text(this.formatLabel(t)).attr(P ? {} : t.labelAttribs).css(P ? {} : o.style).addClass(\"highcharts-bubble-legend-labels \" + (s.labels.className || \"\")).add(this.legendItem.symbol),\n            L = {\n              x: m + S + s.labels.x,\n              y: y + s.labels.y + .4 * M.getBBox().height\n            };\n          M.attr(L), h.push(M), M.placed = !0, M.alignAttr = L;\n        }\n      }, {\n        key: \"getMaxLabelSize\",\n        value: function getMaxLabelSize() {\n          var t, e;\n          return this.symbols.labels.forEach(function (i) {\n            e = i.getBBox(!0), t = t ? e.width > t.width ? e : t : e;\n          }), t || {};\n        }\n      }, {\n        key: \"formatLabel\",\n        value: function formatLabel(t) {\n          var i = this.options,\n            s = i.labels.formatter,\n            o = i.labels.format,\n            a = this.chart.numberFormatter;\n          return o ? e.format(o, t) : s ? s.call(t) : a(t.value, 1);\n        }\n      }, {\n        key: \"hideOverlappingLabels\",\n        value: function hideOverlappingLabels() {\n          var t = this.chart,\n            e = this.options.labels.allowOverlap,\n            i = this.symbols;\n          !e && i && (t.hideOverlappingLabels(i.labels), i.labels.forEach(function (t, e) {\n            t.newOpacity ? t.newOpacity !== t.oldOpacity && i.connectors[e].show() : i.connectors[e].hide();\n          }));\n        }\n      }, {\n        key: \"getRanges\",\n        value: function getRanges() {\n          var t = this.legend.bubbleLegend,\n            e = t.chart.series,\n            i = t.options.ranges,\n            s,\n            o,\n            a = Number.MAX_VALUE,\n            d = -Number.MAX_VALUE;\n          return e.forEach(function (t) {\n            t.isBubble && !t.ignoreSeries && (o = t.zData.filter(l)).length && (a = p(t.options.zMin, Math.min(a, Math.max(n(o), !1 === t.options.displayNegative ? t.options.zThreshold : -Number.MAX_VALUE))), d = p(t.options.zMax, Math.max(d, r(o))));\n          }), s = a === d ? [{\n            value: d\n          }] : [{\n            value: a\n          }, {\n            value: (a + d) / 2\n          }, {\n            value: d,\n            autoRanges: !0\n          }], i.length && i[0].radius && s.reverse(), s.forEach(function (t, e) {\n            i && i[e] && (s[e] = h(i[e], t));\n          }), s;\n        }\n      }, {\n        key: \"predictBubbleSizes\",\n        value: function predictBubbleSizes() {\n          var t = this.chart,\n            e = t.legend.options,\n            i = e.floating,\n            s = \"horizontal\" === e.layout,\n            o = s ? t.legend.lastLineHeight : 0,\n            a = t.plotSizeX,\n            r = t.plotSizeY,\n            n = t.series[this.options.seriesIndex],\n            l = n.getPxExtremes(),\n            h = Math.ceil(l.minPxSize),\n            p = Math.ceil(l.maxPxSize),\n            d = Math.min(r, a),\n            c,\n            u = n.options.maxSize;\n          return i || !/%$/.test(u) ? c = p : (c = (d + o) * (u = parseFloat(u)) / 100 / (u / 100 + 1), (s && r - c >= a || !s && a - c >= r) && (c = p)), [h, Math.ceil(c)];\n        }\n      }, {\n        key: \"updateRanges\",\n        value: function updateRanges(t, e) {\n          var i = this.legend.options.bubbleLegend;\n          i.minSize = t, i.maxSize = e, i.ranges = this.getRanges();\n        }\n      }, {\n        key: \"correctSizes\",\n        value: function correctSizes() {\n          var t = this.legend,\n            e = this.chart.series[this.options.seriesIndex].getPxExtremes();\n          Math.abs(Math.ceil(e.maxPxSize) - this.options.maxSize) > 1 && (this.updateRanges(this.options.minSize, e.maxPxSize), t.render());\n        }\n      }]);\n    }();\n  }), i(e, \"Series/Bubble/BubbleLegendComposition.js\", [e[\"Series/Bubble/BubbleLegendDefaults.js\"], e[\"Series/Bubble/BubbleLegendItem.js\"], e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    var a = i.setOptions,\n      r = s.composed,\n      n = o.addEvent,\n      l = o.objectEach,\n      h = o.pushUnique,\n      p = o.wrap;\n    function d(t, e, i) {\n      var s, o, a;\n      var r = this.legend,\n        n = c(this) >= 0;\n      r && r.options.enabled && r.bubbleLegend && r.options.bubbleLegend.autoRanges && n ? (s = r.bubbleLegend.options, o = r.bubbleLegend.predictBubbleSizes(), r.bubbleLegend.updateRanges(o[0], o[1]), s.placed || (r.group.placed = !1, r.allItems.forEach(function (t) {\n        (a = t.legendItem || {}).group && (a.group.translateY = void 0);\n      })), r.render(), s.placed || (this.getMargins(), this.axes.forEach(function (t) {\n        t.visible && t.render(), s.placed || (t.setScale(), t.updateNames(), l(t.ticks, function (t) {\n          t.isNew = !0, t.isNewLabel = !0;\n        }));\n      }), this.getMargins()), s.placed = !0, t.call(this, e, i), r.bubbleLegend.correctSizes(), b(r, u(r))) : (t.call(this, e, i), r && r.options.enabled && r.bubbleLegend && (r.render(), b(r, u(r))));\n    }\n    function c(t) {\n      var e = t.series,\n        i = 0;\n      for (; i < e.length;) {\n        if (e[i] && e[i].isBubble && e[i].visible && e[i].zData.length) return i;\n        i++;\n      }\n      return -1;\n    }\n    function u(t) {\n      var e = t.allItems,\n        i = [],\n        s = e.length,\n        o,\n        a,\n        r,\n        n = 0,\n        l = 0;\n      for (n = 0; n < s; n++) if (a = e[n].legendItem || {}, r = (e[n + 1] || {}).legendItem || {}, a.labelHeight && (e[n].itemHeight = a.labelHeight), e[n] === e[s - 1] || a.y !== r.y) {\n        for (i.push({\n          height: 0\n        }), o = i[i.length - 1]; l <= n; l++) e[l].itemHeight > o.height && (o.height = e[l].itemHeight);\n        o.step = n;\n      }\n      return i;\n    }\n    function g(t) {\n      var i = this.bubbleLegend,\n        s = this.options,\n        o = s.bubbleLegend,\n        a = c(this.chart);\n      i && i.ranges && i.ranges.length && (o.ranges.length && (o.autoRanges = !!o.ranges[0].autoRanges), this.destroyItem(i)), a >= 0 && s.enabled && o.enabled && (o.seriesIndex = a, this.bubbleLegend = new e(o, this), this.bubbleLegend.addToLegend(t.allItems));\n    }\n    function f(t) {\n      var e;\n      if (t.defaultPrevented) return !1;\n      var i = t.legendItem,\n        s = this.chart,\n        o = i.visible;\n      this && this.bubbleLegend && (i.visible = !o, i.ignoreSeries = o, e = c(s) >= 0, this.bubbleLegend.visible !== e && (this.update({\n        bubbleLegend: {\n          enabled: e\n        }\n      }), this.bubbleLegend.visible = e), i.visible = o);\n    }\n    function b(t, e) {\n      var i = t.allItems,\n        s = t.options.rtl,\n        o,\n        a,\n        r,\n        n,\n        l = 0;\n      i.forEach(function (t, i) {\n        (n = t.legendItem || {}).group && (o = n.group.translateX || 0, a = n.y || 0, ((r = t.movementX) || s && t.ranges) && (r = s ? o - t.options.maxSize / 2 : o + r, n.group.attr({\n          translateX: r\n        })), i > e[l].step && l++, n.group.attr({\n          translateY: Math.round(a + e[l].height / 2)\n        }), n.y = a + e[l].height / 2);\n      });\n    }\n    return {\n      compose: function compose(e, i) {\n        h(r, \"Series.BubbleLegend\") && (a({\n          legend: {\n            bubbleLegend: t\n          }\n        }), p(e.prototype, \"drawChartBox\", d), n(i, \"afterGetAllItems\", g), n(i, \"itemClick\", f));\n      }\n    };\n  }), i(e, \"Series/Bubble/BubblePoint.js\", [e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.seriesTypes.scatter.prototype.pointClass,\n      o = i.extend;\n    var a = /*#__PURE__*/function (_s5) {\n      function a() {\n        _classCallCheck(this, a);\n        return _callSuper(this, a, arguments);\n      }\n      _inherits(a, _s5);\n      return _createClass(a, [{\n        key: \"haloPath\",\n        value: function haloPath(e) {\n          var i = (e && this.marker && this.marker.radius || 0) + e;\n          if (this.series.chart.inverted) {\n            var _t6 = this.pos() || [0, 0],\n              _this$series = this.series,\n              _e7 = _this$series.xAxis,\n              _s6 = _this$series.yAxis,\n              _o2 = _this$series.chart;\n            return _o2.renderer.symbols.circle(_e7.len - _t6[1] - i, _s6.len - _t6[0] - i, 2 * i, 2 * i);\n          }\n          return t.prototype.haloPath.call(this, i);\n        }\n      }]);\n    }(s);\n    return o(a.prototype, {\n      ttBelow: !1\n    }), a;\n  }), i(e, \"Series/Bubble/BubbleSeries.js\", [e[\"Series/Bubble/BubbleLegendComposition.js\"], e[\"Series/Bubble/BubblePoint.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, a) {\n    var r = i.parse,\n      n = s.composed,\n      l = s.noop,\n      h = o.series,\n      _o$seriesTypes = o.seriesTypes,\n      p = _o$seriesTypes.column.prototype,\n      d = _o$seriesTypes.scatter,\n      c = a.addEvent,\n      u = a.arrayMax,\n      g = a.arrayMin,\n      f = a.clamp,\n      b = a.extend,\n      m = a.isNumber,\n      y = a.merge,\n      x = a.pick,\n      P = a.pushUnique;\n    function S() {\n      var _this3 = this;\n      var t = this.len,\n        e = this.coll,\n        i = this.isXAxis,\n        s = this.min,\n        o = i ? \"xData\" : \"yData\",\n        a = (this.max || 0) - (s || 0),\n        r = 0,\n        n = t,\n        l = t / a,\n        h;\n      (\"xAxis\" === e || \"yAxis\" === e) && (this.series.forEach(function (t) {\n        if (t.bubblePadding && t.reserveSpace()) {\n          _this3.allowZoomOutside = !0, h = !0;\n          var _e8 = t[o];\n          if (i && ((t.onPoint || t).getRadii(0, 0, t), t.onPoint && (t.radii = t.onPoint.radii)), a > 0) {\n            var _i4 = _e8.length;\n            for (; _i4--;) if (m(_e8[_i4]) && _this3.dataMin <= _e8[_i4] && _e8[_i4] <= _this3.max) {\n              var _o3 = t.radii && t.radii[_i4] || 0;\n              r = Math.min((_e8[_i4] - s) * l - _o3, r), n = Math.max((_e8[_i4] - s) * l + _o3, n);\n            }\n          }\n        }\n      }), h && a > 0 && !this.logarithmic && (n -= t, l *= (t + Math.max(0, r) - Math.min(n, t)) / t, [[\"min\", \"userMin\", r], [\"max\", \"userMax\", n]].forEach(function (t) {\n        void 0 === x(_this3.options[t[0]], _this3[t[1]]) && (_this3[t[0]] += t[2] / l);\n      })));\n    }\n    var M = /*#__PURE__*/function (_d) {\n      function M() {\n        _classCallCheck(this, M);\n        return _callSuper(this, M, arguments);\n      }\n      _inherits(M, _d);\n      return _createClass(M, [{\n        key: \"animate\",\n        value: function animate(t) {\n          !t && this.points.length < this.options.animationLimit && this.points.forEach(function (t) {\n            var e = t.graphic,\n              _t$plotX = t.plotX,\n              i = _t$plotX === void 0 ? 0 : _t$plotX,\n              _t$plotY = t.plotY,\n              s = _t$plotY === void 0 ? 0 : _t$plotY;\n            e && e.width && (this.hasRendered || e.attr({\n              x: i,\n              y: s,\n              width: 1,\n              height: 1\n            }), e.animate(this.markerAttribs(t), this.options.animation));\n          }, this);\n        }\n      }, {\n        key: \"getRadii\",\n        value: function getRadii() {\n          var t = this.zData,\n            e = this.yData,\n            i = [],\n            s,\n            o,\n            a,\n            r = this.chart.bubbleZExtremes,\n            _this$getPxExtremes = this.getPxExtremes(),\n            n = _this$getPxExtremes.minPxSize,\n            l = _this$getPxExtremes.maxPxSize;\n          if (!r) {\n            var _t7,\n              _e9 = Number.MAX_VALUE,\n              _i5 = -Number.MAX_VALUE;\n            this.chart.series.forEach(function (s) {\n              if (s.bubblePadding && s.reserveSpace()) {\n                var _o4 = (s.onPoint || s).getZExtremes();\n                _o4 && (_e9 = Math.min(x(_e9, _o4.zMin), _o4.zMin), _i5 = Math.max(x(_i5, _o4.zMax), _o4.zMax), _t7 = !0);\n              }\n            }), _t7 ? (r = {\n              zMin: _e9,\n              zMax: _i5\n            }, this.chart.bubbleZExtremes = r) : r = {\n              zMin: 0,\n              zMax: 0\n            };\n          }\n          for (o = 0, s = t.length; o < s; o++) a = t[o], i.push(this.getRadius(r.zMin, r.zMax, n, l, a, e && e[o]));\n          this.radii = i;\n        }\n      }, {\n        key: \"getRadius\",\n        value: function getRadius(t, e, i, s, o, a) {\n          var r = this.options,\n            n = \"width\" !== r.sizeBy,\n            l = r.zThreshold,\n            h = e - t,\n            p = .5;\n          if (null === a || null === o) return null;\n          if (m(o)) {\n            if (r.sizeByAbsoluteValue && (o = Math.abs(o - l), e = h = Math.max(e - l, Math.abs(t - l)), t = 0), o < t) return i / 2 - 1;\n            h > 0 && (p = (o - t) / h);\n          }\n          return n && p >= 0 && (p = Math.sqrt(p)), Math.ceil(i + p * (s - i)) / 2;\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return !!this.processedXData.length;\n        }\n      }, {\n        key: \"markerAttribs\",\n        value: function markerAttribs(t, e) {\n          var i = _superPropGet(M, \"markerAttribs\", this, 3)([t, e]),\n            _i$height = i.height,\n            s = _i$height === void 0 ? 0 : _i$height,\n            _i$width = i.width,\n            o = _i$width === void 0 ? 0 : _i$width;\n          return this.chart.inverted ? b(i, {\n            x: (t.plotX || 0) - o / 2,\n            y: (t.plotY || 0) - s / 2\n          }) : i;\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(t, e) {\n          var i = this.options.marker.fillOpacity,\n            s = h.prototype.pointAttribs.call(this, t, e);\n          return 1 !== i && (s.fill = r(s.fill).setOpacity(i).get(\"rgba\")), s;\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          _superPropGet(M, \"translate\", this, 1).call(this), this.getRadii(), this.translateBubble();\n        }\n      }, {\n        key: \"translateBubble\",\n        value: function translateBubble() {\n          var t = this.data,\n            e = this.options,\n            i = this.radii,\n            _this$getPxExtremes2 = this.getPxExtremes(),\n            s = _this$getPxExtremes2.minPxSize,\n            o = t.length;\n          for (; o--;) {\n            var _a3 = t[o],\n              _r = i ? i[o] : 0;\n            \"z\" === this.zoneAxis && (_a3.negative = (_a3.z || 0) < (e.zThreshold || 0)), m(_r) && _r >= s / 2 ? (_a3.marker = b(_a3.marker, {\n              radius: _r,\n              width: 2 * _r,\n              height: 2 * _r\n            }), _a3.dlBox = {\n              x: _a3.plotX - _r,\n              y: _a3.plotY - _r,\n              width: 2 * _r,\n              height: 2 * _r\n            }) : (_a3.shapeArgs = _a3.plotY = _a3.dlBox = void 0, _a3.isInside = !1);\n          }\n        }\n      }, {\n        key: \"getPxExtremes\",\n        value: function getPxExtremes() {\n          var t = Math.min(this.chart.plotWidth, this.chart.plotHeight),\n            e = function e(_e10) {\n              var i;\n              return \"string\" == typeof _e10 && (i = /%$/.test(_e10), _e10 = parseInt(_e10, 10)), i ? t * _e10 / 100 : _e10;\n            },\n            i = e(x(this.options.minSize, 8)),\n            s = Math.max(e(x(this.options.maxSize, \"20%\")), i);\n          return {\n            minPxSize: i,\n            maxPxSize: s\n          };\n        }\n      }, {\n        key: \"getZExtremes\",\n        value: function getZExtremes() {\n          var t = this.options,\n            e = (this.zData || []).filter(m);\n          if (e.length) {\n            var _i6 = x(t.zMin, f(g(e), !1 === t.displayNegative ? t.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE)),\n              _s7 = x(t.zMax, u(e));\n            if (m(_i6) && m(_s7)) return {\n              zMin: _i6,\n              zMax: _s7\n            };\n          }\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(e, i, s) {\n          t.compose(i, s), P(n, \"Series.Bubble\") && c(e, \"foundExtremes\", S);\n        }\n      }]);\n    }(d);\n    return M.defaultOptions = y(d.defaultOptions, {\n      dataLabels: {\n        formatter: function formatter() {\n          var t = this.series.chart.numberFormatter,\n            e = this.point.z;\n          return m(e) ? t(e, -1) : \"\";\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      animationLimit: 250,\n      marker: {\n        lineColor: null,\n        lineWidth: 1,\n        fillOpacity: .5,\n        radius: null,\n        states: {\n          hover: {\n            radiusPlus: 0\n          }\n        },\n        symbol: \"circle\"\n      },\n      minSize: 8,\n      maxSize: \"20%\",\n      softThreshold: !1,\n      states: {\n        hover: {\n          halo: {\n            size: 5\n          }\n        }\n      },\n      tooltip: {\n        pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n      },\n      turboThreshold: 0,\n      zThreshold: 0,\n      zoneAxis: \"z\"\n    }), b(M.prototype, {\n      alignDataLabel: p.alignDataLabel,\n      applyZones: l,\n      bubblePadding: !0,\n      isBubble: !0,\n      pointArrayMap: [\"y\", \"z\"],\n      pointClass: e,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      zoneAxis: \"z\"\n    }), c(M, \"updatedData\", function (t) {\n      delete t.target.chart.bubbleZExtremes;\n    }), c(M, \"remove\", function (t) {\n      delete t.target.chart.bubbleZExtremes;\n    }), o.registerSeriesType(\"bubble\", M), M;\n  }), i(e, \"Series/ColumnRange/ColumnRangePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var _t$seriesTypes = t.seriesTypes,\n      i = _t$seriesTypes.column.prototype.pointClass.prototype,\n      s = _t$seriesTypes.arearange.prototype.pointClass,\n      o = e.extend,\n      a = e.isNumber;\n    var r = /*#__PURE__*/function (_s8) {\n      function r() {\n        _classCallCheck(this, r);\n        return _callSuper(this, r, arguments);\n      }\n      _inherits(r, _s8);\n      return _createClass(r, [{\n        key: \"isValid\",\n        value: function isValid() {\n          return a(this.low);\n        }\n      }]);\n    }(s);\n    return o(r.prototype, {\n      setState: i.setState\n    }), r;\n  }), i(e, \"Series/ColumnRange/ColumnRangeSeries.js\", [e[\"Series/ColumnRange/ColumnRangePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o = e.noop,\n      _i$seriesTypes2 = i.seriesTypes,\n      a = _i$seriesTypes2.arearange,\n      r = _i$seriesTypes2.column,\n      n = _i$seriesTypes2.column.prototype,\n      l = s.addEvent,\n      h = s.clamp,\n      p = s.extend,\n      d = s.isNumber,\n      c = s.merge,\n      u = s.pick;\n    var g = /*#__PURE__*/function (_a4) {\n      function g() {\n        _classCallCheck(this, g);\n        return _callSuper(this, g, arguments);\n      }\n      _inherits(g, _a4);\n      return _createClass(g, [{\n        key: \"setOptions\",\n        value: function setOptions() {\n          return c(!0, arguments[0], {\n            stacking: void 0\n          }), a.prototype.setOptions.apply(this, arguments);\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          return n.translate.apply(this);\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs() {\n          return n.pointAttribs.apply(this, arguments);\n        }\n      }, {\n        key: \"translate3dPoints\",\n        value: function translate3dPoints() {\n          return n.translate3dPoints.apply(this, arguments);\n        }\n      }, {\n        key: \"translate3dShapes\",\n        value: function translate3dShapes() {\n          return n.translate3dShapes.apply(this, arguments);\n        }\n      }, {\n        key: \"afterColumnTranslate\",\n        value: function afterColumnTranslate() {\n          var _this4 = this;\n          var t, e, i, s;\n          var o = this.yAxis,\n            a = this.xAxis,\n            r = a.startAngleRad,\n            n = this.chart,\n            l = this.xAxis.isRadial,\n            p = Math.max(n.chartWidth, n.chartHeight) + 999;\n          this.points.forEach(function (_g) {\n            var f = _g.shapeArgs || {},\n              b = _this4.options.minPointLength,\n              m = _g.plotY,\n              y = o.translate(_g.high, 0, 1, 0, 1);\n            if (d(y) && d(m)) {\n              if (_g.plotHigh = h(y, -p, p), _g.plotLow = h(m, -p, p), s = _g.plotHigh, Math.abs(t = u(_g.rectPlotY, _g.plotY) - _g.plotHigh) < b ? (e = b - t, t += e, s -= e / 2) : t < 0 && (t *= -1, s -= t), l && _this4.polar) i = _g.barX + r, _g.shapeType = \"arc\", _g.shapeArgs = _this4.polar.arc(s + t, s, i, i + _g.pointWidth);else {\n                f.height = t, f.y = s;\n                var _f$x = f.x,\n                  _e11 = _f$x === void 0 ? 0 : _f$x,\n                  _f$width = f.width,\n                  _i7 = _f$width === void 0 ? 0 : _f$width;\n                _g.shapeArgs = c(_g.shapeArgs, _this4.crispCol(_e11, s, _i7, t)), _g.tooltipPos = n.inverted ? [o.len + o.pos - n.plotLeft - s - t / 2, a.len + a.pos - n.plotTop - _e11 - _i7 / 2, t] : [a.left - n.plotLeft + _e11 + _i7 / 2, o.pos - n.plotTop + s + t / 2, t];\n              }\n            }\n          });\n        }\n      }]);\n    }(a);\n    return g.defaultOptions = c(r.defaultOptions, a.defaultOptions, {\n      borderRadius: {\n        where: \"all\"\n      },\n      pointRange: null,\n      legendSymbol: \"rectangle\",\n      marker: null,\n      states: {\n        hover: {\n          halo: !1\n        }\n      }\n    }), l(g, \"afterColumnTranslate\", function () {\n      g.prototype.afterColumnTranslate.apply(this);\n    }, {\n      order: 5\n    }), p(g.prototype, {\n      directTouch: !0,\n      pointClass: t,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      adjustForMissingColumns: n.adjustForMissingColumns,\n      animate: n.animate,\n      crispCol: n.crispCol,\n      drawGraph: o,\n      drawPoints: n.drawPoints,\n      getSymbol: o,\n      drawTracker: n.drawTracker,\n      getColumnMetrics: n.getColumnMetrics\n    }), i.registerSeriesType(\"columnrange\", g), g;\n  }), i(e, \"Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js\", [], function () {\n    return {};\n  }), i(e, \"Series/ColumnPyramid/ColumnPyramidSeries.js\", [e[\"Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.seriesTypes.column,\n      o = i.clamp,\n      a = i.merge,\n      r = i.pick;\n    var n = /*#__PURE__*/function (_s9) {\n      function n() {\n        _classCallCheck(this, n);\n        return _callSuper(this, n, arguments);\n      }\n      _inherits(n, _s9);\n      return _createClass(n, [{\n        key: \"translate\",\n        value: function translate() {\n          var t = this.chart,\n            e = this.options,\n            i = this.dense = this.closestPointRange * this.xAxis.transA < 2,\n            s = this.borderWidth = r(e.borderWidth, i ? 0 : 1),\n            a = this.yAxis,\n            _n = e.threshold,\n            l = r(e.minPointLength, 5),\n            h = this.getColumnMetrics(),\n            p = h.width,\n            d = this.pointXOffset = h.offset,\n            c = this.translatedThreshold = a.getThreshold(_n),\n            u = this.barW = Math.max(p, 1 + 2 * s);\n          var _iterator3 = _createForOfIteratorHelper((t.inverted && (c -= .5), e.pointPadding && (u = Math.ceil(u)), _superPropGet(n, \"translate\", this, 3)([]), this.points)),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _i8 = _step3.value;\n              var _s10 = r(_i8.yBottom, c),\n                g = 999 + Math.abs(_s10),\n                f = o(_i8.plotY, -g, a.len + g),\n                b = u / 2,\n                m = Math.min(f, _s10),\n                y = Math.max(f, _s10) - m,\n                x = _i8.plotX + d,\n                P = void 0,\n                S = void 0,\n                M = void 0,\n                L = void 0,\n                C = void 0,\n                k = void 0,\n                v = void 0,\n                A = void 0,\n                w = void 0,\n                T = void 0,\n                N = void 0;\n              e.centerInCategory && (x = this.adjustForMissingColumns(x, p, _i8, h)), _i8.barX = x, _i8.pointWidth = p, _i8.tooltipPos = t.inverted ? [a.len + a.pos - t.plotLeft - f, this.xAxis.len - x - b, y] : [x + b, f + a.pos - t.plotTop, y], P = _n + (_i8.total || _i8.y), \"percent\" === e.stacking && (P = _n + (_i8.y < 0) ? -100 : 100);\n              var X = a.toPixels(P, !0);\n              M = (S = t.plotHeight - X - (t.plotHeight - c)) ? b * (m - X) / S : 0, L = S ? b * (m + y - X) / S : 0, k = x - M + b, v = x + M + b, A = x + L + b, w = x - L + b, T = m - l, N = m + y, _i8.y < 0 && (T = m, N = m + y + l), t.inverted && (C = a.width - m, S = X - (a.width - c), M = b * (X - C) / S, L = b * (X - (C - y)) / S, v = (k = x + b + M) - 2 * M, A = x - L + b, w = x + L + b, T = m, N = m + y - l, _i8.y < 0 && (N = m + y + l)), _i8.shapeType = \"path\", _i8.shapeArgs = {\n                x: k,\n                y: T,\n                width: v - k,\n                height: y,\n                d: [[\"M\", k, T], [\"L\", v, T], [\"L\", A, N], [\"L\", w, N], [\"Z\"]]\n              };\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      }]);\n    }(s);\n    return n.defaultOptions = a(s.defaultOptions, t), e.registerSeriesType(\"columnpyramid\", n), n;\n  }), i(e, \"Series/ErrorBar/ErrorBarSeriesDefaults.js\", [], function () {\n    return {\n      color: \"#000000\",\n      grouping: !1,\n      linkedTo: \":previous\",\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      whiskerWidth: null\n    };\n  }), i(e, \"Series/ErrorBar/ErrorBarSeries.js\", [e[\"Series/BoxPlot/BoxPlotSeries.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Series/ErrorBar/ErrorBarSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    var a = s.seriesTypes.arearange,\n      r = o.addEvent,\n      n = o.merge,\n      l = o.extend;\n    var h = /*#__PURE__*/function (_t8) {\n      function h() {\n        _classCallCheck(this, h);\n        return _callSuper(this, h, arguments);\n      }\n      _inherits(h, _t8);\n      return _createClass(h, [{\n        key: \"getColumnMetrics\",\n        value: function getColumnMetrics() {\n          return this.linkedParent && this.linkedParent.columnMetrics || e.prototype.getColumnMetrics.call(this);\n        }\n      }, {\n        key: \"drawDataLabels\",\n        value: function drawDataLabels() {\n          var t = this.pointValKey;\n          if (a) {\n            var _iterator4 = _createForOfIteratorHelper((a.prototype.drawDataLabels.call(this), this.points)),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var _e12 = _step4.value;\n                _e12.y = _e12[t];\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          }\n        }\n      }, {\n        key: \"toYData\",\n        value: function toYData(t) {\n          return [t.low, t.high];\n        }\n      }]);\n    }(t);\n    return h.defaultOptions = n(t.defaultOptions, i), r(h, \"afterTranslate\", function () {\n      var _iterator5 = _createForOfIteratorHelper(this.points),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _t9 = _step5.value;\n          _t9.plotLow = _t9.plotY;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }, {\n      order: 0\n    }), l(h.prototype, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"high\",\n      doQuartiles: !1\n    }), s.registerSeriesType(\"errorbar\", h), h;\n  }), i(e, \"Series/Gauge/GaugePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"]], function (t) {\n    var e = t.series.prototype.pointClass;\n    return /*#__PURE__*/function (_e13) {\n      function _class3() {\n        _classCallCheck(this, _class3);\n        return _callSuper(this, _class3, arguments);\n      }\n      _inherits(_class3, _e13);\n      return _createClass(_class3, [{\n        key: \"setState\",\n        value: function setState(t) {\n          this.state = t;\n        }\n      }]);\n    }(e);\n  }), i(e, \"Series/Gauge/GaugeSeries.js\", [e[\"Series/Gauge/GaugePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o = e.noop,\n      a = i.series,\n      r = i.seriesTypes.column,\n      n = s.clamp,\n      l = s.isNumber,\n      h = s.extend,\n      p = s.merge,\n      d = s.pick,\n      c = s.pInt,\n      u = s.defined;\n    var g = /*#__PURE__*/function (_a5) {\n      function g() {\n        _classCallCheck(this, g);\n        return _callSuper(this, g, arguments);\n      }\n      _inherits(g, _a5);\n      return _createClass(g, [{\n        key: \"translate\",\n        value: function translate() {\n          var t = this.yAxis,\n            e = this.options,\n            i = t.center;\n          this.generatePoints(), this.points.forEach(function (s) {\n            var o = p(e.dial, s.dial),\n              a = c(o.radius) * i[2] / 200,\n              r = c(o.baseLength) * a / 100,\n              h = c(o.rearLength) * a / 100,\n              d = o.baseWidth,\n              _g2 = o.topWidth,\n              f = e.overshoot,\n              b = t.startAngleRad + t.translate(s.y, void 0, void 0, void 0, !0);\n            (l(f) || !1 === e.wrap) && (f = l(f) ? f / 180 * Math.PI : 0, b = n(b, t.startAngleRad - f, t.endAngleRad + f)), b = 180 * b / Math.PI, s.shapeType = \"path\";\n            var m = o.path || [[\"M\", -h, -d / 2], [\"L\", r, -d / 2], [\"L\", a, -_g2 / 2], [\"L\", a, _g2 / 2], [\"L\", r, d / 2], [\"L\", -h, d / 2], [\"Z\"]];\n            s.shapeArgs = {\n              d: m,\n              translateX: i[0],\n              translateY: i[1],\n              rotation: b\n            }, s.plotX = i[0], s.plotY = i[1], u(s.y) && t.max - t.min && (s.percentage = (s.y - t.min) / (t.max - t.min) * 100);\n          });\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t = this,\n            e = t.chart,\n            i = t.yAxis.center,\n            s = t.pivot,\n            o = t.options,\n            a = o.pivot,\n            r = e.renderer;\n          t.points.forEach(function (i) {\n            var s = i.graphic,\n              a = i.shapeArgs,\n              n = a.d,\n              l = p(o.dial, i.dial);\n            s ? (s.animate(a), a.d = n) : i.graphic = r[i.shapeType](a).addClass(\"highcharts-dial\").add(t.group), e.styledMode || i.graphic[s ? \"animate\" : \"attr\"]({\n              stroke: l.borderColor,\n              \"stroke-width\": l.borderWidth,\n              fill: l.backgroundColor\n            });\n          }), s ? s.animate({\n            translateX: i[0],\n            translateY: i[1]\n          }) : a && (t.pivot = r.circle(0, 0, a.radius).attr({\n            zIndex: 2\n          }).addClass(\"highcharts-pivot\").translate(i[0], i[1]).add(t.group), e.styledMode || t.pivot.attr({\n            fill: a.backgroundColor,\n            stroke: a.borderColor,\n            \"stroke-width\": a.borderWidth\n          }));\n        }\n      }, {\n        key: \"animate\",\n        value: function animate(t) {\n          var e = this;\n          t || e.points.forEach(function (t) {\n            var i = t.graphic;\n            i && (i.attr({\n              rotation: 180 * e.yAxis.startAngleRad / Math.PI\n            }), i.animate({\n              rotation: t.shapeArgs.rotation\n            }, e.options.animation));\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          this.group = this.plotGroup(\"group\", \"series\", this.visible ? \"inherit\" : \"hidden\", this.options.zIndex, this.chart.seriesGroup), a.prototype.render.call(this), this.group.clip(this.chart.clipRect);\n        }\n      }, {\n        key: \"setData\",\n        value: function setData(t, e) {\n          a.prototype.setData.call(this, t, !1), this.processData(), this.generatePoints(), d(e, !0) && this.chart.redraw();\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return !!this.points.length;\n        }\n      }]);\n    }(a);\n    return g.defaultOptions = p(a.defaultOptions, {\n      dataLabels: {\n        borderColor: \"#cccccc\",\n        borderRadius: 3,\n        borderWidth: 1,\n        crop: !1,\n        defer: !1,\n        enabled: !0,\n        verticalAlign: \"top\",\n        y: 15,\n        zIndex: 2\n      },\n      dial: {\n        backgroundColor: \"#000000\",\n        baseLength: \"70%\",\n        baseWidth: 3,\n        borderColor: \"#cccccc\",\n        borderWidth: 0,\n        radius: \"80%\",\n        rearLength: \"10%\",\n        topWidth: 1\n      },\n      pivot: {\n        radius: 5,\n        borderWidth: 0,\n        borderColor: \"#cccccc\",\n        backgroundColor: \"#000000\"\n      },\n      tooltip: {\n        headerFormat: \"\"\n      },\n      showInLegend: !1\n    }), h(g.prototype, {\n      angular: !0,\n      directTouch: !0,\n      drawGraph: o,\n      drawTracker: r.prototype.drawTracker,\n      fixedBox: !0,\n      forceDL: !0,\n      noSharedTooltip: !0,\n      pointClass: t,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    }), i.registerSeriesType(\"gauge\", g), g;\n  }), i(e, \"Series/DragNodesComposition.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.composed,\n      s = e.addEvent,\n      o = e.pushUnique;\n    function a() {\n      var t, e, i;\n      var o = this;\n      o.container && (t = s(o.container, \"mousedown\", function (t) {\n        var a = o.hoverPoint;\n        a && a.series && a.series.hasDraggableNodes && a.series.options.draggable && (a.series.onMouseDown(a, t), e = s(o.container, \"mousemove\", function (t) {\n          return a && a.series && a.series.onMouseMove(a, t);\n        }), i = s(o.container.ownerDocument, \"mouseup\", function (t) {\n          return e(), i(), a && a.series && a.series.onMouseUp(a, t);\n        }));\n      })), s(o, \"destroy\", function () {\n        t();\n      });\n    }\n    return {\n      compose: function compose(t) {\n        o(i, \"DragNodes\") && s(t, \"load\", a);\n      },\n      onMouseDown: function onMouseDown(t, e) {\n        var _this$chart$pointer;\n        var i = ((_this$chart$pointer = this.chart.pointer) === null || _this$chart$pointer === void 0 ? void 0 : _this$chart$pointer.normalize(e)) || e;\n        t.fixedPosition = {\n          chartX: i.chartX,\n          chartY: i.chartY,\n          plotX: t.plotX,\n          plotY: t.plotY\n        }, t.inDragMode = !0;\n      },\n      onMouseMove: function onMouseMove(t, e) {\n        if (t.fixedPosition && t.inDragMode) {\n          var _o5$pointer;\n          var _i9, _s11;\n          var _o5 = this.chart,\n            _a6 = ((_o5$pointer = _o5.pointer) === null || _o5$pointer === void 0 ? void 0 : _o5$pointer.normalize(e)) || e,\n            r = t.fixedPosition.chartX - _a6.chartX,\n            n = t.fixedPosition.chartY - _a6.chartY,\n            l = _o5.graphLayoutsLookup;\n          (Math.abs(r) > 5 || Math.abs(n) > 5) && (_i9 = t.fixedPosition.plotX - r, _s11 = t.fixedPosition.plotY - n, _o5.isInsidePlot(_i9, _s11) && (t.plotX = _i9, t.plotY = _s11, t.hasDragged = !0, this.redrawHalo(t), l.forEach(function (t) {\n            t.restartSimulation();\n          })));\n        }\n      },\n      onMouseUp: function onMouseUp(t) {\n        t.fixedPosition && (t.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), t.inDragMode = t.hasDragged = !1, this.options.fixedDraggable || delete t.fixedPosition);\n      },\n      redrawHalo: function redrawHalo(t) {\n        t && this.halo && this.halo.attr({\n          d: t.haloPath(this.options.states.hover.halo.size)\n        });\n      }\n    };\n  }), i(e, \"Series/GraphLayoutComposition.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.setAnimation,\n      o = e.composed,\n      a = i.addEvent,\n      r = i.pushUnique;\n    function n() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (t) {\n        t.updateSimulation();\n      }), this.redraw());\n    }\n    function l() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (t) {\n        t.updateSimulation(!1);\n      }), this.redraw());\n    }\n    function h() {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (t) {\n        t.stop();\n      });\n    }\n    function p() {\n      var t,\n        e = !1,\n        i = function i(_i10) {\n          _i10.maxIterations-- && isFinite(_i10.temperature) && !_i10.isStable() && !_i10.enableSimulation && (_i10.beforeStep && _i10.beforeStep(), _i10.step(), t = !1, e = !0);\n        };\n      if (this.graphLayoutsLookup) {\n        for (s(!1, this), this.graphLayoutsLookup.forEach(function (t) {\n          return t.start();\n        }); !t;) t = !0, this.graphLayoutsLookup.forEach(i);\n        e && this.series.forEach(function (t) {\n          t && t.layout && t.render();\n        });\n      }\n    }\n    return {\n      compose: function compose(t) {\n        r(o, \"GraphLayout\") && (a(t, \"afterPrint\", n), a(t, \"beforePrint\", l), a(t, \"predraw\", h), a(t, \"render\", p));\n      },\n      integrations: {},\n      layouts: {}\n    };\n  }), i(e, \"Series/PackedBubble/PackedBubblePoint.js\", [e[\"Core/Chart/Chart.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesRegistry.js\"]], function (t, e, i) {\n    var s = i.seriesTypes.bubble.prototype.pointClass;\n    return /*#__PURE__*/function (_s12) {\n      function _class4() {\n        _classCallCheck(this, _class4);\n        return _callSuper(this, _class4, arguments);\n      }\n      _inherits(_class4, _s12);\n      return _createClass(_class4, [{\n        key: \"destroy\",\n        value: function destroy() {\n          var _this$series2;\n          return (_this$series2 = this.series) !== null && _this$series2 !== void 0 && _this$series2.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes), e.prototype.destroy.apply(this, arguments);\n        }\n      }, {\n        key: \"firePointEvent\",\n        value: function firePointEvent() {\n          var t = this.series.options;\n          if (this.isParentNode && t.parentNode) {\n            var _i11 = t.allowPointSelect;\n            t.allowPointSelect = t.parentNode.allowPointSelect, e.prototype.firePointEvent.apply(this, arguments), t.allowPointSelect = _i11;\n          } else e.prototype.firePointEvent.apply(this, arguments);\n        }\n      }, {\n        key: \"select\",\n        value: function select() {\n          var i = this.series.chart;\n          this.isParentNode ? (i.getSelectedPoints = i.getSelectedParentNodes, e.prototype.select.apply(this, arguments), i.getSelectedPoints = t.prototype.getSelectedPoints) : e.prototype.select.apply(this, arguments);\n        }\n      }]);\n    }(s);\n  }), i(e, \"Series/PackedBubble/PackedBubbleSeriesDefaults.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.isNumber;\n    return {\n      minSize: \"10%\",\n      maxSize: \"50%\",\n      sizeBy: \"area\",\n      zoneAxis: \"y\",\n      crisp: !1,\n      tooltip: {\n        pointFormat: \"Value: {point.value}\"\n      },\n      draggable: !0,\n      useSimulation: !0,\n      parentNode: {\n        allowPointSelect: !1\n      },\n      dataLabels: {\n        formatter: function formatter() {\n          var t = this.series.chart.numberFormatter,\n            i = this.point.value;\n          return e(i) ? t(i, -1) : \"\";\n        },\n        parentNodeFormatter: function parentNodeFormatter() {\n          return this.name;\n        },\n        parentNodeTextPath: {\n          enabled: !0\n        },\n        padding: 0,\n        style: {\n          transition: \"opacity 2000ms\"\n        }\n      },\n      layoutAlgorithm: {\n        initialPositions: \"circle\",\n        initialPositionRadius: 20,\n        bubblePadding: 5,\n        parentNodeLimit: !1,\n        seriesInteraction: !0,\n        dragBetweenSeries: !1,\n        parentNodeOptions: {\n          maxIterations: 400,\n          gravitationalConstant: .03,\n          maxSpeed: 50,\n          initialPositionRadius: 100,\n          seriesInteraction: !0,\n          marker: {\n            fillColor: null,\n            fillOpacity: 1,\n            lineWidth: null,\n            lineColor: null,\n            symbol: \"circle\"\n          }\n        },\n        enableSimulation: !0,\n        type: \"packedbubble\",\n        integration: \"packedbubble\",\n        maxIterations: 1e3,\n        splitSeries: !1,\n        maxSpeed: 5,\n        gravitationalConstant: .01,\n        friction: -.981\n      }\n    };\n  }), i(e, \"Series/Networkgraph/VerletIntegration.js\", [], function () {\n    return {\n      attractive: function attractive(t, e, i) {\n        var s = t.getMass(),\n          o = -i.x * e * this.diffTemperature,\n          a = -i.y * e * this.diffTemperature;\n        t.fromNode.fixedPosition || (t.fromNode.plotX -= o * s.fromNode / t.fromNode.degree, t.fromNode.plotY -= a * s.fromNode / t.fromNode.degree), t.toNode.fixedPosition || (t.toNode.plotX += o * s.toNode / t.toNode.degree, t.toNode.plotY += a * s.toNode / t.toNode.degree);\n      },\n      attractiveForceFunction: function attractiveForceFunction(t, e) {\n        return (e - t) / t;\n      },\n      barycenter: function barycenter() {\n        var t = this.options.gravitationalConstant || 0,\n          e = (this.barycenter.xFactor - (this.box.left + this.box.width) / 2) * t,\n          i = (this.barycenter.yFactor - (this.box.top + this.box.height) / 2) * t;\n        this.nodes.forEach(function (t) {\n          t.fixedPosition || (t.plotX -= e / t.mass / t.degree, t.plotY -= i / t.mass / t.degree);\n        });\n      },\n      getK: function getK(t) {\n        return Math.pow(t.box.width * t.box.height / t.nodes.length, .5);\n      },\n      integrate: function integrate(t, e) {\n        var i = -t.options.friction,\n          s = t.options.maxSpeed,\n          o = e.prevX,\n          a = e.prevY,\n          r = (e.plotX + e.dispX - o) * i,\n          n = (e.plotY + e.dispY - a) * i,\n          l = Math.abs,\n          h = l(r) / (r || 1),\n          p = l(n) / (n || 1),\n          d = h * Math.min(s, Math.abs(r)),\n          c = p * Math.min(s, Math.abs(n));\n        e.prevX = e.plotX + e.dispX, e.prevY = e.plotY + e.dispY, e.plotX += d, e.plotY += c, e.temperature = t.vectorLength({\n          x: d,\n          y: c\n        });\n      },\n      repulsive: function repulsive(t, e, i) {\n        var s = e * this.diffTemperature / t.mass / t.degree;\n        t.fixedPosition || (t.plotX += i.x * s, t.plotY += i.y * s);\n      },\n      repulsiveForceFunction: function repulsiveForceFunction(t, e) {\n        return (e - t) / t * (e > t ? 1 : 0);\n      }\n    };\n  }), i(e, \"Series/PackedBubble/PackedBubbleIntegration.js\", [e[\"Core/Globals.js\"], e[\"Series/Networkgraph/VerletIntegration.js\"]], function (t, e) {\n    var i = t.noop;\n    return {\n      barycenter: function barycenter() {\n        var t, e;\n        var i = this.options.gravitationalConstant,\n          s = this.box,\n          o = this.nodes;\n        var _iterator6 = _createForOfIteratorHelper(o),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var a = _step6.value;\n            this.options.splitSeries && !a.isParentNode ? (t = a.series.parentNode.plotX, e = a.series.parentNode.plotY) : (t = s.width / 2, e = s.height / 2), a.fixedPosition || (a.plotX -= (a.plotX - t) * i / (a.mass * Math.sqrt(o.length)), a.plotY -= (a.plotY - e) * i / (a.mass * Math.sqrt(o.length)));\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      },\n      getK: i,\n      integrate: e.integrate,\n      repulsive: function repulsive(t, e, i, s) {\n        var o = e * this.diffTemperature / t.mass / t.degree,\n          a = i.x * o,\n          r = i.y * o;\n        t.fixedPosition || (t.plotX += a, t.plotY += r), s.fixedPosition || (s.plotX -= a, s.plotY -= r);\n      },\n      repulsiveForceFunction: function repulsiveForceFunction(t, e, i, s) {\n        return Math.min(t, (i.marker.radius + s.marker.radius) / 2);\n      }\n    };\n  }), i(e, \"Series/Networkgraph/EulerIntegration.js\", [], function () {\n    return {\n      attractive: function attractive(t, e, i, s) {\n        var o = t.getMass(),\n          a = i.x / s * e,\n          r = i.y / s * e;\n        t.fromNode.fixedPosition || (t.fromNode.dispX -= a * o.fromNode / t.fromNode.degree, t.fromNode.dispY -= r * o.fromNode / t.fromNode.degree), t.toNode.fixedPosition || (t.toNode.dispX += a * o.toNode / t.toNode.degree, t.toNode.dispY += r * o.toNode / t.toNode.degree);\n      },\n      attractiveForceFunction: function attractiveForceFunction(t, e) {\n        return t * t / e;\n      },\n      barycenter: function barycenter() {\n        var t = this.options.gravitationalConstant,\n          e = this.barycenter.xFactor,\n          i = this.barycenter.yFactor;\n        this.nodes.forEach(function (s) {\n          if (!s.fixedPosition) {\n            var o = s.getDegree(),\n              a = o * (1 + o / 2);\n            s.dispX += (e - s.plotX) * t * a / s.degree, s.dispY += (i - s.plotY) * t * a / s.degree;\n          }\n        });\n      },\n      getK: function getK(t) {\n        return Math.pow(t.box.width * t.box.height / t.nodes.length, .3);\n      },\n      integrate: function integrate(t, e) {\n        e.dispX += e.dispX * t.options.friction, e.dispY += e.dispY * t.options.friction;\n        var i = e.temperature = t.vectorLength({\n          x: e.dispX,\n          y: e.dispY\n        });\n        0 !== i && (e.plotX += e.dispX / i * Math.min(Math.abs(e.dispX), t.temperature), e.plotY += e.dispY / i * Math.min(Math.abs(e.dispY), t.temperature));\n      },\n      repulsive: function repulsive(t, e, i, s) {\n        t.dispX += i.x / s * e / t.degree, t.dispY += i.y / s * e / t.degree;\n      },\n      repulsiveForceFunction: function repulsiveForceFunction(t, e) {\n        return e * e / t;\n      }\n    };\n  }), i(e, \"Series/Networkgraph/QuadTreeNode.js\", [], function () {\n    var t = /*#__PURE__*/function () {\n      function t(_t10) {\n        _classCallCheck(this, t);\n        this.body = !1, this.isEmpty = !1, this.isInternal = !1, this.nodes = [], this.box = _t10, this.boxSize = Math.min(_t10.width, _t10.height);\n      }\n      return _createClass(t, [{\n        key: \"divideBox\",\n        value: function divideBox() {\n          var e = this.box.width / 2,\n            i = this.box.height / 2;\n          this.nodes[0] = new t({\n            left: this.box.left,\n            top: this.box.top,\n            width: e,\n            height: i\n          }), this.nodes[1] = new t({\n            left: this.box.left + e,\n            top: this.box.top,\n            width: e,\n            height: i\n          }), this.nodes[2] = new t({\n            left: this.box.left + e,\n            top: this.box.top + i,\n            width: e,\n            height: i\n          }), this.nodes[3] = new t({\n            left: this.box.left,\n            top: this.box.top + i,\n            width: e,\n            height: i\n          });\n        }\n      }, {\n        key: \"getBoxPosition\",\n        value: function getBoxPosition(_t11) {\n          var e = _t11.plotX < this.box.left + this.box.width / 2,\n            i = _t11.plotY < this.box.top + this.box.height / 2;\n          return e ? i ? 0 : 3 : i ? 1 : 2;\n        }\n      }, {\n        key: \"insert\",\n        value: function insert(e, i) {\n          var s;\n          this.isInternal ? this.nodes[this.getBoxPosition(e)].insert(e, i - 1) : (this.isEmpty = !1, this.body ? i ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, i - 1), this.body = !0), this.nodes[this.getBoxPosition(e)].insert(e, i - 1)) : ((s = new t({\n            top: e.plotX || NaN,\n            left: e.plotY || NaN,\n            width: .1,\n            height: .1\n          })).body = e, s.isInternal = !1, this.nodes.push(s)) : (this.isInternal = !1, this.body = e));\n        }\n      }, {\n        key: \"updateMassAndCenter\",\n        value: function updateMassAndCenter() {\n          var _t12 = 0,\n            e = 0,\n            i = 0;\n          if (this.isInternal) {\n            var _iterator7 = _createForOfIteratorHelper(this.nodes),\n              _step7;\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var s = _step7.value;\n                s.isEmpty || (_t12 += s.mass, e += s.plotX * s.mass, i += s.plotY * s.mass);\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n            e /= _t12, i /= _t12;\n          } else this.body && (_t12 = this.body.mass, e = this.body.plotX, i = this.body.plotY);\n          this.mass = _t12, this.plotX = e, this.plotY = i;\n        }\n      }]);\n    }();\n    return t;\n  }), i(e, \"Series/Networkgraph/QuadTree.js\", [e[\"Series/Networkgraph/QuadTreeNode.js\"]], function (t) {\n    return /*#__PURE__*/function () {\n      function _class5(e, i, s, o) {\n        _classCallCheck(this, _class5);\n        this.box = {\n          left: e,\n          top: i,\n          width: s,\n          height: o\n        }, this.maxDepth = 25, this.root = new t(this.box), this.root.isInternal = !0, this.root.isRoot = !0, this.root.divideBox();\n      }\n      return _createClass(_class5, [{\n        key: \"calculateMassAndCenter\",\n        value: function calculateMassAndCenter() {\n          this.visitNodeRecursive(null, null, function (t) {\n            t.updateMassAndCenter();\n          });\n        }\n      }, {\n        key: \"insertNodes\",\n        value: function insertNodes(t) {\n          var _iterator8 = _createForOfIteratorHelper(t),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _e14 = _step8.value;\n              this.root.insert(_e14, this.maxDepth);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n      }, {\n        key: \"visitNodeRecursive\",\n        value: function visitNodeRecursive(t, e, i) {\n          var s;\n          if (t || (t = this.root), t === this.root && e && (s = e(t)), !1 !== s) {\n            var _iterator9 = _createForOfIteratorHelper(t.nodes),\n              _step9;\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var o = _step9.value;\n                if (o.isInternal) {\n                  if (e && (s = e(o)), !1 === s) continue;\n                  this.visitNodeRecursive(o, e, i);\n                } else o.body && e && e(o.body);\n                i && i(o);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n            t === this.root && i && i(t);\n          }\n        }\n      }]);\n    }();\n  }), i(e, \"Series/Networkgraph/ReingoldFruchtermanLayout.js\", [e[\"Series/Networkgraph/EulerIntegration.js\"], e[\"Core/Globals.js\"], e[\"Series/GraphLayoutComposition.js\"], e[\"Series/Networkgraph/QuadTree.js\"], e[\"Core/Utilities.js\"], e[\"Series/Networkgraph/VerletIntegration.js\"]], function (t, e, i, s, o, a) {\n    var r = e.win,\n      n = o.clamp,\n      l = o.defined,\n      h = o.isFunction,\n      p = o.fireEvent,\n      d = o.pick;\n    var c = /*#__PURE__*/function () {\n      function c() {\n        _classCallCheck(this, c);\n        this.box = {}, this.currentStep = 0, this.initialRendering = !0, this.links = [], this.nodes = [], this.series = [], this.simulation = !1;\n      }\n      return _createClass(c, [{\n        key: \"init\",\n        value: function init(t) {\n          this.options = t, this.nodes = [], this.links = [], this.series = [], this.box = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          }, this.setInitialRendering(!0), this.integration = i.integrations[t.integration], this.enableSimulation = t.enableSimulation, this.attractiveForce = d(t.attractiveForce, this.integration.attractiveForceFunction), this.repulsiveForce = d(t.repulsiveForce, this.integration.repulsiveForceFunction), this.approximation = t.approximation;\n        }\n      }, {\n        key: \"updateSimulation\",\n        value: function updateSimulation(t) {\n          this.enableSimulation = d(t, this.options.enableSimulation);\n        }\n      }, {\n        key: \"start\",\n        value: function start() {\n          var t = this.series,\n            e = this.options;\n          this.currentStep = 0, this.forces = t[0] && t[0].forces || [], this.chart = t[0] && t[0].chart, this.initialRendering && (this.initPositions(), t.forEach(function (t) {\n            t.finishedAnimating = !0, t.render();\n          })), this.setK(), this.resetSimulation(e), this.enableSimulation && this.step();\n        }\n      }, {\n        key: \"step\",\n        value: function step() {\n          var _this5 = this;\n          var t = this.series;\n          var _iterator10 = _createForOfIteratorHelper((this.currentStep++, \"barnes-hut\" === this.approximation && (this.createQuadTree(), this.quadTree.calculateMassAndCenter()), this.forces || [])),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _t13 = _step10.value;\n              this[_t13 + \"Forces\"](this.temperature);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n          if (this.applyLimits(), this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep), this.prevSystemTemperature = this.systemTemperature, this.systemTemperature = this.getSystemTemperature(), this.enableSimulation) {\n            var _iterator11 = _createForOfIteratorHelper(t),\n              _step11;\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var _e15 = _step11.value;\n                _e15.chart && _e15.render();\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n            this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && r.cancelAnimationFrame(this.simulation), this.simulation = r.requestAnimationFrame(function () {\n              return _this5.step();\n            })) : (this.simulation = !1, this.series.forEach(function (t) {\n              p(t, \"afterSimulation\");\n            }));\n          }\n        }\n      }, {\n        key: \"stop\",\n        value: function stop() {\n          this.simulation && r.cancelAnimationFrame(this.simulation);\n        }\n      }, {\n        key: \"setArea\",\n        value: function setArea(t, e, i, s) {\n          this.box = {\n            left: t,\n            top: e,\n            width: i,\n            height: s\n          };\n        }\n      }, {\n        key: \"setK\",\n        value: function setK() {\n          this.k = this.options.linkLength || this.integration.getK(this);\n        }\n      }, {\n        key: \"addElementsToCollection\",\n        value: function addElementsToCollection(t, e) {\n          var _iterator12 = _createForOfIteratorHelper(t),\n            _step12;\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var _i12 = _step12.value;\n              -1 === e.indexOf(_i12) && e.push(_i12);\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n        }\n      }, {\n        key: \"removeElementFromCollection\",\n        value: function removeElementFromCollection(t, e) {\n          var i = e.indexOf(t);\n          -1 !== i && e.splice(i, 1);\n        }\n      }, {\n        key: \"clear\",\n        value: function clear() {\n          this.nodes.length = 0, this.links.length = 0, this.series.length = 0, this.resetSimulation();\n        }\n      }, {\n        key: \"resetSimulation\",\n        value: function resetSimulation() {\n          this.forcedStop = !1, this.systemTemperature = 0, this.setMaxIterations(), this.setTemperature(), this.setDiffTemperature();\n        }\n      }, {\n        key: \"restartSimulation\",\n        value: function restartSimulation() {\n          this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));\n        }\n      }, {\n        key: \"setMaxIterations\",\n        value: function setMaxIterations(t) {\n          this.maxIterations = d(t, this.options.maxIterations);\n        }\n      }, {\n        key: \"setTemperature\",\n        value: function setTemperature() {\n          this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);\n        }\n      }, {\n        key: \"setDiffTemperature\",\n        value: function setDiffTemperature() {\n          this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);\n        }\n      }, {\n        key: \"setInitialRendering\",\n        value: function setInitialRendering(t) {\n          this.initialRendering = t;\n        }\n      }, {\n        key: \"createQuadTree\",\n        value: function createQuadTree() {\n          this.quadTree = new s(this.box.left, this.box.top, this.box.width, this.box.height), this.quadTree.insertNodes(this.nodes);\n        }\n      }, {\n        key: \"initPositions\",\n        value: function initPositions() {\n          var t = this.options.initialPositions;\n          if (h(t)) {\n            var _iterator13 = _createForOfIteratorHelper((t.call(this), this.nodes)),\n              _step13;\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var _e16 = _step13.value;\n                l(_e16.prevX) || (_e16.prevX = _e16.plotX), l(_e16.prevY) || (_e16.prevY = _e16.plotY), _e16.dispX = 0, _e16.dispY = 0;\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n          } else \"circle\" === t ? this.setCircularPositions() : this.setRandomPositions();\n        }\n      }, {\n        key: \"setCircularPositions\",\n        value: function setCircularPositions() {\n          var t;\n          var e = this.box,\n            i = this.nodes,\n            s = 2 * Math.PI / (i.length + 1),\n            o = i.filter(function (t) {\n              return 0 === t.linksTo.length;\n            }),\n            a = {},\n            r = this.options.initialPositionRadius,\n            _n2 = function n(t) {\n              var _iterator14 = _createForOfIteratorHelper(t.linksFrom || []),\n                _step14;\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var _e17 = _step14.value;\n                  a[_e17.toNode.id] || (a[_e17.toNode.id] = !0, l.push(_e17.toNode), _n2(_e17.toNode));\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n            },\n            l = [];\n          var _iterator15 = _createForOfIteratorHelper(o),\n            _step15;\n          try {\n            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n              var _t15 = _step15.value;\n              l.push(_t15), _n2(_t15);\n            }\n          } catch (err) {\n            _iterator15.e(err);\n          } finally {\n            _iterator15.f();\n          }\n          if (l.length) {\n            var _iterator16 = _createForOfIteratorHelper(i),\n              _step16;\n            try {\n              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                var _t14 = _step16.value;\n                -1 === l.indexOf(_t14) && l.push(_t14);\n              }\n            } catch (err) {\n              _iterator16.e(err);\n            } finally {\n              _iterator16.f();\n            }\n          } else l = i;\n          for (var _i13 = 0, _o6 = l.length; _i13 < _o6; ++_i13) (t = l[_i13]).plotX = t.prevX = d(t.plotX, e.width / 2 + r * Math.cos(_i13 * s)), t.plotY = t.prevY = d(t.plotY, e.height / 2 + r * Math.sin(_i13 * s)), t.dispX = 0, t.dispY = 0;\n        }\n      }, {\n        key: \"setRandomPositions\",\n        value: function setRandomPositions() {\n          var t;\n          var e = this.box,\n            i = this.nodes,\n            s = i.length + 1,\n            o = function o(t) {\n              var e = t * t / Math.PI;\n              return e - Math.floor(e);\n            };\n          for (var _a7 = 0, _r2 = i.length; _a7 < _r2; ++_a7) (t = i[_a7]).plotX = t.prevX = d(t.plotX, e.width * o(_a7)), t.plotY = t.prevY = d(t.plotY, e.height * o(s + _a7)), t.dispX = 0, t.dispY = 0;\n        }\n      }, {\n        key: \"force\",\n        value: function force(t) {\n          for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            e[_key - 1] = arguments[_key];\n          }\n          this.integration[t].apply(this, e);\n        }\n      }, {\n        key: \"barycenterForces\",\n        value: function barycenterForces() {\n          this.getBarycenter(), this.force(\"barycenter\");\n        }\n      }, {\n        key: \"getBarycenter\",\n        value: function getBarycenter() {\n          var t = 0,\n            e = 0,\n            i = 0;\n          var _iterator17 = _createForOfIteratorHelper(this.nodes),\n            _step17;\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _s13 = _step17.value;\n              e += _s13.plotX * _s13.mass, i += _s13.plotY * _s13.mass, t += _s13.mass;\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n          return this.barycenter = {\n            x: e,\n            y: i,\n            xFactor: e / t,\n            yFactor: i / t\n          }, this.barycenter;\n        }\n      }, {\n        key: \"barnesHutApproximation\",\n        value: function barnesHutApproximation(t, e) {\n          var i, s;\n          var o = this.getDistXY(t, e),\n            a = this.vectorLength(o);\n          return t !== e && 0 !== a && (e.isInternal ? e.boxSize / a < this.options.theta && 0 !== a ? (s = this.repulsiveForce(a, this.k), this.force(\"repulsive\", t, s * e.mass, o, a), i = !1) : i = !0 : (s = this.repulsiveForce(a, this.k), this.force(\"repulsive\", t, s * e.mass, o, a))), i;\n        }\n      }, {\n        key: \"repulsiveForces\",\n        value: function repulsiveForces() {\n          var _this6 = this;\n          if (\"barnes-hut\" === this.approximation) {\n            var _iterator18 = _createForOfIteratorHelper(this.nodes),\n              _step18;\n            try {\n              var _loop = function _loop() {\n                var t = _step18.value;\n                _this6.quadTree.visitNodeRecursive(null, function (e) {\n                  return _this6.barnesHutApproximation(t, e);\n                });\n              };\n              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator18.e(err);\n            } finally {\n              _iterator18.f();\n            }\n          } else {\n            var _t16, _e18, _i14;\n            var _iterator19 = _createForOfIteratorHelper(this.nodes),\n              _step19;\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _s14 = _step19.value;\n                var _iterator20 = _createForOfIteratorHelper(this.nodes),\n                  _step20;\n                try {\n                  for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                    var _o7 = _step20.value;\n                    _s14 === _o7 || _s14.fixedPosition || (_i14 = this.getDistXY(_s14, _o7), 0 !== (_e18 = this.vectorLength(_i14)) && (_t16 = this.repulsiveForce(_e18, this.k), this.force(\"repulsive\", _s14, _t16 * _o7.mass, _i14, _e18)));\n                  }\n                } catch (err) {\n                  _iterator20.e(err);\n                } finally {\n                  _iterator20.f();\n                }\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n          }\n        }\n      }, {\n        key: \"attractiveForces\",\n        value: function attractiveForces() {\n          var t, e, i;\n          var _iterator21 = _createForOfIteratorHelper(this.links),\n            _step21;\n          try {\n            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n              var _s15 = _step21.value;\n              _s15.fromNode && _s15.toNode && (t = this.getDistXY(_s15.fromNode, _s15.toNode), 0 !== (e = this.vectorLength(t)) && (i = this.attractiveForce(e, this.k), this.force(\"attractive\", _s15, i, t, e)));\n            }\n          } catch (err) {\n            _iterator21.e(err);\n          } finally {\n            _iterator21.f();\n          }\n        }\n      }, {\n        key: \"applyLimits\",\n        value: function applyLimits() {\n          var _iterator22 = _createForOfIteratorHelper(this.nodes),\n            _step22;\n          try {\n            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n              var _t17 = _step22.value;\n              _t17.fixedPosition || (this.integration.integrate(this, _t17), this.applyLimitBox(_t17, this.box), _t17.dispX = 0, _t17.dispY = 0);\n            }\n          } catch (err) {\n            _iterator22.e(err);\n          } finally {\n            _iterator22.f();\n          }\n        }\n      }, {\n        key: \"applyLimitBox\",\n        value: function applyLimitBox(t, e) {\n          var i = t.radius;\n          t.plotX = n(t.plotX, e.left + i, e.width - i), t.plotY = n(t.plotY, e.top + i, e.height - i);\n        }\n      }, {\n        key: \"coolDown\",\n        value: function coolDown(t, e, i) {\n          return t - e * i;\n        }\n      }, {\n        key: \"isStable\",\n        value: function isStable() {\n          return 1e-5 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || this.temperature <= 0;\n        }\n      }, {\n        key: \"getSystemTemperature\",\n        value: function getSystemTemperature() {\n          var t = 0;\n          var _iterator23 = _createForOfIteratorHelper(this.nodes),\n            _step23;\n          try {\n            for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n              var _e19 = _step23.value;\n              t += _e19.temperature;\n            }\n          } catch (err) {\n            _iterator23.e(err);\n          } finally {\n            _iterator23.f();\n          }\n          return t;\n        }\n      }, {\n        key: \"vectorLength\",\n        value: function vectorLength(t) {\n          return Math.sqrt(t.x * t.x + t.y * t.y);\n        }\n      }, {\n        key: \"getDistR\",\n        value: function getDistR(t, e) {\n          var i = this.getDistXY(t, e);\n          return this.vectorLength(i);\n        }\n      }, {\n        key: \"getDistXY\",\n        value: function getDistXY(t, e) {\n          var i = t.plotX - e.plotX,\n            s = t.plotY - e.plotY;\n          return {\n            x: i,\n            y: s,\n            absX: Math.abs(i),\n            absY: Math.abs(s)\n          };\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(e) {\n          i.compose(e), i.integrations.euler = t, i.integrations.verlet = a, i.layouts[\"reingold-fruchterman\"] = c;\n        }\n      }]);\n    }();\n    return c;\n  }), i(e, \"Series/PackedBubble/PackedBubbleLayout.js\", [e[\"Series/GraphLayoutComposition.js\"], e[\"Series/PackedBubble/PackedBubbleIntegration.js\"], e[\"Series/Networkgraph/ReingoldFruchtermanLayout.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o = s.addEvent,\n      a = s.pick;\n    function r() {\n      var t = this.series,\n        e = [];\n      return t.forEach(function (t) {\n        t.parentNode && t.parentNode.selected && e.push(t.parentNode);\n      }), e;\n    }\n    function n() {\n      this.allDataPoints && delete this.allDataPoints;\n    }\n    var l = /*#__PURE__*/function (_i15) {\n      function l() {\n        var _this7;\n        _classCallCheck(this, l);\n        _this7 = _callSuper(this, l, arguments), _this7.index = NaN, _this7.nodes = [], _this7.series = [];\n        return _this7;\n      }\n      _inherits(l, _i15);\n      return _createClass(l, [{\n        key: \"beforeStep\",\n        value: function beforeStep() {\n          this.options.marker && this.series.forEach(function (t) {\n            t && t.calculateParentRadius();\n          });\n        }\n      }, {\n        key: \"isStable\",\n        value: function isStable() {\n          var t = Math.abs(this.prevSystemTemperature - this.systemTemperature);\n          return 1 > Math.abs(10 * this.systemTemperature / Math.sqrt(this.nodes.length)) && t < 1e-5 || this.temperature <= 0;\n        }\n      }, {\n        key: \"setCircularPositions\",\n        value: function setCircularPositions() {\n          var t = this.box,\n            e = this.nodes,\n            i = 2 * Math.PI / (e.length + 1),\n            s = this.options.initialPositionRadius,\n            o,\n            r,\n            n = 0;\n          var _iterator24 = _createForOfIteratorHelper(e),\n            _step24;\n          try {\n            for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n              var _l = _step24.value;\n              this.options.splitSeries && !_l.isParentNode ? (o = _l.series.parentNode.plotX, r = _l.series.parentNode.plotY) : (o = t.width / 2, r = t.height / 2), _l.plotX = _l.prevX = a(_l.plotX, o + s * Math.cos(_l.index || n * i)), _l.plotY = _l.prevY = a(_l.plotY, r + s * Math.sin(_l.index || n * i)), _l.dispX = 0, _l.dispY = 0, n++;\n            }\n          } catch (err) {\n            _iterator24.e(err);\n          } finally {\n            _iterator24.f();\n          }\n        }\n      }, {\n        key: \"repulsiveForces\",\n        value: function repulsiveForces() {\n          var t, e, i;\n          var s = this,\n            o = s.options.bubblePadding,\n            a = s.nodes;\n          a.forEach(function (r) {\n            r.degree = r.mass, r.neighbours = 0, a.forEach(function (a) {\n              t = 0, r !== a && !r.fixedPosition && (s.options.seriesInteraction || r.series === a.series) && (i = s.getDistXY(r, a), (e = s.vectorLength(i) - (r.marker.radius + a.marker.radius + o)) < 0 && (r.degree += .01, r.neighbours++, t = s.repulsiveForce(-e / Math.sqrt(r.neighbours), s.k, r, a)), s.force(\"repulsive\", r, t * a.mass, i, a, e));\n            });\n          });\n        }\n      }, {\n        key: \"applyLimitBox\",\n        value: function applyLimitBox(t, e) {\n          var i, s;\n          this.options.splitSeries && !t.isParentNode && this.options.parentNodeLimit && (i = this.getDistXY(t, t.series.parentNode), (s = t.series.parentNodeRadius - t.marker.radius - this.vectorLength(i)) < 0 && s > -2 * t.marker.radius && (t.plotX -= .01 * i.x, t.plotY -= .01 * i.y)), _superPropGet(l, \"applyLimitBox\", this, 3)([t, e]);\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(s) {\n          i.compose(s), t.integrations.packedbubble = e, t.layouts.packedbubble = l;\n          var a = s.prototype;\n          a.getSelectedParentNodes || (o(s, \"beforeRedraw\", n), a.getSelectedParentNodes = r);\n        }\n      }]);\n    }(i);\n    return t.layouts.packedbubble = l, l;\n  }), i(e, \"Series/SimulationSeriesUtilities.js\", [e[\"Core/Utilities.js\"], e[\"Core/Animation/AnimationUtilities.js\"]], function (t, e) {\n    var i = t.merge,\n      s = t.syncTimeout,\n      o = e.animObject;\n    return {\n      initDataLabels: function initDataLabels() {\n        var t = this.options.dataLabels;\n        if (!this.dataLabelsGroup) {\n          var _e20 = this.initDataLabelsGroup();\n          return !this.chart.styledMode && t !== null && t !== void 0 && t.style && _e20.css(t.style), _e20.attr({\n            opacity: 0\n          }), this.visible && _e20.show(), _e20;\n        }\n        return this.dataLabelsGroup.attr(i({\n          opacity: 1\n        }, this.getPlotBox(\"data-labels\"))), this.dataLabelsGroup;\n      },\n      initDataLabelsDefer: function initDataLabelsDefer() {\n        var _this$options$layoutA,\n          _this8 = this;\n        var t = this.options.dataLabels;\n        t !== null && t !== void 0 && t.defer && (_this$options$layoutA = this.options.layoutAlgorithm) !== null && _this$options$layoutA !== void 0 && _this$options$layoutA.enableSimulation ? s(function () {\n          _this8.deferDataLabels = !1;\n        }, t ? o(t.animation).defer : 0) : this.deferDataLabels = !1;\n      }\n    };\n  }), i(e, \"Extensions/TextPath.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.deg2rad,\n      s = e.addEvent,\n      o = e.merge,\n      a = e.uniqueKey,\n      r = e.defined,\n      n = e.extend;\n    function l(t, e) {\n      var _this9 = this;\n      e = o(!0, {\n        enabled: !0,\n        attributes: {\n          dy: -5,\n          startOffset: \"50%\",\n          textAnchor: \"middle\"\n        }\n      }, e);\n      var i = this.renderer.url,\n        l = this.text || this,\n        h = l.textPath,\n        _e21 = e,\n        p = _e21.attributes,\n        d = _e21.enabled;\n      if (t = t || h && h.path, h && h.undo(), t && d) {\n        var _e22 = s(l, \"afterModifyTree\", function (e) {\n          if (t && d) {\n            var _s16 = t.attr(\"id\");\n            _s16 || t.attr(\"id\", _s16 = a());\n            var _o8 = {\n              x: 0,\n              y: 0\n            };\n            r(p.dx) && (_o8.dx = p.dx, delete p.dx), r(p.dy) && (_o8.dy = p.dy, delete p.dy), l.attr(_o8), _this9.attr({\n              transform: \"\"\n            }), _this9.box && (_this9.box = _this9.box.destroy());\n            var _h = e.nodes.slice(0);\n            e.nodes.length = 0, e.nodes[0] = {\n              tagName: \"textPath\",\n              attributes: n(p, {\n                \"text-anchor\": p.textAnchor,\n                href: \"\".concat(i, \"#\").concat(_s16)\n              }),\n              children: _h\n            };\n          }\n        });\n        l.textPath = {\n          path: t,\n          undo: _e22\n        };\n      } else l.attr({\n        dx: 0,\n        dy: 0\n      }), delete l.textPath;\n      return this.added && (l.textCache = \"\", this.renderer.buildText(l)), this;\n    }\n    function h(t) {\n      var _this$element;\n      var e = t.bBox,\n        s = (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.querySelector(\"textPath\");\n      if (s) {\n        var _t18 = [],\n          _this$renderer$fontMe = this.renderer.fontMetrics(this.element),\n          _o9 = _this$renderer$fontMe.b,\n          _a8 = _this$renderer$fontMe.h,\n          _r3 = _a8 - _o9,\n          _n3 = RegExp('(<tspan>|<tspan(?!\\\\sclass=\"highcharts-br\")[^>]*>|<\\\\/tspan>)', \"g\"),\n          _l2 = s.innerHTML.replace(_n3, \"\").split(/<tspan class=\"highcharts-br\"[^>]*>/),\n          _h2 = _l2.length,\n          _p2 = function _p2(t, e) {\n            var a = e.x,\n              n = e.y,\n              l = (s.getRotationOfChar(t) - 90) * i,\n              h = Math.cos(l),\n              p = Math.sin(l);\n            return [[a - _r3 * h, n - _r3 * p], [a + _o9 * h, n + _o9 * p]];\n          };\n        for (var _e23 = 0, _i16 = 0; _i16 < _h2; _i16++) {\n          var _o10 = _l2[_i16].length;\n          for (var _a9 = 0; _a9 < _o10; _a9 += 5) try {\n            var _o11 = _e23 + _a9 + _i16,\n              _p3 = _p2(_o11, s.getStartPositionOfChar(_o11)),\n              _p4 = _slicedToArray(_p3, 2),\n              _r4 = _p4[0],\n              _n4 = _p4[1];\n            0 === _a9 ? (_t18.push(_n4), _t18.push(_r4)) : (0 === _i16 && _t18.unshift(_n4), _i16 === _h2 - 1 && _t18.push(_r4));\n          } catch (t) {\n            break;\n          }\n          _e23 += _o10 - 1;\n          try {\n            var _o12 = _e23 + _i16,\n              _a10 = s.getEndPositionOfChar(_o12),\n              _p5 = _p2(_o12, _a10),\n              _p6 = _slicedToArray(_p5, 2),\n              _r5 = _p6[0],\n              _n5 = _p6[1];\n            _t18.unshift(_n5), _t18.unshift(_r5);\n          } catch (t) {\n            break;\n          }\n        }\n        _t18.length && _t18.push(_t18[0].slice()), e.polygon = _t18;\n      }\n      return e;\n    }\n    function p(t) {\n      var _i$getDataLabelPath;\n      var e = t.labelOptions,\n        i = t.point,\n        s = e[i.formatPrefix + \"TextPath\"] || e.textPath;\n      s && !e.useHTML && (this.setTextPath(((_i$getDataLabelPath = i.getDataLabelPath) === null || _i$getDataLabelPath === void 0 ? void 0 : _i$getDataLabelPath.call(i, this)) || i.graphic, s), i.dataLabelPath && !s.enabled && (i.dataLabelPath = i.dataLabelPath.destroy()));\n    }\n    return {\n      compose: function compose(t) {\n        s(t, \"afterGetBBox\", h), s(t, \"beforeAddingDataLabel\", p);\n        var e = t.prototype;\n        e.setTextPath || (e.setTextPath = l);\n      }\n    };\n  }), i(e, \"Series/PackedBubble/PackedBubbleSeries.js\", [e[\"Core/Color/Color.js\"], e[\"Series/DragNodesComposition.js\"], e[\"Series/GraphLayoutComposition.js\"], e[\"Core/Globals.js\"], e[\"Series/PackedBubble/PackedBubblePoint.js\"], e[\"Series/PackedBubble/PackedBubbleSeriesDefaults.js\"], e[\"Series/PackedBubble/PackedBubbleLayout.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Series/SimulationSeriesUtilities.js\"], e[\"Core/Utilities.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Extensions/TextPath.js\"]], function (t, e, i, s, o, a, r, n, l, h, p, d) {\n    var c = t.parse,\n      u = s.noop,\n      g = n.series.prototype,\n      f = n.seriesTypes.bubble,\n      b = l.initDataLabels,\n      m = l.initDataLabelsDefer,\n      y = h.addEvent,\n      x = h.clamp,\n      P = h.defined,\n      S = h.extend,\n      M = h.fireEvent,\n      L = h.isArray,\n      C = h.isNumber,\n      k = h.merge,\n      v = h.pick;\n    d.compose(p);\n    var A = /*#__PURE__*/function (_f3) {\n      function A() {\n        var _this10;\n        _classCallCheck(this, A);\n        _this10 = _callSuper(this, A, arguments), _this10.parentNodeMass = 0, _this10.deferDataLabels = !0;\n        return _this10;\n      }\n      _inherits(A, _f3);\n      return _createClass(A, [{\n        key: \"accumulateAllPoints\",\n        value: function accumulateAllPoints() {\n          var t;\n          var e = this.chart,\n            i = [];\n          var _iterator25 = _createForOfIteratorHelper(e.series),\n            _step25;\n          try {\n            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n              var _s17 = _step25.value;\n              if (_s17.is(\"packedbubble\") && _s17.reserveSpace()) {\n                t = _s17.yData || [];\n                for (var _e24 = 0; _e24 < t.length; _e24++) i.push([null, null, t[_e24], _s17.index, _e24, {\n                  id: _e24,\n                  marker: {\n                    radius: 0\n                  }\n                }]);\n              }\n            }\n          } catch (err) {\n            _iterator25.e(err);\n          } finally {\n            _iterator25.f();\n          }\n          return i;\n        }\n      }, {\n        key: \"addLayout\",\n        value: function addLayout() {\n          var t = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n            e = t.type || \"packedbubble\",\n            s = this.chart.options.chart,\n            o = this.chart.graphLayoutsStorage,\n            a = this.chart.graphLayoutsLookup,\n            r;\n          o || (this.chart.graphLayoutsStorage = o = {}, this.chart.graphLayoutsLookup = a = []), (r = o[e]) || (t.enableSimulation = P(s.forExport) ? !s.forExport : t.enableSimulation, o[e] = r = new i.layouts[e](), r.init(t), a.splice(r.index, 0, r)), this.layout = r, this.points.forEach(function (t) {\n            t.mass = 2, t.degree = 1, t.collisionNmb = 1;\n          }), r.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight), r.addElementsToCollection([this], r.series), r.addElementsToCollection(this.points, r.nodes);\n        }\n      }, {\n        key: \"addSeriesLayout\",\n        value: function addSeriesLayout() {\n          var t = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n            e = t.type || \"packedbubble\",\n            s = this.chart.graphLayoutsStorage,\n            o = this.chart.graphLayoutsLookup,\n            a = k(t, t.parentNodeOptions, {\n              enableSimulation: this.layout.options.enableSimulation\n            }),\n            r = s[e + \"-series\"];\n          r || (s[e + \"-series\"] = r = new i.layouts[e](), r.init(a), o.splice(r.index, 0, r)), this.parentNodeLayout = r, this.createParentNodes();\n        }\n      }, {\n        key: \"calculateParentRadius\",\n        value: function calculateParentRadius() {\n          var t = this.seriesBox();\n          this.parentNodeRadius = x(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, t ? Math.max(Math.sqrt(Math.pow(t.width, 2) + Math.pow(t.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20), this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);\n        }\n      }, {\n        key: \"calculateZExtremes\",\n        value: function calculateZExtremes() {\n          var t = this.chart.series,\n            e = this.options.zMin,\n            i = this.options.zMax,\n            s = 1 / 0,\n            o = -1 / 0;\n          return e && i ? [e, i] : (t.forEach(function (t) {\n            t.yData.forEach(function (t) {\n              P(t) && (t > o && (o = t), t < s && (s = t));\n            });\n          }), [e = v(e, s), i = v(i, o)]);\n        }\n      }, {\n        key: \"checkOverlap\",\n        value: function checkOverlap(t, e) {\n          var i = t[0] - e[0],\n            s = t[1] - e[1];\n          return Math.sqrt(i * i + s * s) - Math.abs(t[2] + e[2]) < -.001;\n        }\n      }, {\n        key: \"createParentNodes\",\n        value: function createParentNodes() {\n          var _this11 = this;\n          var t = this.pointClass,\n            e = this.chart,\n            i = this.parentNodeLayout,\n            s = this.layout.options,\n            o,\n            a = this.parentNode,\n            r = {\n              radius: this.parentNodeRadius,\n              lineColor: this.color,\n              fillColor: c(this.color).brighten(.4).get()\n            };\n          s.parentNodeOptions && (r = k(s.parentNodeOptions.marker || {}, r)), this.parentNodeMass = 0, this.points.forEach(function (t) {\n            _this11.parentNodeMass += Math.PI * Math.pow(t.marker.radius, 2);\n          }), this.calculateParentRadius(), i.nodes.forEach(function (t) {\n            t.seriesIndex === _this11.index && (o = !0);\n          }), i.setArea(0, 0, e.plotWidth, e.plotHeight), o || (a || (a = new t(this, {\n            mass: this.parentNodeRadius / 2,\n            marker: r,\n            dataLabels: {\n              inside: !1\n            },\n            states: {\n              normal: {\n                marker: r\n              },\n              hover: {\n                marker: r\n              }\n            },\n            dataLabelOnNull: !0,\n            degree: this.parentNodeRadius,\n            isParentNode: !0,\n            seriesIndex: this.index\n          })), this.parentNode && (a.plotX = this.parentNode.plotX, a.plotY = this.parentNode.plotY), this.parentNode = a, i.addElementsToCollection([this], i.series), i.addElementsToCollection([a], i.nodes));\n        }\n      }, {\n        key: \"deferLayout\",\n        value: function deferLayout() {\n          var t = this.options.layoutAlgorithm;\n          this.visible && (this.addLayout(), t.splitSeries && this.addSeriesLayout());\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var _this12 = this;\n          this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (t) {\n            t.removeElementFromCollection(_this12, t.series);\n          }, this), this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy())), g.destroy.apply(this, arguments);\n        }\n      }, {\n        key: \"drawDataLabels\",\n        value: function drawDataLabels() {\n          !this.deferDataLabels && (g.drawDataLabels.call(this, this.points), this.parentNode && (this.parentNode.formatPrefix = \"parentNode\", g.drawDataLabels.call(this, [this.parentNode])));\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          var _this$group;\n          if (!this.layout || !this.layout.options.splitSeries) return;\n          var t = this.chart,\n            e = this.layout.options.parentNodeOptions.marker,\n            i = {\n              fill: e.fillColor || c(this.color).brighten(.4).get(),\n              opacity: e.fillOpacity,\n              stroke: e.lineColor || this.color,\n              \"stroke-width\": v(e.lineWidth, this.options.lineWidth)\n            },\n            s = {};\n          this.parentNodesGroup = this.plotGroup(\"parentNodesGroup\", \"parentNode\", this.visible ? \"inherit\" : \"hidden\", .1, t.seriesGroup), (_this$group = this.group) !== null && _this$group !== void 0 && _this$group.attr({\n            zIndex: 2\n          }), this.calculateParentRadius(), this.parentNode && P(this.parentNode.plotX) && P(this.parentNode.plotY) && P(this.parentNodeRadius) && (s = k({\n            x: this.parentNode.plotX - this.parentNodeRadius,\n            y: this.parentNode.plotY - this.parentNodeRadius,\n            width: 2 * this.parentNodeRadius,\n            height: 2 * this.parentNodeRadius\n          }, i), this.parentNode.graphic || (this.graph = this.parentNode.graphic = t.renderer.symbol(i.symbol).add(this.parentNodesGroup)), this.parentNode.graphic.attr(s));\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          var t;\n          var e = this.parentNode;\n          _superPropGet(A, \"drawTracker\", this, 3)([]), e && (t = L(e.dataLabels) ? e.dataLabels : e.dataLabel ? [e.dataLabel] : [], e.graphic && (e.graphic.element.point = e), t.forEach(function (t) {\n            (t.div || t.element).point = e;\n          }));\n        }\n      }, {\n        key: \"getPointRadius\",\n        value: function getPointRadius() {\n          var _this13 = this;\n          var t, e, i, s;\n          var o = this.chart,\n            a = o.plotWidth,\n            r = o.plotHeight,\n            n = this.options,\n            l = n.useSimulation,\n            h = Math.min(a, r),\n            p = {},\n            d = [],\n            c = o.allDataPoints || [],\n            u = c.length;\n          [\"minSize\", \"maxSize\"].forEach(function (t) {\n            var e = parseInt(n[t], 10),\n              i = /%$/.test(n[t]);\n            p[t] = i ? h * e / 100 : e * Math.sqrt(u);\n          }), o.minRadius = t = p.minSize / Math.sqrt(u), o.maxRadius = e = p.maxSize / Math.sqrt(u);\n          var g = l ? this.calculateZExtremes() : [t, e];\n          c.forEach(function (o, a) {\n            i = l ? x(o[2], g[0], g[1]) : o[2], 0 === (s = _this13.getRadius(g[0], g[1], t, e, i)) && (s = null), c[a][2] = s, d.push(s);\n          }), this.radii = d;\n        }\n      }, {\n        key: \"init\",\n        value: function init() {\n          return g.init.apply(this, arguments), m.call(this), this.eventsToUnbind.push(y(this, \"updatedData\", function () {\n            var _this14 = this;\n            this.chart.series.forEach(function (t) {\n              t.type === _this14.type && (t.isDirty = !0);\n            }, this);\n          })), this;\n        }\n      }, {\n        key: \"onMouseUp\",\n        value: function onMouseUp(t) {\n          if (t.fixedPosition && !t.removed) {\n            var _i17;\n            var _s18 = this.layout,\n              _o13 = this.parentNodeLayout;\n            _o13 && _s18.options.dragBetweenSeries && _o13.nodes.forEach(function (e) {\n              t && t.marker && e !== t.series.parentNode && (_i17 = _s18.getDistXY(t, e), _s18.vectorLength(_i17) - e.marker.radius - t.marker.radius < 0 && (e.series.addPoint(k(t.options, {\n                plotX: t.plotX,\n                plotY: t.plotY\n              }), !1), _s18.removeElementFromCollection(t, _s18.nodes), t.remove()));\n            }), e.onMouseUp.apply(this, arguments);\n          }\n        }\n      }, {\n        key: \"placeBubbles\",\n        value: function placeBubbles(t) {\n          var e = this.checkOverlap,\n            i = this.positionBubble,\n            s = [],\n            o = 1,\n            a = 0,\n            r = 0,\n            n,\n            l = [],\n            h,\n            p = t.sort(function (t, e) {\n              return e[2] - t[2];\n            });\n          if (p.length) {\n            if (s.push([[0, 0, p[0][2], p[0][3], p[0][4]]]), p.length > 1) for (s.push([[0, 0 - p[1][2] - p[0][2], p[1][2], p[1][3], p[1][4]]]), h = 2; h < p.length; h++) p[h][2] = p[h][2] || 1, e(n = i(s[o][a], s[o - 1][r], p[h]), s[o][0]) ? (s.push([]), r = 0, s[o + 1].push(i(s[o][a], s[o][0], p[h])), o++, a = 0) : o > 1 && s[o - 1][r + 1] && e(n, s[o - 1][r + 1]) ? (r++, s[o].push(i(s[o][a], s[o - 1][r], p[h])), a++) : (a++, s[o].push(n));\n            this.chart.stages = s, this.chart.rawPositions = [].concat.apply([], s), this.resizeRadius(), l = this.chart.rawPositions;\n          }\n          return l;\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(t, e) {\n          var i = this.options,\n            s = t && t.isParentNode,\n            o = i.marker;\n          s && i.layoutAlgorithm && i.layoutAlgorithm.parentNodeOptions && (o = i.layoutAlgorithm.parentNodeOptions.marker);\n          var a = o.fillOpacity,\n            r = g.pointAttribs.call(this, t, e);\n          return 1 !== a && (r[\"fill-opacity\"] = a), r;\n        }\n      }, {\n        key: \"positionBubble\",\n        value: function positionBubble(t, e, i) {\n          var s = Math.asin,\n            o = Math.acos,\n            a = Math.pow,\n            r = Math.abs,\n            n = (0, Math.sqrt)(a(t[0] - e[0], 2) + a(t[1] - e[1], 2)),\n            l = o((a(n, 2) + a(i[2] + e[2], 2) - a(i[2] + t[2], 2)) / (2 * (i[2] + e[2]) * n)),\n            h = s(r(t[0] - e[0]) / n),\n            p = (t[1] - e[1] < 0 ? 0 : Math.PI) + l + h * ((t[0] - e[0]) * (t[1] - e[1]) < 0 ? 1 : -1),\n            d = Math.cos(p),\n            c = Math.sin(p);\n          return [e[0] + (e[2] + i[2]) * c, e[1] - (e[2] + i[2]) * d, i[2], i[3], i[4]];\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t = [];\n          g.render.apply(this, arguments), !this.options.dataLabels.allowOverlap && (this.data.forEach(function (e) {\n            L(e.dataLabels) && e.dataLabels.forEach(function (e) {\n              t.push(e);\n            });\n          }), this.options.useSimulation && this.chart.hideOverlappingLabels(t));\n        }\n      }, {\n        key: \"resizeRadius\",\n        value: function resizeRadius() {\n          var t, e, i, s, o;\n          var a = this.chart,\n            r = a.rawPositions,\n            n = Math.min,\n            l = Math.max,\n            h = a.plotLeft,\n            p = a.plotTop,\n            d = a.plotHeight,\n            c = a.plotWidth;\n          var _iterator26 = _createForOfIteratorHelper((t = i = Number.POSITIVE_INFINITY, e = s = Number.NEGATIVE_INFINITY, r)),\n            _step26;\n          try {\n            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n              var _a11 = _step26.value;\n              o = _a11[2], t = n(t, _a11[0] - o), e = l(e, _a11[0] + o), i = n(i, _a11[1] - o), s = l(s, _a11[1] + o);\n            }\n          } catch (err) {\n            _iterator26.e(err);\n          } finally {\n            _iterator26.f();\n          }\n          var u = [e - t, s - i],\n            g = [(c - h) / u[0], (d - p) / u[1]],\n            f = n.apply([], g);\n          if (Math.abs(f - 1) > 1e-10) {\n            var _iterator27 = _createForOfIteratorHelper(r),\n              _step27;\n            try {\n              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                var _t19 = _step27.value;\n                _t19[2] *= f;\n              }\n            } catch (err) {\n              _iterator27.e(err);\n            } finally {\n              _iterator27.f();\n            }\n            this.placeBubbles(r);\n          } else a.diffY = d / 2 + p - i - (s - i) / 2, a.diffX = c / 2 + h - t - (e - t) / 2;\n        }\n      }, {\n        key: \"seriesBox\",\n        value: function seriesBox() {\n          var t;\n          var e = this.chart,\n            i = this.data,\n            s = Math.max,\n            o = Math.min,\n            a = [e.plotLeft, e.plotLeft + e.plotWidth, e.plotTop, e.plotTop + e.plotHeight];\n          return i.forEach(function (e) {\n            P(e.plotX) && P(e.plotY) && e.marker.radius && (t = e.marker.radius, a[0] = o(a[0], e.plotX - t), a[1] = s(a[1], e.plotX + t), a[2] = o(a[2], e.plotY - t), a[3] = s(a[3], e.plotY + t));\n          }), C(a.width / a.height) ? a : null;\n        }\n      }, {\n        key: \"setVisible\",\n        value: function setVisible() {\n          var t = this;\n          g.setVisible.apply(t, arguments), t.parentNodeLayout && t.graph ? t.visible ? (t.graph.show(), t.parentNode.dataLabel && t.parentNode.dataLabel.show()) : (t.graph.hide(), t.parentNodeLayout.removeElementFromCollection(t.parentNode, t.parentNodeLayout.nodes), t.parentNode.dataLabel && t.parentNode.dataLabel.hide()) : t.layout && (t.visible ? t.layout.addElementsToCollection(t.points, t.layout.nodes) : t.points.forEach(function (e) {\n            t.layout.removeElementFromCollection(e, t.layout.nodes);\n          }));\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          var t, e, i;\n          var s = this.chart,\n            o = this.data,\n            a = this.index,\n            r = this.options.useSimulation;\n          var _iterator28 = _createForOfIteratorHelper((this.processedXData = this.xData, this.generatePoints(), P(s.allDataPoints) || (s.allDataPoints = this.accumulateAllPoints(), this.getPointRadius()), r ? i = s.allDataPoints : (i = this.placeBubbles(s.allDataPoints), this.options.draggable = !1), i)),\n            _step28;\n          try {\n            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n              var _n6 = _step28.value;\n              _n6[3] === a && (t = o[_n6[4]], e = v(_n6[2], void 0), r || (t.plotX = _n6[0] - s.plotLeft + s.diffX, t.plotY = _n6[1] - s.plotTop + s.diffY), C(e) && (t.marker = S(t.marker, {\n                radius: e,\n                width: 2 * e,\n                height: 2 * e\n              }), t.radius = e));\n            }\n          } catch (err) {\n            _iterator28.e(err);\n          } finally {\n            _iterator28.f();\n          }\n          r && this.deferLayout(), M(this, \"afterTranslate\");\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t, i, s) {\n          f.compose(t, i, s), e.compose(i), r.compose(i);\n        }\n      }]);\n    }(f);\n    return A.defaultOptions = k(f.defaultOptions, a), S(A.prototype, {\n      pointClass: o,\n      axisTypes: [],\n      directTouch: !0,\n      forces: [\"barycenter\", \"repulsive\"],\n      hasDraggableNodes: !0,\n      invertible: !1,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointArrayMap: [\"value\"],\n      pointValKey: \"value\",\n      requireSorting: !1,\n      trackerGroups: [\"group\", \"dataLabelsGroup\", \"parentNodesGroup\"],\n      initDataLabels: b,\n      alignDataLabel: g.alignDataLabel,\n      indexateNodes: u,\n      onMouseDown: e.onMouseDown,\n      onMouseMove: e.onMouseMove,\n      redrawHalo: e.redrawHalo,\n      searchPoint: u\n    }), n.registerSeriesType(\"packedbubble\", A), A;\n  }), i(e, \"Series/Polygon/PolygonSeriesDefaults.js\", [], function () {\n    return {\n      marker: {\n        enabled: !1,\n        states: {\n          hover: {\n            enabled: !1\n          }\n        }\n      },\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0,\n        pointFormat: \"\"\n      },\n      trackByArea: !0,\n      legendSymbol: \"rectangle\"\n    };\n  }), i(e, \"Series/Polygon/PolygonSeries.js\", [e[\"Core/Globals.js\"], e[\"Series/Polygon/PolygonSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o = t.noop,\n      _i$seriesTypes3 = i.seriesTypes,\n      a = _i$seriesTypes3.area,\n      r = _i$seriesTypes3.line,\n      n = _i$seriesTypes3.scatter,\n      l = s.extend,\n      h = s.merge;\n    var p = /*#__PURE__*/function (_n7) {\n      function p() {\n        _classCallCheck(this, p);\n        return _callSuper(this, p, arguments);\n      }\n      _inherits(p, _n7);\n      return _createClass(p, [{\n        key: \"getGraphPath\",\n        value: function getGraphPath() {\n          var t = r.prototype.getGraphPath.call(this),\n            e = t.length + 1;\n          for (; e--;) (e === t.length || \"M\" === t[e][0]) && e > 0 && t.splice(e, 0, [\"Z\"]);\n          return this.areaPath = t, t;\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          this.options.fillColor = this.color, a.prototype.drawGraph.call(this);\n        }\n      }]);\n    }(n);\n    return p.defaultOptions = h(n.defaultOptions, e), l(p.prototype, {\n      type: \"polygon\",\n      drawTracker: r.prototype.drawTracker,\n      setStackedPoints: o\n    }), i.registerSeriesType(\"polygon\", p), p;\n  }), i(e, \"Core/Axis/RadialAxisDefaults.js\", [], function () {\n    return {\n      circular: {\n        gridLineWidth: 1,\n        labels: {\n          align: void 0,\n          x: 0,\n          y: void 0,\n          style: {\n            textOverflow: \"none\"\n          }\n        },\n        maxPadding: 0,\n        minPadding: 0,\n        showLastLabel: !1,\n        tickLength: 0\n      },\n      radial: {\n        gridLineInterpolation: \"circle\",\n        gridLineWidth: 1,\n        labels: {\n          align: \"right\",\n          padding: 5,\n          x: -3,\n          y: -2\n        },\n        showLastLabel: !1,\n        title: {\n          x: 4,\n          text: null,\n          rotation: 90\n        }\n      },\n      radialGauge: {\n        endOnTick: !1,\n        gridLineWidth: 0,\n        labels: {\n          align: \"center\",\n          distance: -25,\n          x: 0,\n          y: void 0\n        },\n        lineWidth: 1,\n        minorGridLineWidth: 0,\n        minorTickInterval: \"auto\",\n        minorTickLength: 10,\n        minorTickPosition: \"inside\",\n        minorTickWidth: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickPosition: \"inside\",\n        tickWidth: 2,\n        title: {\n          rotation: 0,\n          text: \"\"\n        },\n        zIndex: 2\n      }\n    };\n  }), i(e, \"Core/Axis/RadialAxis.js\", [e[\"Core/Axis/RadialAxisDefaults.js\"], e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o;\n    var a = e.defaultOptions,\n      r = i.composed,\n      n = i.noop,\n      l = s.addEvent,\n      h = s.correctFloat,\n      p = s.defined,\n      d = s.extend,\n      c = s.fireEvent,\n      u = s.isObject,\n      g = s.merge,\n      f = s.pick,\n      b = s.pushUnique,\n      m = s.relativeLength,\n      y = s.wrap;\n    return function (e) {\n      function s() {\n        this.autoConnect = this.isCircular && void 0 === f(this.userMax, this.options.max) && h(this.endAngleRad - this.startAngleRad) === h(2 * Math.PI), !this.isCircular && this.chart.inverted && this.max++, this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);\n      }\n      function o() {\n        var _this15 = this;\n        return function () {\n          if (_this15.isRadial && _this15.tickPositions && _this15.options.labels && !0 !== _this15.options.labels.allowOverlap) return _this15.tickPositions.map(function (t) {\n            return _this15.ticks[t] && _this15.ticks[t].label;\n          }).filter(function (t) {\n            return !!t;\n          });\n        };\n      }\n      function x() {\n        return n;\n      }\n      function P(t, e, i) {\n        var s = this.pane.center,\n          o = t.value,\n          a,\n          r,\n          n;\n        return this.isCircular ? (p(o) ? t.point && (t.point.shapeArgs || {}).start && (o = this.chart.inverted ? this.translate(t.point.rectPlotY, !0) : t.point.x) : (r = t.chartX || 0, n = t.chartY || 0, o = this.translate(Math.atan2(n - i, r - e) - this.startAngleRad, !0)), r = (a = this.getPosition(o)).x, n = a.y) : (p(o) || (r = t.chartX, n = t.chartY), p(r) && p(n) && (i = s[1] + this.chart.plotTop, o = this.translate(Math.min(Math.sqrt(Math.pow(r - e, 2) + Math.pow(n - i, 2)), s[2] / 2) - s[3] / 2, !0))), [o, r || 0, n || 0];\n      }\n      function S(t, e, i) {\n        var s = this.pane.center,\n          o = this.chart,\n          a = this.left || 0,\n          r = this.top || 0,\n          n,\n          l = f(e, s[2] / 2 - this.offset),\n          h;\n        return void 0 === i && (i = this.horiz ? 0 : this.center && -this.center[3] / 2), i && (l += i), this.isCircular || void 0 !== e ? ((h = this.chart.renderer.symbols.arc(a + s[0], r + s[1], l, l, {\n          start: this.startAngleRad,\n          end: this.endAngleRad,\n          open: !0,\n          innerR: 0\n        })).xBounds = [a + s[0]], h.yBounds = [r + s[1] - l]) : (n = this.postTranslate(this.angleRad, l), h = [[\"M\", this.center[0] + o.plotLeft, this.center[1] + o.plotTop], [\"L\", n.x, n.y]]), h;\n      }\n      function M() {\n        this.constructor.prototype.getOffset.call(this), this.chart.axisOffset[this.side] = 0;\n      }\n      function L(t, e, i) {\n        var s = this.chart,\n          o = function o(t) {\n            if (\"string\" == typeof t) {\n              var _e25 = parseInt(t, 10);\n              return d.test(t) && (_e25 = _e25 * n / 100), _e25;\n            }\n            return t;\n          },\n          a = this.center,\n          r = this.startAngleRad,\n          n = a[2] / 2,\n          l = Math.min(this.offset, 0),\n          h = this.left || 0,\n          p = this.top || 0,\n          d = /%$/,\n          c = this.isCircular,\n          u,\n          g,\n          b,\n          m,\n          y,\n          x,\n          P = f(o(i.outerRadius), n),\n          S = o(i.innerRadius),\n          M = f(o(i.thickness), 10);\n        if (\"polygon\" === this.options.gridLineInterpolation) x = this.getPlotLinePath({\n          value: t\n        }).concat(this.getPlotLinePath({\n          value: e,\n          reverse: !0\n        }));else {\n          t = Math.max(t, this.min), e = Math.min(e, this.max);\n          var _o14 = this.translate(t),\n            _n8 = this.translate(e);\n          c || (P = _o14 || 0, S = _n8 || 0), \"circle\" !== i.shape && c ? (u = r + (_o14 || 0), g = r + (_n8 || 0)) : (u = -Math.PI / 2, g = 1.5 * Math.PI, y = !0), P -= l, M -= l, x = s.renderer.symbols.arc(h + a[0], p + a[1], P, P, {\n            start: Math.min(u, g),\n            end: Math.max(u, g),\n            innerR: f(S, P - M),\n            open: y,\n            borderRadius: i.borderRadius\n          }), c && (b = (g + u) / 2, m = h + a[0] + a[2] / 2 * Math.cos(b), x.xBounds = b > -Math.PI / 2 && b < Math.PI / 2 ? [m, s.plotWidth] : [0, m], x.yBounds = [p + a[1] + a[2] / 2 * Math.sin(b)], x.yBounds[0] += b > -Math.PI && b < 0 || b > Math.PI ? -10 : 10);\n        }\n        return x;\n      }\n      function C(t) {\n        var _this16 = this;\n        var e = this.pane.center,\n          i = this.chart,\n          s = i.inverted,\n          o = t.reverse,\n          a = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},\n          r = a.innerRadius || \"0%\",\n          n = a.outerRadius || \"100%\",\n          l = e[0] + i.plotLeft,\n          h = e[1] + i.plotTop,\n          p = this.height,\n          d = t.isCrosshair,\n          c = e[3] / 2,\n          u = t.value,\n          g,\n          f,\n          b,\n          y,\n          x,\n          P,\n          S,\n          M,\n          L,\n          C = this.getPosition(u),\n          k = C.x,\n          v = C.y;\n        if (d && (u = (M = this.getCrosshairPosition(t, l, h))[0], k = M[1], v = M[2]), this.isCircular) f = Math.sqrt(Math.pow(k - l, 2) + Math.pow(v - h, 2)), b = \"string\" == typeof r ? m(r, 1) : r / f, y = \"string\" == typeof n ? m(n, 1) : n / f, e && c && (b < (g = c / f) && (b = g), y < g && (y = g)), L = [[\"M\", l + b * (k - l), h - b * (h - v)], [\"L\", k - (1 - y) * (k - l), v + (1 - y) * (h - v)]];else if ((u = this.translate(u)) && (u < 0 || u > p) && (u = 0), \"circle\" === this.options.gridLineInterpolation) L = this.getLinePath(0, u, c);else if (L = [], i[s ? \"yAxis\" : \"xAxis\"].forEach(function (t) {\n          t.pane === _this16.pane && (x = t);\n        }), x) {\n          S = x.tickPositions, x.autoConnect && (S = S.concat([S[0]])), o && (S = S.slice().reverse()), u && (u += c);\n          for (var _t20 = 0; _t20 < S.length; _t20++) P = x.getPosition(S[_t20], u), L.push(_t20 ? [\"L\", P.x, P.y] : [\"M\", P.x, P.y]);\n        }\n        return L;\n      }\n      function k(t, e) {\n        var i = this.translate(t);\n        return this.postTranslate(this.isCircular ? i : this.angleRad, f(this.isCircular ? e : i < 0 ? 0 : i, this.center[2] / 2) - this.offset);\n      }\n      function v() {\n        var t = this.center,\n          e = this.chart,\n          i = this.options.title;\n        return {\n          x: e.plotLeft + t[0] + (i.x || 0),\n          y: e.plotTop + t[1] - {\n            high: .5,\n            middle: .25,\n            low: 0\n          }[i.align] * t[2] + (i.y || 0)\n        };\n      }\n      function A(t) {\n        t.beforeSetTickPositions = s, t.createLabelCollector = o, t.getCrosshairPosition = P, t.getLinePath = S, t.getOffset = M, t.getPlotBandPath = L, t.getPlotLinePath = C, t.getPosition = k, t.getTitlePosition = v, t.postTranslate = D, t.setAxisSize = B, t.setAxisTranslation = z, t.setOptions = O;\n      }\n      function w() {\n        var t = this.chart,\n          e = this.options,\n          i = t.angular && this.isXAxis,\n          s = this.pane,\n          o = s && s.options;\n        if (!i && s && (t.angular || t.polar)) {\n          var _t21 = 2 * Math.PI,\n            _i18 = (f(o.startAngle, 0) - 90) * Math.PI / 180,\n            _s19 = (f(o.endAngle, f(o.startAngle, 0) + 360) - 90) * Math.PI / 180;\n          this.angleRad = (e.angle || 0) * Math.PI / 180, this.startAngleRad = _i18, this.endAngleRad = _s19, this.offset = e.offset || 0;\n          var _a12 = (_i18 % _t21 + _t21) % _t21,\n            _r6 = (_s19 % _t21 + _t21) % _t21;\n          _a12 > Math.PI && (_a12 -= _t21), _r6 > Math.PI && (_r6 -= _t21), this.normalizedStartAngleRad = _a12, this.normalizedEndAngleRad = _r6;\n        }\n      }\n      function T(t) {\n        this.isRadial && (t.align = void 0, t.preventDefault());\n      }\n      function N() {\n        if (this.chart && this.chart.labelCollectors) {\n          var _t22 = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;\n          _t22 >= 0 && this.chart.labelCollectors.splice(_t22, 1);\n        }\n      }\n      function X(t) {\n        var e;\n        var i = this.chart,\n          s = i.angular,\n          o = i.polar,\n          a = this.isXAxis,\n          r = this.coll,\n          l = t.userOptions.pane || 0,\n          h = this.pane = i.pane && i.pane[l];\n        if (\"colorAxis\" === r) {\n          this.isRadial = !1;\n          return;\n        }\n        s ? (s && a ? (this.isHidden = !0, this.createLabelCollector = x, this.getOffset = n, this.redraw = E, this.render = E, this.setScale = n, this.setCategories = n, this.setTitle = n) : A(this), e = !a) : o && (A(this), e = this.horiz), s || o ? (this.isRadial = !0, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && i.labelCollectors.push(this.labelCollector)) : this.isRadial = !1, h && e && (h.axis = this), this.isCircular = e;\n      }\n      function R() {\n        this.isRadial && this.beforeSetTickPositions();\n      }\n      function Y(t) {\n        var e = this.label;\n        if (!e) return;\n        var i = this.axis,\n          s = e.getBBox(),\n          o = i.options.labels,\n          a = (i.translate(this.pos) + i.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,\n          r = Math.round(a),\n          n = p(o.y) ? 0 : -(.3 * s.height),\n          l = o.y,\n          h,\n          d = 20,\n          c = o.align,\n          u = \"end\",\n          g = r < 0 ? r + 360 : r,\n          b = g,\n          y = 0,\n          x = 0;\n        i.isRadial && (h = i.getPosition(this.pos, i.center[2] / 2 + m(f(o.distance, -25), i.center[2] / 2, -i.center[2] / 2)), \"auto\" === o.rotation ? e.attr({\n          rotation: a\n        }) : p(l) || (l = i.chart.renderer.fontMetrics(e).b - s.height / 2), p(c) || (i.isCircular ? (s.width > i.len * i.tickInterval / (i.max - i.min) && (d = 0), c = a > d && a < 180 - d ? \"left\" : a > 180 + d && a < 360 - d ? \"right\" : \"center\") : c = \"center\", e.attr({\n          align: c\n        })), \"auto\" === c && 2 === i.tickPositions.length && i.isCircular && (g > 90 && g < 180 ? g = 180 - g : g > 270 && g <= 360 && (g = 540 - g), b > 180 && b <= 360 && (b = 360 - b), (i.pane.options.startAngle === r || i.pane.options.startAngle === r + 360 || i.pane.options.startAngle === r - 360) && (u = \"start\"), c = r >= -90 && r <= 90 || r >= -360 && r <= -270 || r >= 270 && r <= 360 ? \"start\" === u ? \"right\" : \"left\" : \"start\" === u ? \"left\" : \"right\", b > 70 && b < 110 && (c = \"center\"), g < 15 || g >= 180 && g < 195 ? y = .3 * s.height : g >= 15 && g <= 35 ? y = \"start\" === u ? 0 : .75 * s.height : g >= 195 && g <= 215 ? y = \"start\" === u ? .75 * s.height : 0 : g > 35 && g <= 90 ? y = \"start\" === u ? -(.25 * s.height) : s.height : g > 215 && g <= 270 && (y = \"start\" === u ? s.height : -(.25 * s.height)), b < 15 ? x = \"start\" === u ? -(.15 * s.height) : .15 * s.height : b > 165 && b <= 180 && (x = \"start\" === u ? .15 * s.height : -(.15 * s.height)), e.attr({\n          align: c\n        }), e.translate(x, y + n)), t.pos.x = h.x + (o.x || 0), t.pos.y = h.y + (l || 0));\n      }\n      function j(t) {\n        this.axis.getPosition && d(t.pos, this.axis.getPosition(this.pos));\n      }\n      function I(_ref2) {\n        var t = _ref2.options;\n        t.xAxis && g(!0, e.radialDefaultOptions.circular, t.xAxis), t.yAxis && g(!0, e.radialDefaultOptions.radialGauge, t.yAxis);\n      }\n      function D(t, e) {\n        var i = this.chart,\n          s = this.center;\n        return t = this.startAngleRad + t, {\n          x: i.plotLeft + s[0] + Math.cos(t) * e,\n          y: i.plotTop + s[1] + Math.sin(t) * e\n        };\n      }\n      function E() {\n        this.isDirty = !1;\n      }\n      function B() {\n        var t, e;\n        this.constructor.prototype.setAxisSize.call(this), this.isRadial && (this.pane.updateCenter(this), t = this.center = this.pane.center.slice(), this.isCircular ? this.sector = this.endAngleRad - this.startAngleRad : (e = this.postTranslate(this.angleRad, t[3] / 2), t[0] = e.x - this.chart.plotLeft, t[1] = e.y - this.chart.plotTop), this.len = this.width = this.height = (t[2] - t[3]) * f(this.sector, 1) / 2);\n      }\n      function z() {\n        this.constructor.prototype.setAxisTranslation.call(this), this.center && (this.isCircular ? this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.isXAxis ? this.minPixelPadding = this.transA * this.minPointOffset : this.minPixelPadding = 0);\n      }\n      function O(t) {\n        var i = this.coll,\n          _this$chart = this.chart,\n          s = _this$chart.angular,\n          o = _this$chart.inverted,\n          r = _this$chart.polar,\n          n = {};\n        s ? this.isXAxis || (n = g(a.yAxis, e.radialDefaultOptions.radialGauge)) : r && (n = this.horiz ? g(a.xAxis, e.radialDefaultOptions.circular) : g(\"xAxis\" === i ? a.xAxis : a.yAxis, e.radialDefaultOptions.radial)), o && \"yAxis\" === i && (n.stackLabels = u(a.yAxis, !0) ? a.yAxis.stackLabels : {}, n.reversedStacks = !0);\n        var l = this.options = g(n, t);\n        l.plotBands || (l.plotBands = []), c(this, \"afterSetOptions\");\n      }\n      function W(t, e, i, s, o, a, r) {\n        var n;\n        var l = this.axis;\n        return l.isRadial ? [\"M\", e, i, \"L\", (n = l.getPosition(this.pos, l.center[2] / 2 + s)).x, n.y] : t.call(this, e, i, s, o, a, r);\n      }\n      e.radialDefaultOptions = g(t), e.compose = function (t, e) {\n        return b(r, \"Axis.Radial\") && (l(t, \"afterInit\", w), l(t, \"autoLabelAlign\", T), l(t, \"destroy\", N), l(t, \"init\", X), l(t, \"initialAxisTranslation\", R), l(e, \"afterGetLabelPosition\", Y), l(e, \"afterGetPosition\", j), l(i, \"setOptions\", I), y(e.prototype, \"getMarkPath\", W)), t;\n      };\n    }(o || (o = {})), o;\n  }), i(e, \"Series/PolarComposition.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Extensions/Pane/Pane.js\"], e[\"Core/Axis/RadialAxis.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, a) {\n    var r = t.animObject,\n      n = e.composed,\n      l = a.addEvent,\n      h = a.defined,\n      p = a.find,\n      d = a.isNumber,\n      c = a.merge,\n      u = a.pick,\n      g = a.pushUnique,\n      f = a.relativeLength,\n      b = a.splat,\n      m = a.uniqueKey,\n      y = a.wrap;\n    function x() {\n      (this.pane || []).forEach(function (t) {\n        t.render();\n      });\n    }\n    function P(t) {\n      var e = t.args[0].xAxis,\n        i = t.args[0].yAxis,\n        s = t.args[0].chart;\n      e && i && (\"polygon\" === i.gridLineInterpolation ? (e.startOnTick = !0, e.endOnTick = !0) : \"polygon\" === e.gridLineInterpolation && s.inverted && (i.startOnTick = !0, i.endOnTick = !0));\n    }\n    function S() {\n      var _this17 = this;\n      this.pane || (this.pane = []), this.options.pane = b(this.options.pane), this.options.pane.forEach(function (t) {\n        new s(t, _this17);\n      }, this);\n    }\n    function M(t) {\n      var e = t.args.marker,\n        i = this.chart.xAxis[0],\n        s = this.chart.yAxis[0],\n        o = this.chart.inverted,\n        a = o ? s : i,\n        r = o ? i : s;\n      if (this.chart.polar) {\n        t.preventDefault();\n        var _i19 = (e.attr ? e.attr(\"start\") : e.start) - a.startAngleRad,\n          _s20 = e.attr ? e.attr(\"r\") : e.r,\n          _o15 = (e.attr ? e.attr(\"end\") : e.end) - a.startAngleRad,\n          _n9 = e.attr ? e.attr(\"innerR\") : e.innerR;\n        t.result.x = _i19 + a.pos, t.result.width = _o15 - _i19, t.result.y = r.len + r.pos - _s20, t.result.height = _s20 - _n9;\n      }\n    }\n    function L(t) {\n      var e = this.chart;\n      if (e.polar && e.hoverPane && e.hoverPane.axis) {\n        t.preventDefault();\n        var _i20 = e.hoverPane.center,\n          _s21 = e.mouseDownX || 0,\n          _o16 = e.mouseDownY || 0,\n          _a13 = t.args.chartY,\n          _r7 = t.args.chartX,\n          _n10 = 2 * Math.PI,\n          _l3 = e.hoverPane.axis.startAngleRad,\n          _h3 = e.hoverPane.axis.endAngleRad,\n          _p7 = e.inverted ? e.xAxis[0] : e.yAxis[0],\n          _d2 = {},\n          _c = \"arc\";\n        if (_d2.x = _i20[0] + e.plotLeft, _d2.y = _i20[1] + e.plotTop, this.zoomHor) {\n          var _t23 = _l3 > 0 ? _h3 - _l3 : Math.abs(_l3) + Math.abs(_h3),\n            _u = Math.atan2(_o16 - e.plotTop - _i20[1], _s21 - e.plotLeft - _i20[0]) - _l3,\n            _g3 = Math.atan2(_a13 - e.plotTop - _i20[1], _r7 - e.plotLeft - _i20[0]) - _l3;\n          _d2.r = _i20[2] / 2, _d2.innerR = _i20[3] / 2, _u <= 0 && (_u += _n10), _g3 <= 0 && (_g3 += _n10), _g3 < _u && (_g3 = [_u, _u = _g3][0]), _t23 < _n10 && _l3 + _g3 > _h3 + (_n10 - _t23) / 2 && (_g3 = _u, _u = _l3 <= 0 ? _l3 : 0);\n          var _f4 = _d2.start = Math.max(_u + _l3, _l3),\n            _b = _d2.end = Math.min(_g3 + _l3, _h3);\n          if (\"polygon\" === _p7.options.gridLineInterpolation) {\n            var _t24 = e.hoverPane.axis,\n              _s22 = _f4 - _t24.startAngleRad + _t24.pos,\n              _o17 = _p7.getPlotLinePath({\n                value: _p7.max\n              }),\n              _a14 = _t24.toValue(_s22),\n              _r8 = _t24.toValue(_s22 + (_b - _f4));\n            if (_a14 < _t24.getExtremes().min) {\n              var _t24$getExtremes = _t24.getExtremes(),\n                _e26 = _t24$getExtremes.min,\n                _i21 = _t24$getExtremes.max;\n              _a14 = _i21 - (_e26 - _a14);\n            }\n            if (_r8 < _t24.getExtremes().min) {\n              var _t24$getExtremes2 = _t24.getExtremes(),\n                _e27 = _t24$getExtremes2.min,\n                _i22 = _t24$getExtremes2.max;\n              _r8 = _i22 - (_e27 - _r8);\n            }\n            _r8 < _a14 && (_r8 = [_a14, _a14 = _r8][0]), (_o17 = A(_o17, _a14, _r8, _t24)).push([\"L\", _i20[0] + e.plotLeft, e.plotTop + _i20[1]]), _d2.d = _o17, _c = \"path\";\n          }\n        }\n        if (this.zoomVert) {\n          var _t25 = e.inverted ? e.xAxis[0] : e.yAxis[0],\n            _n11 = Math.sqrt(Math.pow(_s21 - e.plotLeft - _i20[0], 2) + Math.pow(_o16 - e.plotTop - _i20[1], 2)),\n            _p8 = Math.sqrt(Math.pow(_r7 - e.plotLeft - _i20[0], 2) + Math.pow(_a13 - e.plotTop - _i20[1], 2));\n          if (_p8 < _n11 && (_n11 = [_p8, _p8 = _n11][0]), _p8 > _i20[2] / 2 && (_p8 = _i20[2] / 2), _n11 < _i20[3] / 2 && (_n11 = _i20[3] / 2), this.zoomHor || (_d2.start = _l3, _d2.end = _h3), _d2.r = _p8, _d2.innerR = _n11, \"polygon\" === _t25.options.gridLineInterpolation) {\n            var _e28 = _t25.toValue(_t25.len + _t25.pos - _n11),\n              _i23 = _t25.toValue(_t25.len + _t25.pos - _p8),\n              _s23 = _t25.getPlotLinePath({\n                value: _i23\n              }).concat(_t25.getPlotLinePath({\n                value: _e28,\n                reverse: !0\n              }));\n            _d2.d = _s23, _c = \"path\";\n          }\n        }\n        if (this.zoomHor && this.zoomVert && \"polygon\" === _p7.options.gridLineInterpolation) {\n          var _t26 = e.hoverPane.axis,\n            _i24 = _d2.start || 0,\n            _s24 = _d2.end || 0,\n            _o18 = _i24 - _t26.startAngleRad + _t26.pos,\n            _a15 = _t26.toValue(_o18),\n            _r9 = _t26.toValue(_o18 + (_s24 - _i24));\n          if (_d2.d instanceof Array) {\n            var _t27 = _d2.d.slice(0, _d2.d.length / 2),\n              _i25 = _d2.d.slice(_d2.d.length / 2, _d2.d.length);\n            _i25 = _toConsumableArray(_i25).reverse();\n            var _s25 = e.hoverPane.axis;\n            _t27 = A(_t27, _a15, _r9, _s25), (_i25 = A(_i25, _a15, _r9, _s25)) && (_i25[0][0] = \"L\"), _i25 = _toConsumableArray(_i25).reverse(), _d2.d = _t27.concat(_i25), _c = \"path\";\n          }\n        }\n        t.attrs = _d2, t.shapeType = _c;\n      }\n    }\n    function C() {\n      var t = this.chart;\n      t.polar && (this.polar = new E(this), t.inverted && (this.isRadialSeries = !0, this.is(\"column\") && (this.isRadialBar = !0)));\n    }\n    function k() {\n      if (this.chart.polar && this.xAxis) {\n        var _t28 = this.xAxis,\n          _i26 = this.yAxis,\n          _s26 = this.chart;\n        this.kdByAngle = _s26.tooltip && _s26.tooltip.shared, this.kdByAngle || _s26.inverted ? this.searchPoint = v : this.options.findNearestPointBy = \"xy\";\n        var _o19 = this.points,\n          _a16 = _o19.length;\n        for (; _a16--;) this.is(\"column\") || this.is(\"columnrange\") || this.polar.toXY(_o19[_a16]), _s26.hasParallelCoordinates || this.yAxis.reversed || (u(_o19[_a16].y, Number.MIN_VALUE) < _i26.min || _o19[_a16].x < _t28.min || _o19[_a16].x > _t28.max ? (_o19[_a16].isNull = !0, _o19[_a16].plotY = NaN) : _o19[_a16].isNull = _o19[_a16].isValid && !_o19[_a16].isValid());\n        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(l(this, \"afterRender\", function () {\n          var t;\n          _s26.polar && !1 !== this.options.clip && (t = this.yAxis.pane.center, this.clipCircle ? this.clipCircle.animate({\n            x: t[0],\n            y: t[1],\n            r: t[2] / 2,\n            innerR: t[3] / 2\n          }) : this.clipCircle = function (t, e, i, s, o) {\n            var a = m(),\n              r = t.createElement(\"clipPath\").attr({\n                id: a\n              }).add(t.defs),\n              n = o ? t.arc(e, i, s, o, 0, 2 * Math.PI).add(r) : t.circle(e, i, s).add(r);\n            return n.id = a, n.clipPath = r, n;\n          }(_s26.renderer, t[0], t[1], t[2] / 2, t[3] / 2), this.group.clip(this.clipCircle), this.setClip = e.noop);\n        })));\n      }\n    }\n    function v(t) {\n      var e = this.chart,\n        i = this.xAxis,\n        s = this.yAxis,\n        o = i.pane && i.pane.center,\n        a = t.chartX - (o && o[0] || 0) - e.plotLeft,\n        r = t.chartY - (o && o[1] || 0) - e.plotTop,\n        n = e.inverted ? {\n          clientX: t.chartX - s.pos,\n          plotY: t.chartY - i.pos\n        } : {\n          clientX: 180 + -180 / Math.PI * Math.atan2(a, r)\n        };\n      return this.searchKDTree(n);\n    }\n    function A(t, e, i, s) {\n      var o = s.tickInterval,\n        a = s.tickPositions,\n        r = p(a, function (t) {\n          return t >= i;\n        }),\n        n = p(_toConsumableArray(a).reverse(), function (t) {\n          return t <= e;\n        });\n      return h(r) || (r = a[a.length - 1]), h(n) || (n = a[0], r += o, t[0][0] = \"L\", t.unshift(t[t.length - 3])), (t = t.slice(a.indexOf(n), a.indexOf(r) + 1))[0][0] = \"M\", t;\n    }\n    function w(t, e) {\n      return p(this.pane || [], function (t) {\n        return t.options.id === e;\n      }) || t.call(this, e);\n    }\n    function T(t, e, s, o, a, r) {\n      var n, l, h;\n      var p = this.chart,\n        d = u(o.inside, !!this.options.stacking);\n      if (p.polar) {\n        if (n = e.rectPlotX / Math.PI * 180, p.inverted) this.forceDL = p.isInsidePlot(e.plotX, e.plotY), d && e.shapeArgs ? (l = e.shapeArgs, a = c(a, {\n          x: (h = this.yAxis.postTranslate(((l.start || 0) + (l.end || 0)) / 2 - this.xAxis.startAngleRad, e.barX + e.pointWidth / 2)).x - p.plotLeft,\n          y: h.y - p.plotTop\n        })) : e.tooltipPos && (a = c(a, {\n          x: e.tooltipPos[0],\n          y: e.tooltipPos[1]\n        })), o.align = u(o.align, \"center\"), o.verticalAlign = u(o.verticalAlign, \"middle\");else {\n          var g;\n          var _t29, _e29;\n          null === (g = o).align && (_t29 = n > 20 && n < 160 ? \"left\" : n > 200 && n < 340 ? \"right\" : \"center\", g.align = _t29), null === g.verticalAlign && (_e29 = n < 45 || n > 315 ? \"bottom\" : n > 135 && n < 225 ? \"top\" : \"middle\", g.verticalAlign = _e29), o = g;\n        }\n        i.prototype.alignDataLabel.call(this, e, s, o, a, r), this.isRadialBar && e.shapeArgs && e.shapeArgs.start === e.shapeArgs.end ? s.hide() : s.show();\n      } else t.call(this, e, s, o, a, r);\n    }\n    function N() {\n      var t = this.options,\n        e = t.stacking,\n        i = this.chart,\n        s = this.xAxis,\n        o = this.yAxis,\n        r = o.reversed,\n        n = o.center,\n        l = s.startAngleRad,\n        p = s.endAngleRad - l,\n        c = t.threshold,\n        u = 0,\n        g,\n        b,\n        m,\n        y,\n        x,\n        P = 0,\n        S = 0,\n        M,\n        L,\n        C,\n        k,\n        v,\n        A,\n        w,\n        T;\n      if (s.isRadial) for (m = (g = this.points).length, y = o.translate(o.min), x = o.translate(o.max), c = t.threshold || 0, i.inverted && d(c) && h(u = o.translate(c)) && (u < 0 ? u = 0 : u > p && (u = p), this.translatedThreshold = u + l); m--;) {\n        if (A = (b = g[m]).barX, L = b.x, C = b.y, b.shapeType = \"arc\", i.inverted) {\n          b.plotY = o.translate(C), e && o.stacking ? (v = o.stacking.stacks[(C < 0 ? \"-\" : \"\") + this.stackKey], this.visible && v && v[L] && !b.isNull && (k = v[L].points[this.getStackIndicator(void 0, L, this.index).key], P = o.translate(k[0]), S = o.translate(k[1]), h(P) && (P = a.clamp(P, 0, p)))) : (P = u, S = b.plotY), P > S && (S = [P, P = S][0]), r ? S > y ? S = y : P < x ? P = x : (P > y || S < x) && (P = S = p) : P < y ? P = y : S > x ? S = x : (S < y || P > x) && (P = S = 0), o.min > o.max && (P = S = r ? p : 0), P += l, S += l, n && (b.barX = A += n[3] / 2), w = Math.max(A, 0), T = Math.max(A + b.pointWidth, 0);\n          var _i27 = t.borderRadius,\n            _s27 = f((\"object\" == _typeof(_i27) ? _i27.radius : _i27) || 0, T - w);\n          b.shapeArgs = {\n            x: n[0],\n            y: n[1],\n            r: T,\n            innerR: w,\n            start: P,\n            end: S,\n            borderRadius: _s27\n          }, b.opacity = P === S ? 0 : void 0, b.plotY = (h(this.translatedThreshold) && (P < this.translatedThreshold ? P : S)) - l;\n        } else P = A + l, b.shapeArgs = this.polar.arc(b.yBottom, b.plotY, P, P + b.pointWidth), b.shapeArgs.borderRadius = 0;\n        this.polar.toXY(b), i.inverted ? (M = o.postTranslate(b.rectPlotY, A + b.pointWidth / 2), b.tooltipPos = [M.x - i.plotLeft, M.y - i.plotTop]) : b.tooltipPos = [b.plotX, b.plotY], n && (b.ttBelow = b.plotY > n[1]);\n      }\n    }\n    function X(t, e) {\n      var i, s;\n      var o = this;\n      if (this.chart.polar) {\n        e = e || this.points;\n        for (var _t30 = 0; _t30 < e.length; _t30++) if (!e[_t30].isNull) {\n          i = _t30;\n          break;\n        }\n        !1 !== this.options.connectEnds && void 0 !== i && (this.connectEnds = !0, e.splice(e.length, 0, e[i]), s = !0), e.forEach(function (t) {\n          void 0 === t.polarPlotY && o.polar.toXY(t);\n        });\n      }\n      var a = t.apply(this, [].slice.call(arguments, 1));\n      return s && e.pop(), a;\n    }\n    function R(t, e) {\n      var i = this.chart,\n        s = {\n          xAxis: [],\n          yAxis: []\n        };\n      return i.polar ? i.axes.forEach(function (t) {\n        if (\"colorAxis\" === t.coll) return;\n        var o = t.isXAxis,\n          a = t.center,\n          r = e.chartX - a[0] - i.plotLeft,\n          n = e.chartY - a[1] - i.plotTop;\n        s[o ? \"xAxis\" : \"yAxis\"].push({\n          axis: t,\n          value: t.translate(o ? Math.PI - Math.atan2(r, n) : Math.sqrt(Math.pow(r, 2) + Math.pow(n, 2)), !0)\n        });\n      }) : s = t.call(this, e), s;\n    }\n    function Y(t, e) {\n      this.chart.polar || t.call(this, e);\n    }\n    function j(t, i) {\n      var s = this,\n        o = this.chart,\n        a = this.group,\n        n = this.markerGroup,\n        l = this.xAxis && this.xAxis.center,\n        h = o.plotLeft,\n        p = o.plotTop,\n        d = this.options.animation,\n        c,\n        g,\n        f,\n        b,\n        m,\n        y;\n      o.polar ? s.isRadialBar ? i || (s.startAngleRad = u(s.translatedThreshold, s.xAxis.startAngleRad), e.seriesTypes.pie.prototype.animate.call(s, i)) : (d = r(d), s.is(\"column\") ? i || (g = l[3] / 2, s.points.forEach(function (t) {\n        f = t.graphic, m = (b = t.shapeArgs) && b.r, y = b && b.innerR, f && b && (f.attr({\n          r: g,\n          innerR: g\n        }), f.animate({\n          r: m,\n          innerR: y\n        }, s.options.animation));\n      })) : i ? (c = {\n        translateX: l[0] + h,\n        translateY: l[1] + p,\n        scaleX: .001,\n        scaleY: .001\n      }, a.attr(c), n && n.attr(c)) : (c = {\n        translateX: h,\n        translateY: p,\n        scaleX: 1,\n        scaleY: 1\n      }, a.animate(c, d), n && n.animate(c, d))) : t.call(this, i);\n    }\n    function I(t, e, i, s) {\n      var o, a;\n      if (this.chart.polar) {\n        if (s) {\n          var _t31 = (a = function t(e, i, s, o) {\n              var a, r, n, l, h, p;\n              var d = o ? 1 : 0,\n                c = (a = i >= 0 && i <= e.length - 1 ? i : i < 0 ? e.length - 1 + i : 0) - 1 < 0 ? e.length - (1 + d) : a - 1,\n                u = a + 1 > e.length - 1 ? d : a + 1,\n                g = e[c],\n                f = e[u],\n                b = g.plotX,\n                m = g.plotY,\n                y = f.plotX,\n                x = f.plotY,\n                P = e[a].plotX,\n                S = e[a].plotY;\n              r = (1.5 * P + b) / 2.5, n = (1.5 * S + m) / 2.5, l = (1.5 * P + y) / 2.5, h = (1.5 * S + x) / 2.5;\n              var M = Math.sqrt(Math.pow(r - P, 2) + Math.pow(n - S, 2)),\n                L = Math.sqrt(Math.pow(l - P, 2) + Math.pow(h - S, 2)),\n                C = Math.atan2(n - S, r - P);\n              p = Math.PI / 2 + (C + Math.atan2(h - S, l - P)) / 2, Math.abs(C - p) > Math.PI / 2 && (p -= Math.PI), r = P + Math.cos(p) * M, n = S + Math.sin(p) * M;\n              var k = {\n                rightContX: l = P + Math.cos(Math.PI + p) * L,\n                rightContY: h = S + Math.sin(Math.PI + p) * L,\n                leftContX: r,\n                leftContY: n,\n                plotX: P,\n                plotY: S\n              };\n              return s && (k.prevPointCont = t(e, c, !1, o)), k;\n            }(e, s, !0, this.connectEnds)).prevPointCont && a.prevPointCont.rightContX,\n            _i28 = a.prevPointCont && a.prevPointCont.rightContY;\n          o = [\"C\", d(_t31) ? _t31 : a.plotX, d(_i28) ? _i28 : a.plotY, d(a.leftContX) ? a.leftContX : a.plotX, d(a.leftContY) ? a.leftContY : a.plotY, a.plotX, a.plotY];\n        } else o = [\"M\", i.plotX, i.plotY];\n      } else o = t.call(this, e, i, s);\n      return o;\n    }\n    function D(t, e) {\n      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.plotY;\n      if (!this.destroyed) {\n        var _s28 = this.plotX,\n          _o20 = this.series,\n          _a17 = _o20.chart;\n        return _a17.polar && d(_s28) && d(i) ? [_s28 + (e ? _a17.plotLeft : 0), i + (e ? _a17.plotTop : 0)] : t.call(this, e, i);\n      }\n    }\n    var E = /*#__PURE__*/function () {\n      function E(t) {\n        _classCallCheck(this, E);\n        this.series = t;\n      }\n      return _createClass(E, [{\n        key: \"arc\",\n        value: function arc(t, e, i, s) {\n          var o = this.series,\n            a = o.xAxis.center,\n            r = o.yAxis.len,\n            n = a[3] / 2,\n            l = r - e + n,\n            h = r - u(t, r) + n;\n          return o.yAxis.reversed && (l < 0 && (l = n), h < 0 && (h = n)), {\n            x: a[0],\n            y: a[1],\n            r: l,\n            innerR: h,\n            start: i,\n            end: s\n          };\n        }\n      }, {\n        key: \"toXY\",\n        value: function toXY(t) {\n          var e = this.series,\n            i = e.chart,\n            s = e.xAxis,\n            o = e.yAxis,\n            a = t.plotX,\n            r = i.inverted,\n            n = t.y,\n            l = t.plotY,\n            h = r ? a : o.len - l,\n            p;\n          if (r && e && !e.isRadialBar && (t.plotY = l = d(n) ? o.translate(n) : 0), t.rectPlotX = a, t.rectPlotY = l, o.center && (h += o.center[3] / 2), d(l)) {\n            var _e30 = r ? o.postTranslate(l, h) : s.postTranslate(a, h);\n            t.plotX = t.polarPlotX = _e30.x - i.plotLeft, t.plotY = t.polarPlotY = _e30.y - i.plotTop;\n          }\n          e.kdByAngle ? ((p = (a / Math.PI * 180 + s.pane.options.startAngle) % 360) < 0 && (p += 360), t.clientX = p) : t.clientX = t.plotX;\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t, e, i, a, r, h, p, d, c, u) {\n          if (s.compose(e, i), o.compose(t, r), g(n, \"Polar\")) {\n            var _t32 = e.prototype,\n              _s29 = h.prototype,\n              _o21 = i.prototype,\n              _r10 = a.prototype;\n            if (l(e, \"afterDrawChartBox\", x), l(e, \"getAxes\", S), l(e, \"init\", P), y(_t32, \"get\", w), y(_o21, \"getCoordinates\", R), y(_o21, \"pinch\", Y), l(i, \"getSelectionMarkerAttrs\", L), l(i, \"getSelectionBox\", M), l(a, \"afterInit\", C), l(a, \"afterTranslate\", k, {\n              order: 2\n            }), l(a, \"afterColumnTranslate\", N, {\n              order: 4\n            }), y(_r10, \"animate\", j), y(_s29, \"pos\", D), d) {\n              var _t33 = d.prototype;\n              y(_t33, \"alignDataLabel\", T), y(_t33, \"animate\", j);\n            }\n            if (c && y(c.prototype, \"getGraphPath\", X), u) {\n              var _t34 = u.prototype;\n              y(_t34, \"getPointSpline\", I), p && (p.prototype.getPointSpline = _t34.getPointSpline);\n            }\n          }\n        }\n      }]);\n    }();\n    return E;\n  }), i(e, \"Core/Axis/WaterfallAxis.js\", [e[\"Core/Globals.js\"], e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    var o = t.composed,\n      a = i.addEvent,\n      r = i.objectEach,\n      n = i.pushUnique;\n    return function (t) {\n      function i() {\n        var t = this.waterfall.stacks;\n        t && (t.changed = !1, delete t.alreadyChanged);\n      }\n      function s() {\n        var t = this.options.stackLabels;\n        t && t.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();\n      }\n      function l() {\n        this.waterfall || (this.waterfall = new p(this));\n      }\n      function h() {\n        var t = this.axes;\n        var _iterator29 = _createForOfIteratorHelper(this.series),\n          _step29;\n        try {\n          for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n            var _e31 = _step29.value;\n            if (_e31.options.stacking) {\n              var _iterator30 = _createForOfIteratorHelper(t),\n                _step30;\n              try {\n                for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                  var _e32 = _step30.value;\n                  _e32.isXAxis || (_e32.waterfall.stacks.changed = !0);\n                }\n              } catch (err) {\n                _iterator30.e(err);\n              } finally {\n                _iterator30.f();\n              }\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator29.e(err);\n        } finally {\n          _iterator29.f();\n        }\n      }\n      t.compose = function (t, e) {\n        n(o, \"Axis.Waterfall\") && (a(t, \"init\", l), a(t, \"afterBuildStacks\", i), a(t, \"afterRender\", s), a(e, \"beforeRedraw\", h));\n      };\n      var p = /*#__PURE__*/function () {\n        function p(t) {\n          _classCallCheck(this, p);\n          this.axis = t, this.stacks = {\n            changed: !1\n          };\n        }\n        return _createClass(p, [{\n          key: \"renderStackTotals\",\n          value: function renderStackTotals() {\n            var t = this.axis,\n              i = t.waterfall.stacks,\n              s = t.stacking && t.stacking.stackTotalGroup,\n              o = new e(t, t.options.stackLabels || {}, !1, 0, void 0);\n            this.dummyStackItem = o, s && r(i, function (t) {\n              r(t, function (t, i) {\n                o.total = t.stackTotal, o.x = +i, t.label && (o.label = t.label), e.prototype.render.call(o, s), t.label = o.label, delete o.label;\n              });\n            }), o.total = null;\n          }\n        }]);\n      }();\n      t.Composition = p;\n    }(s || (s = {})), s;\n  }), i(e, \"Series/Waterfall/WaterfallPoint.js\", [e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = i.isNumber;\n    var o = /*#__PURE__*/function (_t$prototype$pointCla) {\n      function o() {\n        _classCallCheck(this, o);\n        return _callSuper(this, o, arguments);\n      }\n      _inherits(o, _t$prototype$pointCla);\n      return _createClass(o, [{\n        key: \"getClassName\",\n        value: function getClassName() {\n          var t = e.prototype.getClassName.call(this);\n          return this.isSum ? t += \" highcharts-sum\" : this.isIntermediateSum && (t += \" highcharts-intermediate-sum\"), t;\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return s(this.y) || this.isSum || !!this.isIntermediateSum;\n        }\n      }]);\n    }(t.prototype.pointClass);\n    return o;\n  }), i(e, \"Series/Waterfall/WaterfallSeriesDefaults.js\", [], function () {\n    return {\n      dataLabels: {\n        inside: !0\n      },\n      lineWidth: 1,\n      lineColor: \"#333333\",\n      dashStyle: \"Dot\",\n      borderColor: \"#333333\",\n      states: {\n        hover: {\n          lineWidthPlus: 0\n        }\n      }\n    };\n  }), i(e, \"Series/Waterfall/WaterfallSeries.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"], e[\"Core/Axis/WaterfallAxis.js\"], e[\"Series/Waterfall/WaterfallPoint.js\"], e[\"Series/Waterfall/WaterfallSeriesDefaults.js\"]], function (t, e, i, s, o) {\n    var _t$seriesTypes2 = t.seriesTypes,\n      a = _t$seriesTypes2.column,\n      r = _t$seriesTypes2.line,\n      n = e.addEvent,\n      l = e.arrayMax,\n      h = e.arrayMin,\n      p = e.correctFloat,\n      d = e.crisp,\n      c = e.extend,\n      u = e.isNumber,\n      g = e.merge,\n      f = e.objectEach,\n      b = e.pick;\n    function m(t, e) {\n      return Object.hasOwnProperty.call(t, e);\n    }\n    var y = /*#__PURE__*/function (_a18) {\n      function y() {\n        _classCallCheck(this, y);\n        return _callSuper(this, y, arguments);\n      }\n      _inherits(y, _a18);\n      return _createClass(y, [{\n        key: \"generatePoints\",\n        value: function generatePoints() {\n          a.prototype.generatePoints.apply(this);\n          for (var _t35 = 0, _e33 = this.points.length; _t35 < _e33; _t35++) {\n            var _e34 = this.points[_t35],\n              _i29 = this.processedYData[_t35];\n            u(_i29) && (_e34.isIntermediateSum || _e34.isSum) && (_e34.y = p(_i29));\n          }\n        }\n      }, {\n        key: \"processData\",\n        value: function processData(t) {\n          var e, i, s, o, a, r;\n          var n = this.options,\n            l = this.yData,\n            h = n.data,\n            d = l.length,\n            c = n.threshold || 0;\n          s = i = o = a = 0;\n          for (var _t36 = 0; _t36 < d; _t36++) r = l[_t36], e = h && h[_t36] ? h[_t36] : {}, \"sum\" === r || e.isSum ? l[_t36] = p(s) : \"intermediateSum\" === r || e.isIntermediateSum ? (l[_t36] = p(i), i = 0) : (s += r, i += r), o = Math.min(s, o), a = Math.max(s, a);\n          _superPropGet(y, \"processData\", this, 1).call(this, t), n.stacking || (this.dataMin = o + c, this.dataMax = a);\n        }\n      }, {\n        key: \"toYData\",\n        value: function toYData(t) {\n          return t.isSum ? \"sum\" : t.isIntermediateSum ? \"intermediateSum\" : t.y;\n        }\n      }, {\n        key: \"updateParallelArrays\",\n        value: function updateParallelArrays(t, e) {\n          _superPropGet(y, \"updateParallelArrays\", this, 1).call(this, t, e), (\"sum\" === this.yData[0] || \"intermediateSum\" === this.yData[0]) && (this.yData[0] = null);\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(t, e) {\n          var i = this.options.upColor;\n          i && !t.options.color && u(t.y) && (t.color = t.y > 0 ? i : void 0);\n          var s = a.prototype.pointAttribs.call(this, t, e);\n          return delete s.dashstyle, s;\n        }\n      }, {\n        key: \"getGraphPath\",\n        value: function getGraphPath() {\n          return [[\"M\", 0, 0]];\n        }\n      }, {\n        key: \"getCrispPath\",\n        value: function getCrispPath() {\n          var _this$graph;\n          var t = this.data.filter(function (t) {\n              return u(t.y);\n            }),\n            e = this.yAxis,\n            i = t.length,\n            s = ((_this$graph = this.graph) === null || _this$graph === void 0 ? void 0 : _this$graph.strokeWidth()) || 0,\n            o = this.xAxis.reversed,\n            a = this.yAxis.reversed,\n            r = this.options.stacking,\n            n = [];\n          for (var _l4 = 1; _l4 < i; _l4++) {\n            if (!(this.options.connectNulls || u(this.data[t[_l4].index - 1].y))) continue;\n            var _i30 = t[_l4].box,\n              _h4 = t[_l4 - 1],\n              _p9 = _h4.y || 0,\n              _c2 = t[_l4 - 1].box;\n            if (!_i30 || !_c2) continue;\n            var _g4 = e.waterfall.stacks[this.stackKey],\n              _f5 = _p9 > 0 ? -_c2.height : 0;\n            if (_g4 && _c2 && _i30) {\n              var _t37 = void 0;\n              var _p10 = _g4[_l4 - 1];\n              if (r) {\n                var _i31 = _p10.connectorThreshold;\n                _t37 = d(e.translate(_i31, !1, !0, !1, !0) + (a ? _f5 : 0), s);\n              } else _t37 = d(_c2.y + (_h4.minPointLengthOffset || 0), s);\n              n.push([\"M\", (_c2.x || 0) + (o ? 0 : _c2.width || 0), _t37], [\"L\", (_i30.x || 0) + (o && _i30.width || 0), _t37]);\n            }\n            if (_c2 && n.length && (!r && _p9 < 0 && !a || _p9 > 0 && a)) {\n              var _t38 = n[n.length - 2];\n              _t38 && \"number\" == typeof _t38[2] && (_t38[2] += _c2.height || 0);\n              var _e35 = n[n.length - 1];\n              _e35 && \"number\" == typeof _e35[2] && (_e35[2] += _c2.height || 0);\n            }\n          }\n          return n;\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          r.prototype.drawGraph.call(this), this.graph && this.graph.attr({\n            d: this.getCrispPath()\n          });\n        }\n      }, {\n        key: \"setStackedPoints\",\n        value: function setStackedPoints(t) {\n          var _t$waterfall;\n          var e = this.options,\n            i = (_t$waterfall = t.waterfall) === null || _t$waterfall === void 0 ? void 0 : _t$waterfall.stacks,\n            s = e.threshold || 0,\n            o = this.stackKey,\n            a = this.xData,\n            r = a.length,\n            n = s,\n            l = n,\n            h,\n            p = 0,\n            d = 0,\n            c = 0,\n            u,\n            g,\n            f,\n            b,\n            m,\n            _y,\n            x,\n            P,\n            S = function S(t, e, i, s) {\n              if (h) {\n                if (u) for (; i < u; i++) h.stackState[i] += s;else h.stackState[0] = t, u = h.stackState.length;\n                h.stackState.push(h.stackState[u - 1] + e);\n              }\n            };\n          if (t.stacking && i && this.reserveSpace()) {\n            P = i.changed, (x = i.alreadyChanged) && 0 > x.indexOf(o) && (P = !0), i[o] || (i[o] = {});\n            var _t39 = i[o];\n            if (_t39) for (var _i32 = 0; _i32 < r; _i32++) (!_t39[_y = a[_i32]] || P) && (_t39[_y] = {\n              negTotal: 0,\n              posTotal: 0,\n              stackTotal: 0,\n              threshold: 0,\n              stateIndex: 0,\n              stackState: [],\n              label: P && _t39[_y] ? _t39[_y].label : void 0\n            }), h = _t39[_y], (m = this.yData[_i32]) >= 0 ? h.posTotal += m : h.negTotal += m, b = e.data[_i32], g = h.absolutePos = h.posTotal, f = h.absoluteNeg = h.negTotal, h.stackTotal = g + f, u = h.stackState.length, b && b.isIntermediateSum ? (S(c, d, 0, c), c = d, d = s, n ^= l, l ^= n, n ^= l) : b && b.isSum ? (S(s, p, u, 0), n = s) : (S(n, m, 0, p), b && (p += m, d += m)), h.stateIndex++, h.threshold = n, n += h.stackTotal;\n            i.changed = !1, i.alreadyChanged || (i.alreadyChanged = []), i.alreadyChanged.push(o);\n          }\n        }\n      }, {\n        key: \"getExtremes\",\n        value: function getExtremes() {\n          var t, e, i;\n          var s = this.options.stacking;\n          return s ? (t = this.yAxis.waterfall.stacks, e = this.stackedYNeg = [], i = this.stackedYPos = [], \"overlap\" === s ? f(t[this.stackKey], function (t) {\n            e.push(h(t.stackState)), i.push(l(t.stackState));\n          }) : f(t[this.stackKey], function (t) {\n            e.push(t.negTotal + t.threshold), i.push(t.posTotal + t.threshold);\n          }), {\n            dataMin: h(e),\n            dataMax: l(i)\n          }) : {\n            dataMin: this.dataMin,\n            dataMax: this.dataMax\n          };\n        }\n      }]);\n    }(a);\n    return y.defaultOptions = g(a.defaultOptions, o), y.compose = i.compose, c(y.prototype, {\n      pointValKey: \"y\",\n      showLine: !0,\n      pointClass: s\n    }), n(y, \"afterColumnTranslate\", function () {\n      var t = this.options,\n        e = this.points,\n        i = this.yAxis,\n        s = b(t.minPointLength, 5),\n        o = s / 2,\n        a = t.threshold || 0,\n        r = t.stacking,\n        n = i.waterfall.stacks[this.stackKey],\n        l = a,\n        h = a,\n        p,\n        f,\n        y,\n        x;\n      for (var _t40 = 0; _t40 < e.length; _t40++) {\n        var _b2 = e[_t40],\n          P = this.processedYData[_t40],\n          S = c({\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          }, _b2.shapeArgs || {});\n        _b2.box = S;\n        var M = [0, P],\n          L = _b2.y || 0;\n        if (r) {\n          if (n) {\n            var _e36 = n[_t40];\n            \"overlap\" === r ? (f = _e36.stackState[_e36.stateIndex--], p = L >= 0 ? f : f - L, m(_e36, \"absolutePos\") && delete _e36.absolutePos, m(_e36, \"absoluteNeg\") && delete _e36.absoluteNeg) : (L >= 0 ? (f = _e36.threshold + _e36.posTotal, _e36.posTotal -= L, p = f) : (f = _e36.threshold + _e36.negTotal, _e36.negTotal -= L, p = f - L), !_e36.posTotal && u(_e36.absolutePos) && m(_e36, \"absolutePos\") && (_e36.posTotal = _e36.absolutePos, delete _e36.absolutePos), !_e36.negTotal && u(_e36.absoluteNeg) && m(_e36, \"absoluteNeg\") && (_e36.negTotal = _e36.absoluteNeg, delete _e36.absoluteNeg)), _b2.isSum || (_e36.connectorThreshold = _e36.threshold + _e36.stackTotal), i.reversed ? (y = L >= 0 ? p - L : p + L, x = p) : (y = p, x = p - L), _b2.below = y <= a, S.y = i.translate(y, !1, !0, !1, !0), S.height = Math.abs(S.y - i.translate(x, !1, !0, !1, !0));\n            var _s30 = i.waterfall.dummyStackItem;\n            _s30 && (_s30.x = _t40, _s30.label = n[_t40].label, _s30.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[_t40], this.stackedYPos[_t40], void 0, this.xAxis));\n          }\n        } else p = Math.max(h, h + L) + M[0], S.y = i.translate(p, !1, !0, !1, !0), _b2.isSum ? (S.y = i.translate(M[1], !1, !0, !1, !0), S.height = Math.min(i.translate(M[0], !1, !0, !1, !0), i.len) - S.y, _b2.below = M[1] <= a) : _b2.isIntermediateSum ? (L >= 0 ? (y = M[1] + l, x = l) : (y = l, x = M[1] + l), i.reversed && (y ^= x, x ^= y, y ^= x), S.y = i.translate(y, !1, !0, !1, !0), S.height = Math.abs(S.y - Math.min(i.translate(x, !1, !0, !1, !0), i.len)), l += M[1], _b2.below = y <= a) : (S.height = P > 0 ? i.translate(h, !1, !0, !1, !0) - S.y : i.translate(h, !1, !0, !1, !0) - i.translate(h - P, !1, !0, !1, !0), h += P, _b2.below = h < a), S.height < 0 && (S.y += S.height, S.height *= -1);\n        _b2.plotY = S.y, _b2.yBottom = S.y + S.height, S.height <= s && !_b2.isNull ? (S.height = s, S.y -= o, _b2.yBottom = S.y + S.height, _b2.plotY = S.y, L < 0 ? _b2.minPointLengthOffset = -o : _b2.minPointLengthOffset = o) : (_b2.isNull && (S.width = 0), _b2.minPointLengthOffset = 0);\n        var C = _b2.plotY + (_b2.negative ? S.height : 0);\n        _b2.below && (_b2.plotY += S.height), _b2.tooltipPos && (this.chart.inverted ? _b2.tooltipPos[0] = i.len - C : _b2.tooltipPos[1] = C), _b2.isInside = this.isPointInside(_b2);\n        var k = d(_b2.yBottom, this.borderWidth);\n        S.y = d(S.y, this.borderWidth), S.height = k - S.y, g(!0, _b2.shapeArgs, S);\n      }\n    }, {\n      order: 2\n    }), t.registerSeriesType(\"waterfall\", y), y;\n  }), i(e, \"masters/highcharts-more.src.js\", [e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Extensions/Pane/Pane.js\"], e[\"Series/Bubble/BubbleSeries.js\"], e[\"Series/PackedBubble/PackedBubbleSeries.js\"], e[\"Series/PolarComposition.js\"], e[\"Core/Axis/RadialAxis.js\"], e[\"Series/Waterfall/WaterfallSeries.js\"]], function (t, e, i, s, o, a, r, n) {\n    return t.RadialAxis = r, s.compose(t.Axis, t.Chart, t.Legend), o.compose(t.Axis, t.Chart, t.Legend), i.compose(t.Chart, t.Pointer), a.compose(t.Axis, t.Chart, t.Pointer, t.Series, t.Tick, t.Point, e.seriesTypes.areasplinerange, e.seriesTypes.column, e.seriesTypes.line, e.seriesTypes.spline), n.compose(t.Axis, t.Chart), t;\n  });\n});\n\n//# sourceURL=webpack://medaxion-custom-visualizations/./node_modules/highcharts/highcharts-more.js?");

/***/ }),

/***/ "./node_modules/highcharts/highcharts.js":
/*!***********************************************!*\
  !*** ./node_modules/highcharts/highcharts.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n20 = 0, F = function F() {}; return { s: F, n: function n() { return _n20 >= r.length ? { done: !0 } : { done: !1, value: r[_n20++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n!\n/**\n* Highcharts JS v11.4.7 (2024-08-14)\n*\n* (c) 2009-2024 Torstein Honsi\n*\n* License: www.highcharts.com/license\n*/\nfunction (t, e) {\n  \"object\" == ( false ? 0 : _typeof(module)) && module.exports ? (e[\"default\"] = e, module.exports = t && t.document ? e(t) : e) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return e(t);\n  }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n}(\"undefined\" != typeof window ? window : this, function (t) {\n  \"use strict\";\n\n  var e = {};\n  function i(e, i, s, r) {\n    !e.hasOwnProperty(i) && (e[i] = r.apply(null, s), t && \"function\" == typeof CustomEvent && t.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: i,\n        module: e[i]\n      }\n    })));\n  }\n  return i(e, \"Core/Globals.js\", [], function () {\n    var e, i;\n    return (i = e || (e = {})).SVG_NS = \"http://www.w3.org/2000/svg\", i.product = \"Highcharts\", i.version = \"11.4.7\", i.win = void 0 !== t ? t : {}, i.doc = i.win.document, i.svg = i.doc && i.doc.createElementNS && !!i.doc.createElementNS(i.SVG_NS, \"svg\").createSVGRect, i.userAgent = i.win.navigator && i.win.navigator.userAgent || \"\", i.isChrome = i.win.chrome, i.isFirefox = -1 !== i.userAgent.indexOf(\"Firefox\"), i.isMS = /(edge|msie|trident)/i.test(i.userAgent) && !i.win.opera, i.isSafari = !i.isChrome && -1 !== i.userAgent.indexOf(\"Safari\"), i.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(i.userAgent), i.isWebKit = -1 !== i.userAgent.indexOf(\"AppleWebKit\"), i.deg2rad = 2 * Math.PI / 360, i.hasBidiBug = i.isFirefox && 4 > parseInt(i.userAgent.split(\"Firefox/\")[1], 10), i.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"], i.noop = function () {}, i.supportsPassiveEvents = function () {\n      var t = !1;\n      if (!i.isMS) {\n        var _e = Object.defineProperty({}, \"passive\", {\n          get: function get() {\n            t = !0;\n          }\n        });\n        i.win.addEventListener && i.win.removeEventListener && (i.win.addEventListener(\"testPassive\", i.noop, _e), i.win.removeEventListener(\"testPassive\", i.noop, _e));\n      }\n      return t;\n    }(), i.charts = [], i.composed = [], i.dateFormats = {}, i.seriesTypes = {}, i.symbolSizes = {}, i.chartCount = 0, e;\n  }), i(e, \"Core/Utilities.js\", [e[\"Core/Globals.js\"]], function (t) {\n    var e;\n    var i = t.charts,\n      s = t.doc,\n      r = t.win;\n    function o(e, i, s, n) {\n      var a = i ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === e && (e = \"\".concat(a, \": Deprecated member\"));\n      var h = p(e),\n        l = h ? \"\".concat(a, \" #\").concat(e, \": www.highcharts.com/errors/\").concat(e, \"/\") : e.toString();\n      if (void 0 !== n) {\n        var _t = \"\";\n        h && (l += \"?\"), C(n, function (e, i) {\n          _t += \"\\n - \".concat(i, \": \").concat(e), h && (l += encodeURI(i) + \"=\" + encodeURI(e));\n        }), l += _t;\n      }\n      M(t, \"displayError\", {\n        chart: s,\n        code: e,\n        message: l,\n        params: n\n      }, function () {\n        if (i) throw Error(l);\n        r.console && -1 === o.messages.indexOf(l) && console.warn(l);\n      }), o.messages.push(l);\n    }\n    function n(t, e) {\n      return parseInt(t, e || 10);\n    }\n    function a(t) {\n      return \"string\" == typeof t;\n    }\n    function h(t) {\n      var e = Object.prototype.toString.call(t);\n      return \"[object Array]\" === e || \"[object Array Iterator]\" === e;\n    }\n    function l(t, e) {\n      return !!t && \"object\" == _typeof(t) && (!e || !h(t));\n    }\n    function d(t) {\n      return l(t) && \"number\" == typeof t.nodeType;\n    }\n    function c(t) {\n      var e = t && t.constructor;\n      return !!(l(t, !0) && !d(t) && e && e.name && \"Object\" !== e.name);\n    }\n    function p(t) {\n      return \"number\" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;\n    }\n    function u(t) {\n      return null != t;\n    }\n    function g(t, e, i) {\n      var s;\n      var r = a(e) && !u(i),\n        o = function o(e, i) {\n          u(e) ? t.setAttribute(i, e) : r ? (s = t.getAttribute(i)) || \"class\" !== i || (s = t.getAttribute(i + \"Name\")) : t.removeAttribute(i);\n        };\n      return a(e) ? o(i, e) : C(e, o), s;\n    }\n    function f(t) {\n      return h(t) ? t : [t];\n    }\n    function m(t, e) {\n      var i;\n      for (i in t || (t = {}), e) t[i] = e[i];\n      return t;\n    }\n    function x() {\n      var t = arguments,\n        e = t.length;\n      for (var _i = 0; _i < e; _i++) {\n        var _e2 = t[_i];\n        if (null != _e2) return _e2;\n      }\n    }\n    function y(t, e) {\n      m(t.style, e);\n    }\n    function b(t) {\n      return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));\n    }\n    function v(t, e) {\n      return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));\n    }\n    (o || (o = {})).messages = [], Math.easeInOutSine = function (t) {\n      return -.5 * (Math.cos(Math.PI * t) - 1);\n    };\n    var S = Array.prototype.find ? function (t, e) {\n      return t.find(e);\n    } : function (t, e) {\n      var i;\n      var s = t.length;\n      for (i = 0; i < s; i++) if (e(t[i], i)) return t[i];\n    };\n    function C(t, e, i) {\n      for (var _s in t) Object.hasOwnProperty.call(t, _s) && e.call(i || t[_s], t[_s], _s, t);\n    }\n    function k(t, e, i) {\n      function s(e, i) {\n        var s = t.removeEventListener;\n        s && s.call(t, e, i, !1);\n      }\n      function r(i) {\n        var r, o;\n        t.nodeName && (e ? (r = {})[e] = !0 : r = i, C(r, function (t, e) {\n          if (i[e]) for (o = i[e].length; o--;) s(e, i[e][o].fn);\n        }));\n      }\n      var o = \"function\" == typeof t && t.prototype || t;\n      if (Object.hasOwnProperty.call(o, \"hcEvents\")) {\n        var _t2 = o.hcEvents;\n        if (e) {\n          var _o = _t2[e] || [];\n          i ? (_t2[e] = _o.filter(function (t) {\n            return i !== t.fn;\n          }), s(e, i)) : (r(_t2), _t2[e] = []);\n        } else r(_t2), delete o.hcEvents;\n      }\n    }\n    function M(e, i, r, o) {\n      if (r = r || {}, s.createEvent && (e.dispatchEvent || e.fireEvent && e !== t)) {\n        var _t3 = s.createEvent(\"Events\");\n        _t3.initEvent(i, !0, !0), r = m(_t3, r), e.dispatchEvent ? e.dispatchEvent(r) : e.fireEvent(i, r);\n      } else if (e.hcEvents) {\n        r.target || m(r, {\n          preventDefault: function preventDefault() {\n            r.defaultPrevented = !0;\n          },\n          target: e,\n          type: i\n        });\n        var _t4 = [],\n          _s2 = e,\n          _o2 = !1;\n        for (; _s2.hcEvents;) Object.hasOwnProperty.call(_s2, \"hcEvents\") && _s2.hcEvents[i] && (_t4.length && (_o2 = !0), _t4.unshift.apply(_t4, _s2.hcEvents[i])), _s2 = Object.getPrototypeOf(_s2);\n        _o2 && _t4.sort(function (t, e) {\n          return t.order - e.order;\n        }), _t4.forEach(function (t) {\n          !1 === t.fn.call(e, r) && r.preventDefault();\n        });\n      }\n      o && !r.defaultPrevented && o.call(e, r);\n    }\n    C({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (e, i) {\n      t[i] = function (t) {\n        return o(32, !1, void 0, _defineProperty({}, \"Highcharts.\".concat(i), \"use Array.\".concat(e))), Array.prototype[e].apply(t, [].slice.call(arguments, 1));\n      };\n    });\n    var w = function () {\n      var t = Math.random().toString(36).substring(2, 9) + \"-\",\n        i = 0;\n      return function () {\n        return \"highcharts-\" + (e ? \"\" : t) + i++;\n      };\n    }();\n    return r.jQuery && (r.jQuery.fn.highcharts = function () {\n      var e = [].slice.call(arguments);\n      if (this[0]) return e[0] ? (new t[a(e[0]) ? e.shift() : \"Chart\"](this[0], e[0], e[1]), this) : i[g(this[0], \"data-highcharts-chart\")];\n    }), {\n      addEvent: function addEvent(e, i, s) {\n        var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        var o = \"function\" == typeof e && e.prototype || e;\n        Object.hasOwnProperty.call(o, \"hcEvents\") || (o.hcEvents = {});\n        var n = o.hcEvents;\n        t.Point && e instanceof t.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0);\n        var a = e.addEventListener;\n        a && a.call(e, i, s, !!t.supportsPassiveEvents && {\n          passive: void 0 === r.passive ? -1 !== i.indexOf(\"touch\") : r.passive,\n          capture: !1\n        }), n[i] || (n[i] = []);\n        var h = {\n          fn: s,\n          order: \"number\" == typeof r.order ? r.order : 1 / 0\n        };\n        return n[i].push(h), n[i].sort(function (t, e) {\n          return t.order - e.order;\n        }), function () {\n          k(e, i, s);\n        };\n      },\n      arrayMax: function arrayMax(t) {\n        var e = t.length,\n          i = t[0];\n        for (; e--;) t[e] > i && (i = t[e]);\n        return i;\n      },\n      arrayMin: function arrayMin(t) {\n        var e = t.length,\n          i = t[0];\n        for (; e--;) t[e] < i && (i = t[e]);\n        return i;\n      },\n      attr: g,\n      clamp: function clamp(t, e, i) {\n        return t > e ? t < i ? t : i : e;\n      },\n      clearTimeout: function (_clearTimeout) {\n        function clearTimeout(_x) {\n          return _clearTimeout.apply(this, arguments);\n        }\n        clearTimeout.toString = function () {\n          return _clearTimeout.toString();\n        };\n        return clearTimeout;\n      }(function (t) {\n        u(t) && clearTimeout(t);\n      }),\n      correctFloat: v,\n      createElement: function createElement(t, e, i, r, o) {\n        var n = s.createElement(t);\n        return e && m(n, e), o && y(n, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        }), i && y(n, i), r && r.appendChild(n), n;\n      },\n      crisp: function crisp(t) {\n        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var i = arguments.length > 2 ? arguments[2] : undefined;\n        var s = e % 2 / 2,\n          r = i ? -1 : 1;\n        return (Math.round(t * r - s) + s) * r;\n      },\n      css: y,\n      defined: u,\n      destroyObjectProperties: function destroyObjectProperties(t, e, i) {\n        C(t, function (s, r) {\n          s !== e && s !== null && s !== void 0 && s.destroy && s.destroy(), ((s === null || s === void 0 ? void 0 : s.destroy) || !i) && delete t[r];\n        });\n      },\n      diffObjects: function diffObjects(t, e, i, s) {\n        var r = {};\n        return function t(e, r, o, n) {\n          var a = i ? r : e;\n          C(e, function (i, d) {\n            if (!n && s && s.indexOf(d) > -1 && r[d]) {\n              i = f(i), o[d] = [];\n              for (var _e3 = 0; _e3 < Math.max(i.length, r[d].length); _e3++) r[d][_e3] && (void 0 === i[_e3] ? o[d][_e3] = r[d][_e3] : (o[d][_e3] = {}, t(i[_e3], r[d][_e3], o[d][_e3], n + 1)));\n            } else l(i, !0) && !i.nodeType ? (o[d] = h(i) ? [] : {}, t(i, r[d] || {}, o[d], n + 1), 0 !== Object.keys(o[d]).length || \"colorAxis\" === d && 0 === n || delete o[d]) : (e[d] !== r[d] || d in e && !(d in r)) && \"__proto__\" !== d && \"constructor\" !== d && (o[d] = a[d]);\n          });\n        }(t, e, r, 0), r;\n      },\n      discardElement: function discardElement(t) {\n        t && t.parentElement && t.parentElement.removeChild(t);\n      },\n      erase: function erase(t, e) {\n        var i = t.length;\n        for (; i--;) if (t[i] === e) {\n          t.splice(i, 1);\n          break;\n        }\n      },\n      error: o,\n      extend: m,\n      extendClass: function extendClass(t, e) {\n        var i = function i() {};\n        return i.prototype = new t(), m(i.prototype, e), i;\n      },\n      find: S,\n      fireEvent: M,\n      getClosestDistance: function getClosestDistance(t, e) {\n        var i, s, r, o;\n        var n = !e;\n        return t.forEach(function (t) {\n          if (t.length > 1) for (o = s = t.length - 1; o > 0; o--) {\n            var _e4;\n            (r = t[o] - t[o - 1]) < 0 && !n ? ((_e4 = e) !== null && _e4 !== void 0 && _e4(), e = void 0) : r && (void 0 === i || r < i) && (i = r);\n          }\n        }), i;\n      },\n      getMagnitude: b,\n      getNestedProperty: function getNestedProperty(t, e) {\n        var i = t.split(\".\");\n        for (; i.length && u(e);) {\n          var _t5 = i.shift();\n          if (void 0 === _t5 || \"__proto__\" === _t5) return;\n          if (\"this\" === _t5) {\n            var _t7;\n            var _t6 = void 0;\n            return l(e) && (_t6 = e[\"@this\"]), (_t7 = _t6) !== null && _t7 !== void 0 ? _t7 : e;\n          }\n          var _s3 = e[_t5];\n          if (!u(_s3) || \"function\" == typeof _s3 || \"number\" == typeof _s3.nodeType || _s3 === r) return;\n          e = _s3;\n        }\n        return e;\n      },\n      getStyle: function t(e, i, s) {\n        var o;\n        if (\"width\" === i) {\n          var _i2 = Math.min(e.offsetWidth, e.scrollWidth),\n            _s4 = e.getBoundingClientRect && e.getBoundingClientRect().width;\n          return _s4 < _i2 && _s4 >= _i2 - 1 && (_i2 = Math.floor(_s4)), Math.max(0, _i2 - (t(e, \"padding-left\", !0) || 0) - (t(e, \"padding-right\", !0) || 0));\n        }\n        if (\"height\" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, \"padding-top\", !0) || 0) - (t(e, \"padding-bottom\", !0) || 0));\n        var a = r.getComputedStyle(e, void 0);\n        return a && (o = a.getPropertyValue(i), x(s, \"opacity\" !== i) && (o = n(o))), o;\n      },\n      inArray: function inArray(t, e, i) {\n        return o(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        }), e.indexOf(t, i);\n      },\n      insertItem: function insertItem(t, e) {\n        var i;\n        var s = t.options.index,\n          r = e.length;\n        for (i = t.options.isInternal ? r : 0; i < r + 1; i++) if (!e[i] || p(s) && s < x(e[i].options.index, e[i]._i) || e[i].options.isInternal) {\n          e.splice(i, 0, t);\n          break;\n        }\n        return i;\n      },\n      isArray: h,\n      isClass: c,\n      isDOMElement: d,\n      isFunction: function isFunction(t) {\n        return \"function\" == typeof t;\n      },\n      isNumber: p,\n      isObject: l,\n      isString: a,\n      keys: function keys(t) {\n        return o(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        }), Object.keys(t);\n      },\n      merge: function merge() {\n        var t,\n          e = arguments,\n          i = {},\n          _s5 = function s(t, e) {\n            return \"object\" != _typeof(t) && (t = {}), C(e, function (i, r) {\n              \"__proto__\" !== r && \"constructor\" !== r && (!l(i, !0) || c(i) || d(i) ? t[r] = e[r] : t[r] = _s5(t[r] || {}, i));\n            }), t;\n          };\n        !0 === e[0] && (i = e[1], e = Array.prototype.slice.call(e, 2));\n        var r = e.length;\n        for (t = 0; t < r; t++) i = _s5(i, e[t]);\n        return i;\n      },\n      normalizeTickInterval: function normalizeTickInterval(t, e, i, s, r) {\n        var o,\n          n = t;\n        i = x(i, b(t));\n        var a = t / i;\n        for (!e && (e = r ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === s && (1 === i ? e = e.filter(function (t) {\n          return t % 1 == 0;\n        }) : i <= .1 && (e = [1 / i]))), o = 0; o < e.length && (n = e[o], (!r || !(n * i >= t)) && (r || !(a <= (e[o] + (e[o + 1] || e[o])) / 2))); o++);\n        return v(n * i, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: C,\n      offset: function offset(t) {\n        var e = s.documentElement,\n          i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {\n            top: 0,\n            left: 0,\n            width: 0,\n            height: 0\n          };\n        return {\n          top: i.top + (r.pageYOffset || e.scrollTop) - (e.clientTop || 0),\n          left: i.left + (r.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),\n          width: i.width,\n          height: i.height\n        };\n      },\n      pad: function pad(t, e, i) {\n        return Array((e || 2) + 1 - String(t).replace(\"-\", \"\").length).join(i || \"0\") + t;\n      },\n      pick: x,\n      pInt: n,\n      pushUnique: function pushUnique(t, e) {\n        return 0 > t.indexOf(e) && !!t.push(e);\n      },\n      relativeLength: function relativeLength(t, e, i) {\n        return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);\n      },\n      removeEvent: k,\n      replaceNested: function replaceNested(t) {\n        var i, s;\n        for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          e[_key - 1] = arguments[_key];\n        }\n        do {\n          var _iterator = _createForOfIteratorHelper((i = t, e)),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              s = _step.value;\n              t = t.replace(s[0], s[1]);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } while (t !== i);\n        return t;\n      },\n      splat: f,\n      stableSort: function stableSort(t, e) {\n        var i, s;\n        var r = t.length;\n        for (s = 0; s < r; s++) t[s].safeI = s;\n        for (t.sort(function (t, s) {\n          return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;\n        }), s = 0; s < r; s++) delete t[s].safeI;\n      },\n      syncTimeout: function syncTimeout(t, e, i) {\n        return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1e3,\n        minute: 6e4,\n        hour: 36e5,\n        day: 864e5,\n        week: 6048e5,\n        month: 24192e5,\n        year: 314496e5\n      },\n      uniqueKey: w,\n      useSerialIds: function useSerialIds(t) {\n        return e = x(t, e);\n      },\n      wrap: function wrap(t, e, i) {\n        var s = t[e];\n        t[e] = function () {\n          var t = arguments,\n            e = this;\n          return i.apply(this, [function () {\n            return s.apply(e, arguments.length ? arguments : t);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n  }), i(e, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {},\n        position: {}\n      },\n      reflow: !0,\n      type: \"line\",\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#334eff\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  }), i(e, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: [\"#2caffe\", \"#544fc5\", \"#00e272\", \"#fe6a35\", \"#6b8abc\", \"#d568fb\", \"#2ee0ca\", \"#fa4b42\", \"#feb56a\", \"#91e8e1\"]\n    };\n  }), i(e, \"Core/Time.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.win,\n      s = e.defined,\n      r = e.error,\n      o = e.extend,\n      n = e.isNumber,\n      a = e.isObject,\n      h = e.merge,\n      l = e.objectEach,\n      d = e.pad,\n      c = e.pick,\n      p = e.splat,\n      u = e.timeUnits,\n      g = t.isSafari && i.Intl && i.Intl.DateTimeFormat.prototype.formatRange,\n      f = t.isSafari && i.Intl && !i.Intl.DateTimeFormat.prototype.formatRange;\n    var m = /*#__PURE__*/function () {\n      function m(t) {\n        _classCallCheck(this, m);\n        this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = i.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(t);\n      }\n      return _createClass(m, [{\n        key: \"get\",\n        value: function get(t, e) {\n          if (this.variableTimezone || this.timezoneOffset) {\n            var _i3 = e.getTime(),\n              _s6 = _i3 - this.getTimezoneOffset(e);\n            e.setTime(_s6);\n            var _r = e[\"getUTC\" + t]();\n            return e.setTime(_i3), _r;\n          }\n          return this.useUTC ? e[\"getUTC\" + t]() : e[\"get\" + t]();\n        }\n      }, {\n        key: \"set\",\n        value: function set(t, e, i) {\n          if (this.variableTimezone || this.timezoneOffset) {\n            if (\"Milliseconds\" === t || \"Seconds\" === t || \"Minutes\" === t && this.getTimezoneOffset(e) % 36e5 == 0) return e[\"setUTC\" + t](i);\n            var _s7 = this.getTimezoneOffset(e),\n              _r2 = e.getTime() - _s7;\n            e.setTime(_r2), e[\"setUTC\" + t](i);\n            var _o4 = this.getTimezoneOffset(e);\n            return _r2 = e.getTime() + _o4, e.setTime(_r2);\n          }\n          return this.useUTC || g && \"FullYear\" === t ? e[\"setUTC\" + t](i) : e[\"set\" + t](i);\n        }\n      }, {\n        key: \"update\",\n        value: function update() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var e = c(t.useUTC, !0);\n          this.options = t = h(!0, this.options, t), this.Date = t.Date || i.Date || Date, this.useUTC = e, this.timezoneOffset = e && t.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = e && !!(t.getTimezoneOffset || t.timezone);\n        }\n      }, {\n        key: \"makeTime\",\n        value: function makeTime(t, e, i, s, r, o) {\n          var n, a, h;\n          return this.useUTC ? (n = this.Date.UTC.apply(0, arguments), a = this.getTimezoneOffset(n), n += a, a !== (h = this.getTimezoneOffset(n)) ? n += h - a : a - 36e5 !== this.getTimezoneOffset(n - 36e5) || f || (n -= 36e5)) : n = new this.Date(t, e, c(i, 1), c(s, 0), c(r, 0), c(o, 0)).getTime(), n;\n        }\n      }, {\n        key: \"timezoneOffsetFunction\",\n        value: function timezoneOffsetFunction() {\n          var t = this,\n            e = this.options,\n            i = e.getTimezoneOffset;\n          return this.useUTC ? e.timezone ? function (t) {\n            try {\n              var _i4 = \"shortOffset,\".concat(e.timezone || \"\"),\n                _m$formatCache$i$form = (m.formatCache[_i4] = m.formatCache[_i4] || Intl.DateTimeFormat(\"en\", {\n                  timeZone: e.timezone,\n                  timeZoneName: \"shortOffset\"\n                })).format(t).split(/(GMT|:)/).map(Number),\n                _m$formatCache$i$form2 = _slicedToArray(_m$formatCache$i$form, 5),\n                _s8 = _m$formatCache$i$form2[0],\n                _r3 = _m$formatCache$i$form2[1],\n                _o5 = _m$formatCache$i$form2[2],\n                _a = _m$formatCache$i$form2[3],\n                _m$formatCache$i$form3 = _m$formatCache$i$form2[4],\n                _h = _m$formatCache$i$form3 === void 0 ? 0 : _m$formatCache$i$form3,\n                _l = -(36e5 * (_o5 + _h / 60));\n              if (n(_l)) return _l;\n            } catch (t) {\n              r(34);\n            }\n            return 0;\n          } : this.useUTC && i ? function (t) {\n            return 6e4 * i(t.valueOf());\n          } : function () {\n            return 6e4 * (t.timezoneOffset || 0);\n          } : function (t) {\n            return 6e4 * new Date(t.toString()).getTimezoneOffset();\n          };\n        }\n      }, {\n        key: \"dateFormat\",\n        value: function dateFormat(e, i, r) {\n          if (!s(i) || isNaN(i)) return t.defaultOptions.lang && t.defaultOptions.lang.invalidDate || \"\";\n          e = c(e, \"%Y-%m-%d %H:%M:%S\");\n          var n = this,\n            a = new this.Date(i),\n            h = this.get(\"Hours\", a),\n            p = this.get(\"Day\", a),\n            u = this.get(\"Date\", a),\n            g = this.get(\"Month\", a),\n            f = this.get(\"FullYear\", a),\n            _m = t.defaultOptions.lang,\n            x = _m && _m.weekdays,\n            y = _m && _m.shortWeekdays;\n          return l(o({\n            a: y ? y[p] : x[p].substr(0, 3),\n            A: x[p],\n            d: d(u),\n            e: d(u, 2, \" \"),\n            w: p,\n            b: _m.shortMonths[g],\n            B: _m.months[g],\n            m: d(g + 1),\n            o: g + 1,\n            y: f.toString().substr(2, 2),\n            Y: f,\n            H: d(h),\n            k: h,\n            I: d(h % 12 || 12),\n            l: h % 12 || 12,\n            M: d(this.get(\"Minutes\", a)),\n            p: h < 12 ? \"AM\" : \"PM\",\n            P: h < 12 ? \"am\" : \"pm\",\n            S: d(this.get(\"Seconds\", a)),\n            L: d(Math.floor(i % 1e3), 3)\n          }, t.dateFormats), function (t, s) {\n            for (; -1 !== e.indexOf(\"%\" + s);) e = e.replace(\"%\" + s, \"function\" == typeof t ? t.call(n, i) : t);\n          }), r ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n        }\n      }, {\n        key: \"resolveDTLFormat\",\n        value: function resolveDTLFormat(t) {\n          return a(t, !0) ? t : {\n            main: (t = p(t))[0],\n            from: t[1],\n            to: t[2]\n          };\n        }\n      }, {\n        key: \"getTimeTicks\",\n        value: function getTimeTicks(t, e, i, r) {\n          var n, a, h, l;\n          var d = this,\n            p = d.Date,\n            g = [],\n            f = {},\n            _m2 = new p(e),\n            x = t.unitRange,\n            y = t.count || 1;\n          if (r = c(r, 1), s(e)) {\n            d.set(\"Milliseconds\", _m2, x >= u.second ? 0 : y * Math.floor(d.get(\"Milliseconds\", _m2) / y)), x >= u.second && d.set(\"Seconds\", _m2, x >= u.minute ? 0 : y * Math.floor(d.get(\"Seconds\", _m2) / y)), x >= u.minute && d.set(\"Minutes\", _m2, x >= u.hour ? 0 : y * Math.floor(d.get(\"Minutes\", _m2) / y)), x >= u.hour && d.set(\"Hours\", _m2, x >= u.day ? 0 : y * Math.floor(d.get(\"Hours\", _m2) / y)), x >= u.day && d.set(\"Date\", _m2, x >= u.month ? 1 : Math.max(1, y * Math.floor(d.get(\"Date\", _m2) / y))), x >= u.month && (d.set(\"Month\", _m2, x >= u.year ? 0 : y * Math.floor(d.get(\"Month\", _m2) / y)), a = d.get(\"FullYear\", _m2)), x >= u.year && (a -= a % y, d.set(\"FullYear\", _m2, a)), x === u.week && (l = d.get(\"Day\", _m2), d.set(\"Date\", _m2, d.get(\"Date\", _m2) - l + r + (l < r ? -7 : 0))), a = d.get(\"FullYear\", _m2);\n            var _t8 = d.get(\"Month\", _m2),\n              _o6 = d.get(\"Date\", _m2),\n              _c = d.get(\"Hours\", _m2);\n            e = _m2.getTime(), (d.variableTimezone || !d.useUTC) && s(i) && (h = i - e > 4 * u.month || d.getTimezoneOffset(e) !== d.getTimezoneOffset(i));\n            var _p = _m2.getTime();\n            for (n = 1; _p < i;) g.push(_p), x === u.year ? _p = d.makeTime(a + n * y, 0) : x === u.month ? _p = d.makeTime(a, _t8 + n * y) : h && (x === u.day || x === u.week) ? _p = d.makeTime(a, _t8, _o6 + n * y * (x === u.day ? 1 : 7)) : h && x === u.hour && y > 1 ? _p = d.makeTime(a, _t8, _o6, _c + n * y) : _p += x * y, n++;\n            g.push(_p), x <= u.hour && g.length < 1e4 && g.forEach(function (t) {\n              t % 18e5 == 0 && \"000000000\" === d.dateFormat(\"%H%M%S%L\", t) && (f[t] = \"day\");\n            });\n          }\n          return g.info = o(t, {\n            higherRanks: f,\n            totalRange: x * y\n          }), g;\n        }\n      }, {\n        key: \"getDateFormat\",\n        value: function getDateFormat(t, e, i, s) {\n          var r = this.dateFormat(\"%m-%d %H:%M:%S.%L\", e),\n            o = \"01-01 00:00:00.000\",\n            n = {\n              millisecond: 15,\n              second: 12,\n              minute: 9,\n              hour: 6,\n              day: 3\n            },\n            a = \"millisecond\",\n            h = a;\n          for (a in u) {\n            if (t === u.week && +this.dateFormat(\"%w\", e) === i && r.substr(6) === o.substr(6)) {\n              a = \"week\";\n              break;\n            }\n            if (u[a] > t) {\n              a = h;\n              break;\n            }\n            if (n[a] && r.substr(n[a]) !== o.substr(n[a])) break;\n            \"week\" !== a && (h = a);\n          }\n          return this.resolveDTLFormat(s[a]).main;\n        }\n      }]);\n    }();\n    return m.formatCache = {}, m;\n  }), i(e, \"Core/Defaults.js\", [e[\"Core/Chart/ChartDefaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Color/Palettes.js\"], e[\"Core/Time.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r) {\n    var o = e.isTouchDevice,\n      n = r.fireEvent,\n      a = r.merge,\n      h = {\n        colors: i.colors,\n        symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n        lang: {\n          loading: \"Loading...\",\n          months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n          shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n          weekdays: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n          decimalPoint: \".\",\n          numericSymbols: [\"k\", \"M\", \"G\", \"T\", \"P\", \"E\"],\n          resetZoom: \"Reset zoom\",\n          resetZoomTitle: \"Reset zoom level 1:1\",\n          thousandsSep: \" \"\n        },\n        global: {\n          buttonTheme: {\n            fill: \"#f7f7f7\",\n            padding: 8,\n            r: 2,\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontSize: \"0.8em\",\n              fontWeight: \"normal\"\n            },\n            states: {\n              hover: {\n                fill: \"#e6e6e6\"\n              },\n              select: {\n                fill: \"#e6e9ff\",\n                style: {\n                  color: \"#000000\",\n                  fontWeight: \"bold\"\n                }\n              },\n              disabled: {\n                style: {\n                  color: \"#cccccc\"\n                }\n              }\n            }\n          }\n        },\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: t,\n        title: {\n          style: {\n            color: \"#333333\",\n            fontWeight: \"bold\"\n          },\n          text: \"Chart title\",\n          align: \"center\",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"center\",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"left\",\n          verticalAlign: \"bottom\"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: \"center\",\n          alignColumns: !0,\n          className: \"highcharts-no-tooltip\",\n          events: {},\n          layout: \"horizontal\",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function labelFormatter() {\n            return this.name;\n          },\n          borderColor: \"#999999\",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: \"0.8em\"\n            },\n            activeColor: \"#0022ff\",\n            inactiveColor: \"#cccccc\"\n          },\n          itemStyle: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            textDecoration: \"none\",\n            textOverflow: \"ellipsis\"\n          },\n          itemHoverStyle: {\n            color: \"#000000\"\n          },\n          itemHiddenStyle: {\n            color: \"#666666\",\n            textDecoration: \"line-through\"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: \"absolute\",\n            width: \"13px\",\n            height: \"13px\"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: \"0.8em\",\n              fontWeight: \"bold\"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: \"bold\",\n            position: \"relative\",\n            top: \"45%\"\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#ffffff\",\n            opacity: .5,\n            textAlign: \"center\"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: {\n            duration: 300,\n            easing: function easing(t) {\n              return Math.sqrt(1 - Math.pow(t - 1, 2));\n            }\n          },\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n            second: \"%A, %e %b, %H:%M:%S\",\n            minute: \"%A, %e %b, %H:%M\",\n            hour: \"%A, %e %b, %H:%M\",\n            day: \"%A, %e %b %Y\",\n            week: \"Week from %A, %e %b %Y\",\n            month: \"%B %Y\",\n            year: \"%Y\"\n          },\n          footerFormat: \"\",\n          headerShape: \"callout\",\n          hideDelay: 500,\n          padding: 8,\n          shape: \"callout\",\n          shared: !1,\n          snap: o ? 25 : 10,\n          headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n          pointFormat: '<span style=\"color:{point.color}\">●</span> {series.name}: <b>{point.y}</b><br/>',\n          backgroundColor: \"#ffffff\",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: \"https://www.highcharts.com?credits\",\n          position: {\n            align: \"right\",\n            x: -10,\n            verticalAlign: \"bottom\",\n            y: -5\n          },\n          style: {\n            cursor: \"pointer\",\n            color: \"#999999\",\n            fontSize: \"0.6em\"\n          },\n          text: \"Highcharts.com\"\n        }\n      };\n    h.chart.styledMode = !1;\n    var l = new s(h.time);\n    return {\n      defaultOptions: h,\n      defaultTime: l,\n      getOptions: function getOptions() {\n        return h;\n      },\n      setOptions: function setOptions(t) {\n        return n(e, \"setOptions\", {\n          options: t\n        }), a(!0, h, t), (t.time || t.global) && (e.time ? e.time.update(a(h.global, h.time, t.global, t.time)) : e.time = l), h;\n      }\n    };\n  }), i(e, \"Core/Color/Color.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.isNumber,\n      s = e.merge,\n      r = e.pInt;\n    var o = /*#__PURE__*/function () {\n      function o(e) {\n        _classCallCheck(this, o);\n        var i, s, r, n;\n        this.rgba = [NaN, NaN, NaN, NaN], this.input = e;\n        var a = t.Color;\n        if (a && a !== o) return new a(e);\n        if (\"object\" == _typeof(e) && void 0 !== e.stops) this.stops = e.stops.map(function (t) {\n          return new o(t[1]);\n        });else if (\"string\" == typeof e) {\n          if (this.input = e = o.names[e.toLowerCase()] || e, \"#\" === e.charAt(0)) {\n            var _t9 = e.length,\n              _i5 = parseInt(e.substr(1), 16);\n            7 === _t9 ? s = [(16711680 & _i5) >> 16, (65280 & _i5) >> 8, 255 & _i5, 1] : 4 === _t9 && (s = [(3840 & _i5) >> 4 | (3840 & _i5) >> 8, (240 & _i5) >> 4 | 240 & _i5, (15 & _i5) << 4 | 15 & _i5, 1]);\n          }\n          if (!s) for (r = o.parsers.length; r-- && !s;) (i = (n = o.parsers[r]).regex.exec(e)) && (s = n.parse(i));\n        }\n        s && (this.rgba = s);\n      }\n      return _createClass(o, [{\n        key: \"get\",\n        value: function get(t) {\n          var e = this.input,\n            r = this.rgba;\n          if (\"object\" == _typeof(e) && void 0 !== this.stops) {\n            var _i6 = s(e);\n            return _i6.stops = [].slice.call(_i6.stops), this.stops.forEach(function (e, s) {\n              _i6.stops[s] = [_i6.stops[s][0], e.get(t)];\n            }), _i6;\n          }\n          return r && i(r[0]) ? \"rgb\" !== t && (t || 1 !== r[3]) ? \"a\" === t ? \"\".concat(r[3]) : \"rgba(\" + r.join(\",\") + \")\" : \"rgb(\" + r[0] + \",\" + r[1] + \",\" + r[2] + \")\" : e;\n        }\n      }, {\n        key: \"brighten\",\n        value: function brighten(t) {\n          var e = this.rgba;\n          if (this.stops) this.stops.forEach(function (e) {\n            e.brighten(t);\n          });else if (i(t) && 0 !== t) for (var _i7 = 0; _i7 < 3; _i7++) e[_i7] += r(255 * t), e[_i7] < 0 && (e[_i7] = 0), e[_i7] > 255 && (e[_i7] = 255);\n          return this;\n        }\n      }, {\n        key: \"setOpacity\",\n        value: function setOpacity(t) {\n          return this.rgba[3] = t, this;\n        }\n      }, {\n        key: \"tweenTo\",\n        value: function tweenTo(t, e) {\n          var s = this.rgba,\n            r = t.rgba;\n          if (!i(s[0]) || !i(r[0])) return t.input || \"none\";\n          var _o7 = 1 !== r[3] || 1 !== s[3];\n          return (_o7 ? \"rgba(\" : \"rgb(\") + Math.round(r[0] + (s[0] - r[0]) * (1 - e)) + \",\" + Math.round(r[1] + (s[1] - r[1]) * (1 - e)) + \",\" + Math.round(r[2] + (s[2] - r[2]) * (1 - e)) + (_o7 ? \",\" + (r[3] + (s[3] - r[3]) * (1 - e)) : \"\") + \")\";\n        }\n      }], [{\n        key: \"parse\",\n        value: function parse(t) {\n          return t ? new o(t) : o.None;\n        }\n      }]);\n    }();\n    return o.names = {\n      white: \"#ffffff\",\n      black: \"#000000\"\n    }, o.parsers = [{\n      regex: /rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)/,\n      parse: function parse(t) {\n        return [r(t[1]), r(t[2]), r(t[3]), parseFloat(t[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)/,\n      parse: function parse(t) {\n        return [r(t[1]), r(t[2]), r(t[3]), 1];\n      }\n    }], o.None = new o(\"\"), o;\n  }), i(e, \"Core/Animation/Fx.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.parse,\n      r = e.win,\n      o = i.isNumber,\n      n = i.objectEach;\n    var a = /*#__PURE__*/function () {\n      function a(t, e, i) {\n        _classCallCheck(this, a);\n        this.pos = NaN, this.options = e, this.elem = t, this.prop = i;\n      }\n      return _createClass(a, [{\n        key: \"dSetter\",\n        value: function dSetter() {\n          var t = this.paths,\n            e = t && t[0],\n            i = t && t[1],\n            s = this.now || 0,\n            r = [];\n          if (1 !== s && e && i) {\n            if (e.length === i.length && s < 1) for (var _t10 = 0; _t10 < i.length; _t10++) {\n              var _n = e[_t10],\n                _a2 = i[_t10],\n                h = [];\n              for (var _t11 = 0; _t11 < _a2.length; _t11++) {\n                var _e5 = _n[_t11],\n                  _i8 = _a2[_t11];\n                o(_e5) && o(_i8) && !(\"A\" === _a2[0] && (4 === _t11 || 5 === _t11)) ? h[_t11] = _e5 + s * (_i8 - _e5) : h[_t11] = _i8;\n              }\n              r.push(h);\n            } else r = i;\n          } else r = this.toD || [];\n          this.elem.attr(\"d\", r, void 0, !0);\n        }\n      }, {\n        key: \"update\",\n        value: function update() {\n          var t = this.elem,\n            e = this.prop,\n            i = this.now,\n            s = this.options.step;\n          this[e + \"Setter\"] ? this[e + \"Setter\"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);\n        }\n      }, {\n        key: \"run\",\n        value: function run(t, e, i) {\n          var s = this,\n            o = s.options,\n            _n2 = function n(t) {\n              return !_n2.stopped && s.step(t);\n            },\n            h = r.requestAnimationFrame || function (t) {\n              setTimeout(t, 13);\n            },\n            _l2 = function l() {\n              for (var _t12 = 0; _t12 < a.timers.length; _t12++) a.timers[_t12]() || a.timers.splice(_t12--, 1);\n              a.timers.length && h(_l2);\n            };\n          t !== e || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, _n2.elem = this.elem, _n2.prop = this.prop, _n2() && 1 === a.timers.push(_n2) && h(_l2)) : (delete o.curAnim[this.prop], o.complete && 0 === Object.keys(o.curAnim).length && o.complete.call(this.elem));\n        }\n      }, {\n        key: \"step\",\n        value: function step(t) {\n          var e, i;\n          var s = +new Date(),\n            r = this.options,\n            o = this.elem,\n            _a3 = r.complete,\n            h = r.duration,\n            l = r.curAnim;\n          return o.attr && !o.element ? e = !1 : t || s >= h + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), l[this.prop] = !0, i = !0, n(l, function (t) {\n            !0 !== t && (i = !1);\n          }), i && _a3 && _a3.call(o), e = !1) : (this.pos = r.easing((s - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;\n        }\n      }, {\n        key: \"initPath\",\n        value: function initPath(t, e, i) {\n          var s = t.startX,\n            r = t.endX,\n            n = i.slice(),\n            _a4 = t.isArea,\n            h = _a4 ? 2 : 1,\n            l = e && i.length > e.length && i.hasStackedCliffs,\n            d,\n            c,\n            p,\n            u,\n            g = e && e.slice();\n          if (!g || l) return [n, n];\n          function f(t, e) {\n            for (; t.length < c;) {\n              var _i9 = t[0],\n                _s9 = e[c - t.length];\n              if (_s9 && \"M\" === _i9[0] && (\"C\" === _s9[0] ? t[0] = [\"C\", _i9[1], _i9[2], _i9[1], _i9[2], _i9[1], _i9[2]] : t[0] = [\"L\", _i9[1], _i9[2]]), t.unshift(_i9), _a4) {\n                var _e6 = t.pop();\n                t.push(t[t.length - 1], _e6);\n              }\n            }\n          }\n          function m(t) {\n            for (; t.length < c;) {\n              var _e7 = t[Math.floor(t.length / h) - 1].slice();\n              if (\"C\" === _e7[0] && (_e7[1] = _e7[5], _e7[2] = _e7[6]), _a4) {\n                var _i10 = t[Math.floor(t.length / h)].slice();\n                t.splice(t.length / 2, 0, _e7, _i10);\n              } else t.push(_e7);\n            }\n          }\n          if (s && r && r.length) {\n            for (p = 0; p < s.length; p++) {\n              if (s[p] === r[0]) {\n                d = p;\n                break;\n              }\n              if (s[0] === r[r.length - s.length + p]) {\n                d = p, u = !0;\n                break;\n              }\n              if (s[s.length - 1] === r[r.length - s.length + p]) {\n                d = s.length - p;\n                break;\n              }\n            }\n            void 0 === d && (g = []);\n          }\n          return g.length && o(d) && (c = n.length + d * h, u ? (f(g, n), m(n)) : (f(n, g), m(g))), [g, n];\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter() {\n          a.prototype.strokeSetter.apply(this, arguments);\n        }\n      }, {\n        key: \"strokeSetter\",\n        value: function strokeSetter() {\n          this.elem.attr(this.prop, s(this.start).tweenTo(s(this.end), this.pos), void 0, !0);\n        }\n      }]);\n    }();\n    return a.timers = [], a;\n  }), i(e, \"Core/Animation/AnimationUtilities.js\", [e[\"Core/Animation/Fx.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.defined,\n      s = e.getStyle,\n      r = e.isArray,\n      o = e.isNumber,\n      n = e.isObject,\n      a = e.merge,\n      h = e.objectEach,\n      l = e.pick;\n    function d(t) {\n      return n(t) ? a({\n        duration: 500,\n        defer: 0\n      }, t) : {\n        duration: t ? 500 : 0,\n        defer: 0\n      };\n    }\n    function c(e, i) {\n      var s = t.timers.length;\n      for (; s--;) t.timers[s].elem !== e || i && i !== t.timers[s].prop || (t.timers[s].stopped = !0);\n    }\n    return {\n      animate: function animate(e, i, l) {\n        var d,\n          p = \"\",\n          u,\n          g,\n          f;\n        n(l) || (f = arguments, l = {\n          duration: f[2],\n          easing: f[3],\n          complete: f[4]\n        }), o(l.duration) || (l.duration = 400), l.easing = \"function\" == typeof l.easing ? l.easing : Math[l.easing] || Math.easeInOutSine, l.curAnim = a(i), h(i, function (o, n) {\n          c(e, n), g = new t(e, l, n), u = void 0, \"d\" === n && r(i.d) ? (g.paths = g.initPath(e, e.pathArray, i.d), g.toD = i.d, d = 0, u = 1) : e.attr ? d = e.attr(n) : (d = parseFloat(s(e, n)) || 0, \"opacity\" !== n && (p = \"px\")), u || (u = o), \"string\" == typeof u && u.match(\"px\") && (u = u.replace(/px/g, \"\")), g.run(d, u, p);\n        });\n      },\n      animObject: d,\n      getDeferredAnimation: function getDeferredAnimation(t, e, s) {\n        var r = d(e),\n          o = s ? [s] : t.series,\n          a = 0,\n          h = 0;\n        return o.forEach(function (t) {\n          var s = d(t.options.animation);\n          a = n(e) && i(e.defer) ? r.defer : Math.max(a, s.duration + s.defer), h = Math.min(r.duration, s.duration);\n        }), t.renderer.forExport && (a = 0), {\n          defer: Math.max(0, a - h),\n          duration: Math.min(a, h)\n        };\n      },\n      setAnimation: function setAnimation(t, e) {\n        e.renderer.globalAnimation = l(t, e.options.chart.animation, !0);\n      },\n      stop: c\n    };\n  }), i(e, \"Core/Renderer/HTML/AST.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.SVG_NS,\n      s = t.win,\n      r = e.attr,\n      o = e.createElement,\n      n = e.css,\n      a = e.error,\n      h = e.isFunction,\n      l = e.isString,\n      d = e.objectEach,\n      c = e.splat,\n      p = s.trustedTypes,\n      u = p && h(p.createPolicy) && p.createPolicy(\"highcharts\", {\n        createHTML: function createHTML(t) {\n          return t;\n        }\n      }),\n      g = u ? u.createHTML(\"\") : \"\",\n      f = function () {\n        try {\n          return !!new DOMParser().parseFromString(g, \"text/html\");\n        } catch (t) {\n          return !1;\n        }\n      }();\n    var m = /*#__PURE__*/function () {\n      function m(t) {\n        _classCallCheck(this, m);\n        this.nodes = \"string\" == typeof t ? this.parseMarkup(t) : t;\n      }\n      return _createClass(m, [{\n        key: \"addToDOM\",\n        value: function addToDOM(e) {\n          return function e(s, o) {\n            var h;\n            return c(s).forEach(function (s) {\n              var l;\n              var c = s.tagName,\n                p = s.textContent ? t.doc.createTextNode(s.textContent) : void 0,\n                u = m.bypassHTMLFiltering;\n              if (c) {\n                if (\"#text\" === c) l = p;else if (-1 !== m.allowedTags.indexOf(c) || u) {\n                  var _a5 = \"svg\" === c ? i : o.namespaceURI || i,\n                    _h2 = t.doc.createElementNS(_a5, c),\n                    _g = s.attributes || {};\n                  d(s, function (t, e) {\n                    \"tagName\" !== e && \"attributes\" !== e && \"children\" !== e && \"style\" !== e && \"textContent\" !== e && (_g[e] = t);\n                  }), r(_h2, u ? _g : m.filterUserAttributes(_g)), s.style && n(_h2, s.style), p && _h2.appendChild(p), e(s.children || [], _h2), l = _h2;\n                } else a(33, !1, void 0, {\n                  \"Invalid tagName in config\": c\n                });\n              }\n              l && o.appendChild(l), h = l;\n            }), h;\n          }(this.nodes, e);\n        }\n      }, {\n        key: \"parseMarkup\",\n        value: function parseMarkup(t) {\n          var e;\n          var i = [];\n          if (t = t.trim().replace(/ style=([\"'])/g, \" data-style=$1\"), f) e = new DOMParser().parseFromString(u ? u.createHTML(t) : t, \"text/html\");else {\n            var _i11 = o(\"div\");\n            _i11.innerHTML = t, e = {\n              body: _i11\n            };\n          }\n          var _s10 = function s(t, e) {\n            var i = t.nodeName.toLowerCase(),\n              r = {\n                tagName: i\n              };\n            \"#text\" === i && (r.textContent = t.textContent || \"\");\n            var o = t.attributes;\n            if (o) {\n              var _t13 = {};\n              [].forEach.call(o, function (e) {\n                \"data-style\" === e.name ? r.style = m.parseStyle(e.value) : _t13[e.name] = e.value;\n              }), r.attributes = _t13;\n            }\n            if (t.childNodes.length) {\n              var _e8 = [];\n              [].forEach.call(t.childNodes, function (t) {\n                _s10(t, _e8);\n              }), _e8.length && (r.children = _e8);\n            }\n            e.push(r);\n          };\n          return [].forEach.call(e.body.childNodes, function (t) {\n            return _s10(t, i);\n          }), i;\n        }\n      }], [{\n        key: \"filterUserAttributes\",\n        value: function filterUserAttributes(t) {\n          return d(t, function (e, i) {\n            var s = !0;\n            -1 === m.allowedAttributes.indexOf(i) && (s = !1), -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(i) && (s = l(e) && m.allowedReferences.some(function (t) {\n              return 0 === e.indexOf(t);\n            })), s || (a(33, !1, void 0, {\n              \"Invalid attribute in config\": \"\".concat(i)\n            }), delete t[i]), l(e) && t[i] && (t[i] = e.replace(/</g, \"&lt;\"));\n          }), t;\n        }\n      }, {\n        key: \"parseStyle\",\n        value: function parseStyle(t) {\n          return t.split(\";\").reduce(function (t, e) {\n            var i = e.split(\":\").map(function (t) {\n                return t.trim();\n              }),\n              s = i.shift();\n            return s && i.length && (t[s.replace(/-([a-z])/g, function (t) {\n              return t[1].toUpperCase();\n            })] = i.join(\":\")), t;\n          }, {});\n        }\n      }, {\n        key: \"setElementHTML\",\n        value: function setElementHTML(t, e) {\n          t.innerHTML = m.emptyHTML, e && new m(e).addToDOM(t);\n        }\n      }]);\n    }();\n    return m.allowedAttributes = [\"alt\", \"aria-controls\", \"aria-describedby\", \"aria-expanded\", \"aria-haspopup\", \"aria-hidden\", \"aria-label\", \"aria-labelledby\", \"aria-live\", \"aria-pressed\", \"aria-readonly\", \"aria-roledescription\", \"aria-selected\", \"class\", \"clip-path\", \"color\", \"colspan\", \"cx\", \"cy\", \"d\", \"dx\", \"dy\", \"disabled\", \"fill\", \"filterUnits\", \"flood-color\", \"flood-opacity\", \"height\", \"href\", \"id\", \"in\", \"in2\", \"markerHeight\", \"markerWidth\", \"offset\", \"opacity\", \"operator\", \"orient\", \"padding\", \"paddingLeft\", \"paddingRight\", \"patternUnits\", \"r\", \"radius\", \"refX\", \"refY\", \"role\", \"scope\", \"slope\", \"src\", \"startOffset\", \"stdDeviation\", \"stroke\", \"stroke-linecap\", \"stroke-width\", \"style\", \"tableValues\", \"result\", \"rowspan\", \"summary\", \"target\", \"tabindex\", \"text-align\", \"text-anchor\", \"textAnchor\", \"textLength\", \"title\", \"type\", \"valign\", \"width\", \"x\", \"x1\", \"x2\", \"xlink:href\", \"y\", \"y1\", \"y2\", \"zIndex\"], m.allowedReferences = [\"https://\", \"http://\", \"mailto:\", \"/\", \"../\", \"./\", \"#\"], m.allowedTags = [\"a\", \"abbr\", \"b\", \"br\", \"button\", \"caption\", \"circle\", \"clipPath\", \"code\", \"dd\", \"defs\", \"div\", \"dl\", \"dt\", \"em\", \"feComponentTransfer\", \"feComposite\", \"feDropShadow\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feMorphology\", \"feOffset\", \"feMerge\", \"feMergeNode\", \"filter\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"i\", \"img\", \"li\", \"linearGradient\", \"marker\", \"ol\", \"p\", \"path\", \"pattern\", \"pre\", \"rect\", \"small\", \"span\", \"stop\", \"strong\", \"style\", \"sub\", \"sup\", \"svg\", \"table\", \"text\", \"textPath\", \"thead\", \"title\", \"tbody\", \"tspan\", \"td\", \"th\", \"tr\", \"u\", \"ul\", \"#text\"], m.emptyHTML = g, m.bypassHTMLFiltering = !1, m;\n  }), i(e, \"Core/Templating.js\", [e[\"Core/Defaults.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.defaultOptions,\n      s = t.defaultTime,\n      r = e.extend,\n      o = e.getNestedProperty,\n      n = e.isArray,\n      a = e.isNumber,\n      h = e.isObject,\n      l = e.pick,\n      d = e.pInt,\n      c = {\n        add: function add(t, e) {\n          return t + e;\n        },\n        divide: function divide(t, e) {\n          return 0 !== e ? t / e : \"\";\n        },\n        eq: function eq(t, e) {\n          return t == e;\n        },\n        each: function each(t) {\n          var e = arguments[arguments.length - 1];\n          return !!n(t) && t.map(function (i, s) {\n            return p(e.body, r(h(i) ? i : {\n              \"@this\": i\n            }, {\n              \"@index\": s,\n              \"@first\": 0 === s,\n              \"@last\": s === t.length - 1\n            }));\n          }).join(\"\");\n        },\n        ge: function ge(t, e) {\n          return t >= e;\n        },\n        gt: function gt(t, e) {\n          return t > e;\n        },\n        \"if\": function _if(t) {\n          return !!t;\n        },\n        le: function le(t, e) {\n          return t <= e;\n        },\n        lt: function lt(t, e) {\n          return t < e;\n        },\n        multiply: function multiply(t, e) {\n          return t * e;\n        },\n        ne: function ne(t, e) {\n          return t != e;\n        },\n        subtract: function subtract(t, e) {\n          return t - e;\n        },\n        unless: function unless(t) {\n          return !t;\n        }\n      };\n    function p() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var e = arguments.length > 1 ? arguments[1] : undefined;\n      var r = arguments.length > 2 ? arguments[2] : undefined;\n      var n = /\\{([\\w\\:\\.\\,;\\-\\/<>%@\"'’= #\\(\\)]+)\\}/g,\n        a = /\\(([\\w\\:\\.\\,;\\-\\/<>%@\"'= ]+)\\)/g,\n        h = [],\n        d = /f$/,\n        g = /\\.(\\d)/,\n        f = i.lang,\n        m = r && r.time || s,\n        x = r && r.numberFormatter || u,\n        y = function y() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n          var i;\n          return \"true\" === t || \"false\" !== t && ((i = Number(t)).toString() === t ? i : o(t, e));\n        },\n        b,\n        v,\n        S = 0,\n        C;\n      for (; null !== (b = n.exec(t));) {\n        var _v;\n        var _i12 = a.exec(b[1]);\n        _i12 && (b = _i12, C = !0), v && v.isBlock || (v = {\n          ctx: e,\n          expression: b[1],\n          find: b[0],\n          isBlock: \"#\" === b[1].charAt(0),\n          start: b.index,\n          startInner: b.index + b[0].length,\n          length: b[0].length\n        });\n        var _s11 = b[1].split(\" \")[0].replace(\"#\", \"\");\n        c[_s11] && (v.isBlock && _s11 === v.fn && S++, v.fn || (v.fn = _s11));\n        var _r4 = \"else\" === b[1];\n        if (v.isBlock && v.fn && (b[1] === \"/\".concat(v.fn) || _r4)) {\n          if (S) !_r4 && S--;else {\n            var _e9 = v.startInner,\n              _i13 = t.substr(_e9, b.index - _e9);\n            void 0 === v.body ? (v.body = _i13, v.startInner = b.index + b[0].length) : v.elseBody = _i13, v.find += _i13 + b[0], _r4 || (h.push(v), v = void 0);\n          }\n        } else v.isBlock || h.push(v);\n        if (_i12 && !((_v = v) !== null && _v !== void 0 && _v.isBlock)) break;\n      }\n      return h.forEach(function (i) {\n        var s, o;\n        var n = i.body,\n          a = i.elseBody,\n          h = i.expression,\n          u = i.fn;\n        if (u) {\n          var _t14 = [i],\n            _l3 = h.split(\" \");\n          for (o = c[u].length; o--;) _t14.unshift(y(_l3[o + 1]));\n          s = c[u].apply(e, _t14), i.isBlock && \"boolean\" == typeof s && (s = p(s ? n : a, e, r));\n        } else {\n          var _t15 = h.split(\":\");\n          if (s = y(_t15.shift() || \"\"), _t15.length && \"number\" == typeof s) {\n            var _e10 = _t15.join(\":\");\n            if (d.test(_e10)) {\n              var _t16 = parseInt((_e10.match(g) || [\"\", \"-1\"])[1], 10);\n              null !== s && (s = x(s, _t16, f.decimalPoint, _e10.indexOf(\",\") > -1 ? f.thousandsSep : \"\"));\n            } else s = m.dateFormat(_e10, s);\n          }\n        }\n        t = t.replace(i.find, l(s, \"\"));\n      }), C ? p(t, e, r) : t;\n    }\n    function u(t, e, s, r) {\n      var o, n;\n      t = +t || 0, e = +e;\n      var h = i.lang,\n        c = (t.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n        p = t.toString().split(\"e\"),\n        u = e;\n      -1 === e ? e = Math.min(c, 20) : a(e) ? e && p[1] && p[1] < 0 && ((n = e + +p[1]) >= 0 ? (p[0] = (+p[0]).toExponential(n).split(\"e\")[0], e = n) : (p[0] = p[0].split(\".\")[0] || 0, t = e < 20 ? (p[0] * Math.pow(10, p[1])).toFixed(e) : 0, p[1] = 0)) : e = 2;\n      var g = (Math.abs(p[1] ? p[0] : t) + Math.pow(10, -Math.max(e, c) - 1)).toFixed(e),\n        f = String(d(g)),\n        m = f.length > 3 ? f.length % 3 : 0;\n      return s = l(s, h.decimalPoint), r = l(r, h.thousandsSep), o = (t < 0 ? \"-\" : \"\") + (m ? f.substr(0, m) + r : \"\"), 0 > +p[1] && !u ? o = \"0\" : o += f.substr(m).replace(/(\\d{3})(?=\\d)/g, \"$1\" + r), e ? o += s + g.slice(-e) : 0 == +o && (o = \"0\"), p[1] && 0 != +o && (o += \"e\" + p[1]), o;\n    }\n    return {\n      dateFormat: function dateFormat(t, e, i) {\n        return s.dateFormat(t, e, i);\n      },\n      format: p,\n      helpers: c,\n      numberFormat: u\n    };\n  }), i(e, \"Core/Renderer/RendererRegistry.js\", [e[\"Core/Globals.js\"]], function (t) {\n    var e, i;\n    var s;\n    return (i = e || (e = {})).rendererTypes = {}, i.getRendererType = function () {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : s;\n      return i.rendererTypes[t] || i.rendererTypes[s];\n    }, i.registerRendererType = function (e, r, o) {\n      i.rendererTypes[e] = r, (!s || o) && (s = e, t.Renderer = r);\n    }, e;\n  }), i(e, \"Core/Renderer/RendererUtilities.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.clamp,\n      s = t.pick,\n      r = t.pushUnique,\n      o = t.stableSort;\n    return (e || (e = {})).distribute = function t(e, n, a) {\n      var h = e,\n        l = h.reducedLen || n,\n        d = function d(t, e) {\n          return t.target - e.target;\n        },\n        c = [],\n        p = e.length,\n        u = [],\n        g = c.push,\n        f,\n        m,\n        x,\n        y = !0,\n        b,\n        v,\n        S = 0,\n        C;\n      for (f = p; f--;) S += e[f].size;\n      if (S > l) {\n        for (o(e, function (t, e) {\n          return (e.rank || 0) - (t.rank || 0);\n        }), x = (C = e[0].rank === e[e.length - 1].rank) ? p / 2 : -1, m = C ? x : p - 1; x && S > l;) b = e[f = Math.floor(m)], r(u, f) && (S -= b.size), m += x, C && m >= e.length && (x /= 2, m = x);\n        u.sort(function (t, e) {\n          return e - t;\n        }).forEach(function (t) {\n          return g.apply(c, e.splice(t, 1));\n        });\n      }\n      for (o(e, d), e = e.map(function (t) {\n        return {\n          size: t.size,\n          targets: [t.target],\n          align: s(t.align, .5)\n        };\n      }); y;) {\n        for (f = e.length; f--;) b = e[f], v = (Math.min.apply(0, b.targets) + Math.max.apply(0, b.targets)) / 2, b.pos = i(v - b.size * b.align, 0, n - b.size);\n        for (f = e.length, y = !1; f--;) f > 0 && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > n && (e[f - 1].pos = n - e[f - 1].size), e.splice(f, 1), y = !0);\n      }\n      return g.apply(h, c), f = 0, e.some(function (e) {\n        var i = 0;\n        return (e.targets || []).some(function () {\n          return (h[f].pos = e.pos + i, void 0 !== a && Math.abs(h[f].pos - h[f].target) > a) ? (h.slice(0, f + 1).forEach(function (t) {\n            return delete t.pos;\n          }), h.reducedLen = (h.reducedLen || n) - .1 * n, h.reducedLen > .1 * n && t(h, n, a), !0) : (i += h[f].size, f++, !1);\n        });\n      }), o(h, d), h;\n    }, e;\n  }), i(e, \"Core/Renderer/SVG/SVGElement.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r = t.animate,\n      o = t.animObject,\n      n = t.stop,\n      a = i.deg2rad,\n      h = i.doc,\n      l = i.svg,\n      d = i.SVG_NS,\n      c = i.win,\n      p = s.addEvent,\n      u = s.attr,\n      g = s.createElement,\n      f = s.crisp,\n      m = s.css,\n      x = s.defined,\n      y = s.erase,\n      b = s.extend,\n      v = s.fireEvent,\n      S = s.isArray,\n      C = s.isFunction,\n      k = s.isObject,\n      M = s.isString,\n      w = s.merge,\n      A = s.objectEach,\n      T = s.pick,\n      P = s.pInt,\n      L = s.pushUnique,\n      O = s.replaceNested,\n      D = s.syncTimeout,\n      E = s.uniqueKey;\n    var I = /*#__PURE__*/function () {\n      function I(t, e) {\n        _classCallCheck(this, I);\n        this.onEvents = {}, this.opacity = 1, this.SVG_NS = d, this.element = \"span\" === e || \"body\" === e ? g(e) : h.createElementNS(this.SVG_NS, e), this.renderer = t, this.styles = {}, v(this, \"afterInit\");\n      }\n      return _createClass(I, [{\n        key: \"_defaultGetter\",\n        value: function _defaultGetter(t) {\n          var e = T(this[t + \"Value\"], this[t], this.element ? this.element.getAttribute(t) : null, 0);\n          return /^-?[\\d\\.]+$/.test(e) && (e = parseFloat(e)), e;\n        }\n      }, {\n        key: \"_defaultSetter\",\n        value: function _defaultSetter(t, e, i) {\n          i.setAttribute(e, t);\n        }\n      }, {\n        key: \"add\",\n        value: function add(t) {\n          var e;\n          var i = this.renderer,\n            s = this.element;\n          return t && (this.parentGroup = t), void 0 !== this.textStr && \"text\" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;\n        }\n      }, {\n        key: \"addClass\",\n        value: function addClass(t, e) {\n          var i = e ? \"\" : this.attr(\"class\") || \"\";\n          return (t = (t || \"\").split(/ /g).reduce(function (t, e) {\n            return -1 === i.indexOf(e) && t.push(e), t;\n          }, i ? [i] : []).join(\" \")) !== i && this.attr(\"class\", t), this;\n        }\n      }, {\n        key: \"afterSetters\",\n        value: function afterSetters() {\n          this.doTransform && (this.updateTransform(), this.doTransform = !1);\n        }\n      }, {\n        key: \"align\",\n        value: function align(t, e, i) {\n          var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n          var r, o, n, a;\n          var h = {},\n            l = this.renderer,\n            d = l.alignedObjects,\n            c = !!t;\n          t ? (this.alignOptions = t, this.alignByTranslate = e, this.alignTo = i) : (t = this.alignOptions || {}, e = this.alignByTranslate, i = this.alignTo);\n          var p = !i || M(i) ? i || \"renderer\" : void 0;\n          p && (c && L(d, this), i = void 0);\n          var u = T(i, l[p], l),\n            g = t.align,\n            f = t.verticalAlign;\n          return r = (u.x || 0) + (t.x || 0), o = (u.y || 0) + (t.y || 0), \"right\" === g ? n = 1 : \"center\" === g && (n = 2), n && (r += ((u.width || 0) - (t.width || 0)) / n), h[e ? \"translateX\" : \"x\"] = Math.round(r), \"bottom\" === f ? a = 1 : \"middle\" === f && (a = 2), a && (o += ((u.height || 0) - (t.height || 0)) / a), h[e ? \"translateY\" : \"y\"] = Math.round(o), s && (this[this.placed ? \"animate\" : \"attr\"](h), this.placed = !0), this.alignAttr = h, this;\n        }\n      }, {\n        key: \"alignSetter\",\n        value: function alignSetter(t) {\n          var e = {\n            left: \"start\",\n            center: \"middle\",\n            right: \"end\"\n          };\n          e[t] && (this.alignValue = t, this.element.setAttribute(\"text-anchor\", e[t]));\n        }\n      }, {\n        key: \"animate\",\n        value: function animate(t, e, i) {\n          var _this = this;\n          var s = o(T(e, this.renderer.globalAnimation, !0)),\n            n = s.defer;\n          return h.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), D(function () {\n            _this.element && r(_this, t, s);\n          }, n)) : (this.attr(t, void 0, i || s.complete), A(t, function (t, e) {\n            s.step && s.step.call(this, t, {\n              prop: e,\n              pos: 1,\n              elem: this\n            });\n          }, this)), this;\n        }\n      }, {\n        key: \"applyTextOutline\",\n        value: function applyTextOutline(t) {\n          var e = this.element;\n          -1 !== t.indexOf(\"contrast\") && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));\n          var s = t.split(\" \"),\n            r = s[s.length - 1],\n            o = s[0];\n          if (o && \"none\" !== o && i.svg) {\n            this.fakeTS = !0, o = o.replace(/(^[\\d\\.]+)(.*?)$/g, function (t, e, i) {\n              return 2 * Number(e) + i;\n            }), this.removeTextOutline();\n            var _t17 = h.createElementNS(d, \"tspan\");\n            u(_t17, {\n              \"class\": \"highcharts-text-outline\",\n              fill: r,\n              stroke: r,\n              \"stroke-width\": o,\n              \"stroke-linejoin\": \"round\"\n            });\n            var _i14 = e.querySelector(\"textPath\") || e;\n            [].forEach.call(_i14.childNodes, function (e) {\n              var i = e.cloneNode(!0);\n              i.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(function (t) {\n                return i.removeAttribute(t);\n              }), _t17.appendChild(i);\n            });\n            var _s12 = 0;\n            [].forEach.call(_i14.querySelectorAll(\"text tspan\"), function (t) {\n              _s12 += Number(t.getAttribute(\"dy\"));\n            });\n            var _n3 = h.createElementNS(d, \"tspan\");\n            _n3.textContent = \"​\", u(_n3, {\n              x: Number(e.getAttribute(\"x\")),\n              dy: -_s12\n            }), _t17.appendChild(_n3), _i14.insertBefore(_t17, _i14.firstChild);\n          }\n        }\n      }, {\n        key: \"attr\",\n        value: function attr(t, e, i, s) {\n          var r = this.element,\n            o = I.symbolCustomAttribs,\n            a,\n            h,\n            l = this,\n            d;\n          return \"string\" == typeof t && void 0 !== e && (a = t, (t = {})[a] = e), \"string\" == typeof t ? l = (this[t + \"Getter\"] || this._defaultGetter).call(this, t, r) : (A(t, function (e, i) {\n            d = !1, s || n(this, i), this.symbolName && -1 !== o.indexOf(i) && (h || (this.symbolAttr(t), h = !0), d = !0), this.rotation && (\"x\" === i || \"y\" === i) && (this.doTransform = !0), d || (this[i + \"Setter\"] || this._defaultSetter).call(this, e, i, r);\n          }, this), this.afterSetters()), i && i.call(this), l;\n        }\n      }, {\n        key: \"clip\",\n        value: function clip(t) {\n          if (t && !t.clipPath) {\n            var _e11 = E() + \"-\",\n              _i15 = this.renderer.createElement(\"clipPath\").attr({\n                id: _e11\n              }).add(this.renderer.defs);\n            b(t, {\n              clipPath: _i15,\n              id: _e11,\n              count: 0\n            }), t.add(_i15);\n          }\n          return this.attr(\"clip-path\", t ? \"url(\".concat(this.renderer.url, \"#\").concat(t.id, \")\") : \"none\");\n        }\n      }, {\n        key: \"crisp\",\n        value: function crisp(t, e) {\n          e = Math.round(e || t.strokeWidth || 0);\n          var i = t.x || this.x || 0,\n            s = t.y || this.y || 0,\n            r = (t.width || this.width || 0) + i,\n            o = (t.height || this.height || 0) + s,\n            n = f(i, e),\n            a = f(s, e);\n          return b(t, {\n            x: n,\n            y: a,\n            width: f(r, e) - n,\n            height: f(o, e) - a\n          }), x(t.strokeWidth) && (t.strokeWidth = e), t;\n        }\n      }, {\n        key: \"complexColor\",\n        value: function complexColor(t, i, s) {\n          var r = this.renderer,\n            o,\n            n,\n            a,\n            h,\n            l,\n            d,\n            c,\n            p,\n            u,\n            g,\n            f = [],\n            m;\n          v(this.renderer, \"complexColor\", {\n            args: arguments\n          }, function () {\n            if (t.radialGradient ? n = \"radialGradient\" : t.linearGradient && (n = \"linearGradient\"), n) {\n              if (a = t[n], l = r.gradients, d = t.stops, u = s.radialReference, S(a) && (t[n] = a = {\n                x1: a[0],\n                y1: a[1],\n                x2: a[2],\n                y2: a[3],\n                gradientUnits: \"userSpaceOnUse\"\n              }), \"radialGradient\" === n && u && !x(a.gradientUnits) && (h = a, a = w(a, r.getRadialAttr(u, h), {\n                gradientUnits: \"userSpaceOnUse\"\n              })), A(a, function (t, e) {\n                \"id\" !== e && f.push(e, t);\n              }), A(d, function (t) {\n                f.push(t);\n              }), l[f = f.join(\",\")]) g = l[f].attr(\"id\");else {\n                a.id = g = E();\n                var _t18 = l[f] = r.createElement(n).attr(a).add(r.defs);\n                _t18.radAttr = h, _t18.stops = [], d.forEach(function (i) {\n                  0 === i[1].indexOf(\"rgba\") ? (c = (o = e.parse(i[1])).get(\"rgb\"), p = o.get(\"a\")) : (c = i[1], p = 1);\n                  var s = r.createElement(\"stop\").attr({\n                    offset: i[0],\n                    \"stop-color\": c,\n                    \"stop-opacity\": p\n                  }).add(_t18);\n                  _t18.stops.push(s);\n                });\n              }\n              m = \"url(\" + r.url + \"#\" + g + \")\", s.setAttribute(i, m), s.gradient = f, t.toString = function () {\n                return m;\n              };\n            }\n          });\n        }\n      }, {\n        key: \"css\",\n        value: function css(t) {\n          var e = this.styles,\n            i = {},\n            s = this.element,\n            r,\n            o = !e;\n          if (e && A(t, function (t, s) {\n            e && e[s] !== t && (i[s] = t, o = !0);\n          }), o) {\n            e && (t = b(e, i)), null === t.width || \"auto\" === t.width ? delete this.textWidth : \"text\" === s.nodeName.toLowerCase() && t.width && (r = this.textWidth = P(t.width)), b(this.styles, t), r && !l && this.renderer.forExport && delete t.width;\n            var _o8 = w(t);\n            s.namespaceURI === this.SVG_NS && ([\"textOutline\", \"textOverflow\", \"width\"].forEach(function (t) {\n              return _o8 && delete _o8[t];\n            }), _o8.color && (_o8.fill = _o8.color)), m(s, _o8);\n          }\n          return this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;\n        }\n      }, {\n        key: \"dashstyleSetter\",\n        value: function dashstyleSetter(t) {\n          var e,\n            i = this[\"stroke-width\"];\n          if (\"inherit\" === i && (i = 1), t = t && t.toLowerCase()) {\n            var _s13 = t.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n            for (e = _s13.length; e--;) _s13[e] = \"\" + P(_s13[e]) * T(i, NaN);\n            t = _s13.join(\",\").replace(/NaN/g, \"none\"), this.element.setAttribute(\"stroke-dasharray\", t);\n          }\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var _t$connector;\n          var t = this,\n            e = t.element || {},\n            i = t.renderer,\n            s = e.ownerSVGElement,\n            r = \"SPAN\" === e.nodeName && t.parentGroup || void 0,\n            o,\n            a;\n          if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, n(t), t.clipPath && s) {\n            var _e12 = t.clipPath;\n            [].forEach.call(s.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (t) {\n              t.getAttribute(\"clip-path\").indexOf(_e12.element.id) > -1 && t.removeAttribute(\"clip-path\");\n            }), t.clipPath = _e12.destroy();\n          }\n          if (t.connector = (_t$connector = t.connector) === null || _t$connector === void 0 ? void 0 : _t$connector.destroy(), t.stops) {\n            for (a = 0; a < t.stops.length; a++) t.stops[a].destroy();\n            t.stops.length = 0, t.stops = void 0;\n          }\n          for (t.safeRemoveChild(e); r && r.div && 0 === r.div.childNodes.length;) o = r.parentGroup, t.safeRemoveChild(r.div), delete r.div, r = o;\n          t.alignOptions && y(i.alignedObjects, t), A(t, function (e, i) {\n            t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i];\n          });\n        }\n      }, {\n        key: \"dSetter\",\n        value: function dSetter(t, e, i) {\n          S(t) && (\"string\" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce(function (t, e, i) {\n            return e && e.join ? (i ? t + \" \" : \"\") + e.join(\" \") : (e || \"\").toString();\n          }, \"\")), /(NaN| {2}|^$)/.test(t) && (t = \"M 0 0\"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter(t, e, i) {\n          \"string\" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);\n        }\n      }, {\n        key: \"hrefSetter\",\n        value: function hrefSetter(t, e, i) {\n          i.setAttributeNS(\"http://www.w3.org/1999/xlink\", e, t);\n        }\n      }, {\n        key: \"getBBox\",\n        value: function getBBox(t, e) {\n          var i, s, r, o;\n          var n = this.alignValue,\n            a = this.element,\n            h = this.renderer,\n            l = this.styles,\n            d = this.textStr,\n            c = h.cache,\n            p = h.cacheKeys,\n            u = a.namespaceURI === this.SVG_NS,\n            g = T(e, this.rotation, 0),\n            f = h.styledMode ? a && I.prototype.getStyle.call(a, \"font-size\") : l.fontSize;\n          if (x(d) && (-1 === (o = d.toString()).indexOf(\"<\") && (o = o.replace(/\\d/g, \"0\")), o += [\"\", h.rootFontSize, f, g, this.textWidth, n, l.textOverflow, l.fontWeight].join(\",\")), o && !t && (i = c[o]), !i || i.polygon) {\n            if (u || h.forExport) {\n              try {\n                r = this.fakeTS && function (t) {\n                  var e = a.querySelector(\".highcharts-text-outline\");\n                  e && m(e, {\n                    display: t\n                  });\n                }, C(r) && r(\"none\"), i = a.getBBox ? b({}, a.getBBox()) : {\n                  width: a.offsetWidth,\n                  height: a.offsetHeight,\n                  x: 0,\n                  y: 0\n                }, C(r) && r(\"\");\n              } catch (t) {}\n              (!i || i.width < 0) && (i = {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n              });\n            } else i = this.htmlGetBBox();\n            s = i.height, u && (i.height = s = {\n              \"11px,17\": 14,\n              \"13px,20\": 16\n            }[\"\".concat(f || \"\", \",\").concat(Math.round(s))] || s), g && (i = this.getRotatedBox(i, g));\n            var _t19 = {\n              bBox: i\n            };\n            v(this, \"afterGetBBox\", _t19), i = _t19.bBox;\n          }\n          if (o && (\"\" === d || i.height > 0)) {\n            for (; p.length > 250;) delete c[p.shift()];\n            c[o] || p.push(o), c[o] = i;\n          }\n          return i;\n        }\n      }, {\n        key: \"getRotatedBox\",\n        value: function getRotatedBox(t, e) {\n          var i = t.x,\n            s = t.y,\n            r = t.width,\n            o = t.height,\n            n = this.alignValue,\n            h = this.translateY,\n            _this$rotationOriginX = this.rotationOriginX,\n            l = _this$rotationOriginX === void 0 ? 0 : _this$rotationOriginX,\n            _this$rotationOriginY = this.rotationOriginY,\n            d = _this$rotationOriginY === void 0 ? 0 : _this$rotationOriginY,\n            c = {\n              right: 1,\n              center: .5\n            }[n || 0] || 0,\n            p = Number(this.element.getAttribute(\"y\") || 0) - (h ? 0 : s),\n            u = e * a,\n            g = (e - 90) * a,\n            f = Math.cos(u),\n            m = Math.sin(u),\n            x = r * f,\n            y = r * m,\n            b = Math.cos(g),\n            v = Math.sin(g),\n            _map = [l, d].map(function (t) {\n              return [t - t * f, t * m];\n            }),\n            _map2 = _slicedToArray(_map, 2),\n            _map2$ = _slicedToArray(_map2[0], 2),\n            S = _map2$[0],\n            C = _map2$[1],\n            _map2$2 = _slicedToArray(_map2[1], 2),\n            k = _map2$2[0],\n            M = _map2$2[1],\n            w = i + c * (r - x) + S + M + p * b,\n            A = w + x,\n            T = A - o * b,\n            P = T - x,\n            L = s + p - c * y - C + k + p * v,\n            O = L + y,\n            D = O - o * v,\n            E = D - y,\n            _I = Math.min(w, A, T, P),\n            j = Math.min(L, O, D, E),\n            B = Math.max(w, A, T, P) - _I,\n            R = Math.max(L, O, D, E) - j;\n          return {\n            x: _I,\n            y: j,\n            width: B,\n            height: R,\n            polygon: [[w, L], [A, O], [T, D], [P, E]]\n          };\n        }\n      }, {\n        key: \"getStyle\",\n        value: function getStyle(t) {\n          return c.getComputedStyle(this.element || this, \"\").getPropertyValue(t);\n        }\n      }, {\n        key: \"hasClass\",\n        value: function hasClass(t) {\n          return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(t);\n        }\n      }, {\n        key: \"hide\",\n        value: function hide() {\n          return this.attr({\n            visibility: \"hidden\"\n          });\n        }\n      }, {\n        key: \"htmlGetBBox\",\n        value: function htmlGetBBox() {\n          return {\n            height: 0,\n            width: 0,\n            x: 0,\n            y: 0\n          };\n        }\n      }, {\n        key: \"on\",\n        value: function on(t, e) {\n          var i = this.onEvents;\n          return i[t] && i[t](), i[t] = p(this.element, t, e), this;\n        }\n      }, {\n        key: \"opacitySetter\",\n        value: function opacitySetter(t, e, i) {\n          var s = Number(Number(t).toFixed(3));\n          this.opacity = s, i.setAttribute(e, s);\n        }\n      }, {\n        key: \"reAlign\",\n        value: function reAlign() {\n          var _this$alignOptions;\n          ((_this$alignOptions = this.alignOptions) === null || _this$alignOptions === void 0 ? void 0 : _this$alignOptions.width) && \"left\" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = !1, this.align());\n        }\n      }, {\n        key: \"removeClass\",\n        value: function removeClass(t) {\n          return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(M(t) ? RegExp(\"(^| )\".concat(t, \"( |$)\")) : t, \" \").replace(/ +/g, \" \").trim());\n        }\n      }, {\n        key: \"removeTextOutline\",\n        value: function removeTextOutline() {\n          var t = this.element.querySelector(\"tspan.highcharts-text-outline\");\n          t && this.safeRemoveChild(t);\n        }\n      }, {\n        key: \"safeRemoveChild\",\n        value: function safeRemoveChild(t) {\n          var e = t.parentNode;\n          e && e.removeChild(t);\n        }\n      }, {\n        key: \"setRadialReference\",\n        value: function setRadialReference(t) {\n          var e = this.element.gradient && this.renderer.gradients[this.element.gradient];\n          return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;\n        }\n      }, {\n        key: \"shadow\",\n        value: function shadow(t) {\n          var _this$parentGroup;\n          var e = this.renderer,\n            i = w(((_this$parentGroup = this.parentGroup) === null || _this$parentGroup === void 0 ? void 0 : _this$parentGroup.rotation) === 90 ? {\n              offsetX: -1,\n              offsetY: -1\n            } : {}, k(t) ? t : {}),\n            s = e.shadowDefinition(i);\n          return this.attr({\n            filter: t ? \"url(\".concat(e.url, \"#\").concat(s, \")\") : \"none\"\n          });\n        }\n      }, {\n        key: \"show\",\n        value: function show() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n          return this.attr({\n            visibility: t ? \"inherit\" : \"visible\"\n          });\n        }\n      }, {\n        key: \"stroke-widthSetter\",\n        value: function strokeWidthSetter(t, e, i) {\n          this[e] = t, i.setAttribute(e, t);\n        }\n      }, {\n        key: \"strokeWidth\",\n        value: function strokeWidth() {\n          if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n          var t = this.getStyle(\"stroke-width\"),\n            e = 0,\n            i;\n          return /px$/.test(t) ? e = P(t) : \"\" !== t && (u(i = h.createElementNS(d, \"rect\"), {\n            width: t,\n            \"stroke-width\": 0\n          }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;\n        }\n      }, {\n        key: \"symbolAttr\",\n        value: function symbolAttr(t) {\n          var e = this;\n          I.symbolCustomAttribs.forEach(function (i) {\n            e[i] = T(t[i], e[i]);\n          }), e.attr({\n            d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)\n          });\n        }\n      }, {\n        key: \"textSetter\",\n        value: function textSetter(t) {\n          t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this), this.reAlign());\n        }\n      }, {\n        key: \"titleSetter\",\n        value: function titleSetter(t) {\n          var e = this.element,\n            i = e.getElementsByTagName(\"title\")[0] || h.createElementNS(this.SVG_NS, \"title\");\n          e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = O(T(t, \"\"), [/<[^>]*>/g, \"\"]).replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n        }\n      }, {\n        key: \"toFront\",\n        value: function toFront() {\n          var t = this.element;\n          return t.parentNode.appendChild(t), this;\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(t, e) {\n          return this.attr({\n            translateX: t,\n            translateY: e\n          });\n        }\n      }, {\n        key: \"updateTransform\",\n        value: function updateTransform() {\n          var _this$text;\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"transform\";\n          var e = this.element,\n            i = this.matrix,\n            _this$rotation = this.rotation,\n            s = _this$rotation === void 0 ? 0 : _this$rotation,\n            r = this.rotationOriginX,\n            o = this.rotationOriginY,\n            n = this.scaleX,\n            a = this.scaleY,\n            _this$translateX = this.translateX,\n            h = _this$translateX === void 0 ? 0 : _this$translateX,\n            _this$translateY = this.translateY,\n            l = _this$translateY === void 0 ? 0 : _this$translateY,\n            d = [\"translate(\" + h + \",\" + l + \")\"];\n          x(i) && d.push(\"matrix(\" + i.join(\",\") + \")\"), s && (d.push(\"rotate(\" + s + \" \" + T(r, e.getAttribute(\"x\"), 0) + \" \" + T(o, e.getAttribute(\"y\") || 0) + \")\"), ((_this$text = this.text) === null || _this$text === void 0 ? void 0 : _this$text.element.tagName) === \"SPAN\" && this.text.attr({\n            rotation: s,\n            rotationOriginX: (r || 0) - this.padding,\n            rotationOriginY: (o || 0) - this.padding\n          })), (x(n) || x(a)) && d.push(\"scale(\" + T(n, 1) + \" \" + T(a, 1) + \")\"), d.length && !(this.text || this).textPath && e.setAttribute(t, d.join(\" \"));\n        }\n      }, {\n        key: \"visibilitySetter\",\n        value: function visibilitySetter(t, e, i) {\n          \"inherit\" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;\n        }\n      }, {\n        key: \"xGetter\",\n        value: function xGetter(t) {\n          return \"circle\" === this.element.nodeName && (\"x\" === t ? t = \"cx\" : \"y\" === t && (t = \"cy\")), this._defaultGetter(t);\n        }\n      }, {\n        key: \"zIndexSetter\",\n        value: function zIndexSetter(t, e) {\n          var i = this.renderer,\n            s = this.parentGroup,\n            r = (s || i).element || i.box,\n            o = this.element,\n            n = r === i.box,\n            a,\n            h,\n            l,\n            d = !1,\n            c,\n            p = this.added,\n            u;\n          if (x(t) ? (o.setAttribute(\"data-z-index\", t), t = +t, this[e] === t && (p = !1)) : x(this[e]) && o.removeAttribute(\"data-z-index\"), this[e] = t, p) {\n            for ((t = this.zIndex) && s && (s.handleZ = !0), u = (a = r.childNodes).length - 1; u >= 0 && !d; u--) c = !x(l = (h = a[u]).getAttribute(\"data-z-index\")), h !== o && (t < 0 && c && !n && !u ? (r.insertBefore(o, a[u]), d = !0) : (P(l) <= t || c && (!x(t) || t >= 0)) && (r.insertBefore(o, a[u + 1]), d = !0));\n            d || (r.insertBefore(o, a[n ? 3 : 0]), d = !0);\n          }\n          return d;\n        }\n      }]);\n    }();\n    return I.symbolCustomAttribs = [\"anchorX\", \"anchorY\", \"clockwise\", \"end\", \"height\", \"innerR\", \"r\", \"start\", \"width\", \"x\", \"y\"], I.prototype.strokeSetter = I.prototype.fillSetter, I.prototype.yGetter = I.prototype.xGetter, I.prototype.matrixSetter = I.prototype.rotationOriginXSetter = I.prototype.rotationOriginYSetter = I.prototype.rotationSetter = I.prototype.scaleXSetter = I.prototype.scaleYSetter = I.prototype.translateXSetter = I.prototype.translateYSetter = I.prototype.verticalAlignSetter = function (t, e) {\n      this[e] = t, this.doTransform = !0;\n    }, I;\n  }), i(e, \"Core/Renderer/SVG/SVGLabel.js\", [e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.defined,\n      s = e.extend,\n      r = e.isNumber,\n      o = e.merge,\n      n = e.pick,\n      a = e.removeEvent;\n    var h = /*#__PURE__*/function (_t20) {\n      function h(t, e, i, s, r, o, n, a, l, d) {\n        var _this2;\n        _classCallCheck(this, h);\n        var c;\n        _this2 = _callSuper(this, h, [t, \"g\"]), _this2.paddingLeftSetter = _this2.paddingSetter, _this2.paddingRightSetter = _this2.paddingSetter, _this2.doUpdate = !1, _this2.textStr = e, _this2.x = i, _this2.y = s, _this2.anchorX = o, _this2.anchorY = n, _this2.baseline = l, _this2.className = d, _this2.addClass(\"button\" === d ? \"highcharts-no-tooltip\" : \"highcharts-label\"), d && _this2.addClass(\"highcharts-\" + d), _this2.text = t.text(void 0, 0, 0, a).attr({\n          zIndex: 1\n        }), \"string\" == typeof r && ((c = /^url\\((.*?)\\)$/.test(r)) || _this2.renderer.symbols[r]) && (_this2.symbolKey = r), _this2.bBox = h.emptyBBox, _this2.padding = 3, _this2.baselineOffset = 0, _this2.needsBox = t.styledMode || c, _this2.deferredAttr = {}, _this2.alignFactor = 0;\n        return _this2;\n      }\n      _inherits(h, _t20);\n      return _createClass(h, [{\n        key: \"alignSetter\",\n        value: function alignSetter(t) {\n          var e = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[t];\n          e !== this.alignFactor && (this.alignFactor = e, this.bBox && r(this.xSetting) && this.attr({\n            x: this.xSetting\n          }));\n        }\n      }, {\n        key: \"anchorXSetter\",\n        value: function anchorXSetter(t, e) {\n          this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);\n        }\n      }, {\n        key: \"anchorYSetter\",\n        value: function anchorYSetter(t, e) {\n          this.anchorY = t, this.boxAttr(e, t - this.ySetting);\n        }\n      }, {\n        key: \"boxAttr\",\n        value: function boxAttr(t, e) {\n          this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;\n        }\n      }, {\n        key: \"css\",\n        value: function css(e) {\n          if (e) {\n            var _t21 = {};\n            e = o(e), h.textProps.forEach(function (i) {\n              void 0 !== e[i] && (_t21[i] = e[i], delete e[i]);\n            }), this.text.css(_t21), \"fontSize\" in _t21 || \"fontWeight\" in _t21 ? this.updateTextPadding() : (\"width\" in _t21 || \"textOverflow\" in _t21) && this.updateBoxSize();\n          }\n          return t.prototype.css.call(this, e);\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          a(this.element, \"mouseenter\"), a(this.element, \"mouseleave\"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), t.prototype.destroy.call(this);\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter(t, e) {\n          t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);\n        }\n      }, {\n        key: \"getBBox\",\n        value: function getBBox(t, e) {\n          this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n          var i = this.padding,\n            _this$height = this.height,\n            s = _this$height === void 0 ? 0 : _this$height,\n            _this$translateX2 = this.translateX,\n            r = _this$translateX2 === void 0 ? 0 : _this$translateX2,\n            _this$translateY2 = this.translateY,\n            o = _this$translateY2 === void 0 ? 0 : _this$translateY2,\n            _this$width = this.width,\n            a = _this$width === void 0 ? 0 : _this$width,\n            _h3 = n(this.paddingLeft, i),\n            l = e !== null && e !== void 0 ? e : this.rotation || 0,\n            d = {\n              width: a,\n              height: s,\n              x: r + this.bBox.x - _h3,\n              y: o + this.bBox.y - i + this.baselineOffset\n            };\n          return l && (d = this.getRotatedBox(d, l)), d;\n        }\n      }, {\n        key: \"getCrispAdjust\",\n        value: function getCrispAdjust() {\n          return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n        }\n      }, {\n        key: \"heightSetter\",\n        value: function heightSetter(t) {\n          this.heightSetting = t, this.doUpdate = !0;\n        }\n      }, {\n        key: \"afterSetters\",\n        value: function afterSetters() {\n          _superPropGet(h, \"afterSetters\", this, 3)([]), this.doUpdate && (this.updateBoxSize(), this.doUpdate = !1);\n        }\n      }, {\n        key: \"onAdd\",\n        value: function onAdd() {\n          this.text.add(this), this.attr({\n            text: n(this.textStr, \"\"),\n            x: this.x || 0,\n            y: this.y || 0\n          }), this.box && i(this.anchorX) && this.attr({\n            anchorX: this.anchorX,\n            anchorY: this.anchorY\n          });\n        }\n      }, {\n        key: \"paddingSetter\",\n        value: function paddingSetter(t, e) {\n          r(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;\n        }\n      }, {\n        key: \"rSetter\",\n        value: function rSetter(t, e) {\n          this.boxAttr(e, t);\n        }\n      }, {\n        key: \"strokeSetter\",\n        value: function strokeSetter(t, e) {\n          this.stroke = t, this.boxAttr(e, t);\n        }\n      }, {\n        key: \"stroke-widthSetter\",\n        value: function strokeWidthSetter(t, e) {\n          t && (this.needsBox = !0), this[\"stroke-width\"] = t, this.boxAttr(e, t);\n        }\n      }, {\n        key: \"text-alignSetter\",\n        value: function textAlignSetter(t) {\n          this.textAlign = t;\n        }\n      }, {\n        key: \"textSetter\",\n        value: function textSetter(t) {\n          void 0 !== t && this.text.attr({\n            text: t\n          }), this.updateTextPadding(), this.reAlign();\n        }\n      }, {\n        key: \"updateBoxSize\",\n        value: function updateBoxSize() {\n          var t;\n          var e = this.text,\n            o = {},\n            n = this.padding,\n            a = this.bBox = (!r(this.widthSetting) || !r(this.heightSetting) || this.textAlign) && i(e.textStr) ? e.getBBox(void 0, 0) : h.emptyBBox;\n          this.width = this.getPaddedWidth(), this.height = (this.heightSetting || a.height || 0) + 2 * n;\n          var l = this.renderer.fontMetrics(e);\n          if (this.baselineOffset = n + Math.min((this.text.firstLineMetrics || l).b, a.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2), this.needsBox && !e.textPath) {\n            if (!this.box) {\n              var _t22 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();\n              _t22.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), _t22.add(this);\n            }\n            t = this.getCrispAdjust(), o.x = t, o.y = (this.baseline ? -this.baselineOffset : 0) + t, o.width = Math.round(this.width), o.height = Math.round(this.height), this.box.attr(s(o, this.deferredAttr)), this.deferredAttr = {};\n          }\n        }\n      }, {\n        key: \"updateTextPadding\",\n        value: function updateTextPadding() {\n          var t = this.text;\n          if (!t.textPath) {\n            this.updateBoxSize();\n            var _e13 = this.baseline ? 0 : this.baselineOffset,\n              _s14 = n(this.paddingLeft, this.padding);\n            i(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (_s14 += {\n              center: .5,\n              right: 1\n            }[this.textAlign] * (this.widthSetting - this.bBox.width)), (_s14 !== t.x || _e13 !== t.y) && (t.attr(\"x\", _s14), t.hasBoxWidthChanged && (this.bBox = t.getBBox(!0)), void 0 !== _e13 && t.attr(\"y\", _e13)), t.x = _s14, t.y = _e13;\n          }\n        }\n      }, {\n        key: \"widthSetter\",\n        value: function widthSetter(t) {\n          this.widthSetting = r(t) ? t : void 0, this.doUpdate = !0;\n        }\n      }, {\n        key: \"getPaddedWidth\",\n        value: function getPaddedWidth() {\n          var t = this.padding,\n            e = n(this.paddingLeft, t),\n            i = n(this.paddingRight, t);\n          return (this.widthSetting || this.bBox.width || 0) + e + i;\n        }\n      }, {\n        key: \"xSetter\",\n        value: function xSetter(t) {\n          this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0), this.xSetting = Math.round(t), this.attr(\"translateX\", this.xSetting);\n        }\n      }, {\n        key: \"ySetter\",\n        value: function ySetter(t) {\n          this.ySetting = this.y = Math.round(t), this.attr(\"translateY\", this.ySetting);\n        }\n      }]);\n    }(t);\n    return h.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    }, h.textProps = [\"color\", \"direction\", \"fontFamily\", \"fontSize\", \"fontStyle\", \"fontWeight\", \"lineHeight\", \"textAlign\", \"textDecoration\", \"textOutline\", \"textOverflow\", \"whiteSpace\", \"width\"], h;\n  }), i(e, \"Core/Renderer/SVG/Symbols.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e = t.defined,\n      i = t.isNumber,\n      s = t.pick;\n    function r(t, i, r, o, n) {\n      var a = [];\n      if (n) {\n        var h = n.start || 0,\n          l = s(n.r, r),\n          d = s(n.r, o || r),\n          c = 2e-4 / (n.borderRadius ? 1 : Math.max(l, 1)),\n          _p2 = Math.abs((n.end || 0) - h - 2 * Math.PI) < c,\n          u = (n.end || 0) - (_p2 ? c : 0),\n          g = n.innerR,\n          f = s(n.open, _p2),\n          m = Math.cos(h),\n          x = Math.sin(h),\n          y = Math.cos(u),\n          b = Math.sin(u),\n          v = s(n.longArc, u - h - Math.PI < c ? 0 : 1),\n          S = [\"A\", l, d, 0, v, s(n.clockwise, 1), t + l * y, i + d * b];\n        S.params = {\n          start: h,\n          end: u,\n          cx: t,\n          cy: i\n        }, a.push([\"M\", t + l * m, i + d * x], S), e(g) && ((S = [\"A\", g, g, 0, v, e(n.clockwise) ? 1 - n.clockwise : 0, t + g * m, i + g * x]).params = {\n          start: u,\n          end: h,\n          cx: t,\n          cy: i\n        }, a.push(f ? [\"M\", t + g * y, i + g * b] : [\"L\", t + g * y, i + g * b], S)), f || a.push([\"Z\"]);\n      }\n      return a;\n    }\n    function o(t, e, i, s, r) {\n      return r && r.r ? n(t, e, i, s, r) : [[\"M\", t, e], [\"L\", t + i, e], [\"L\", t + i, e + s], [\"L\", t, e + s], [\"Z\"]];\n    }\n    function n(t, e, i, s, r) {\n      var o = (r === null || r === void 0 ? void 0 : r.r) || 0;\n      return [[\"M\", t + o, e], [\"L\", t + i - o, e], [\"A\", o, o, 0, 0, 1, t + i, e + o], [\"L\", t + i, e + s - o], [\"A\", o, o, 0, 0, 1, t + i - o, e + s], [\"L\", t + o, e + s], [\"A\", o, o, 0, 0, 1, t, e + s - o], [\"L\", t, e + o], [\"A\", o, o, 0, 0, 1, t + o, e], [\"Z\"]];\n    }\n    return {\n      arc: r,\n      callout: function callout(t, e, s, r, o) {\n        var a = Math.min(o && o.r || 0, s, r),\n          h = a + 6,\n          l = o && o.anchorX,\n          d = o && o.anchorY || 0,\n          c = n(t, e, s, r, {\n            r: a\n          });\n        if (!i(l) || l < s && l > 0 && d < r && d > 0) return c;\n        if (t + l > s - h) {\n          if (d > e + h && d < e + r - h) c.splice(3, 1, [\"L\", t + s, d - 6], [\"L\", t + s + 6, d], [\"L\", t + s, d + 6], [\"L\", t + s, e + r - a]);else if (l < s) {\n            var _i16 = d < e + h,\n              _o9 = _i16 ? e : e + r;\n            c.splice(_i16 ? 2 : 5, 0, [\"L\", l, d], [\"L\", t + s - a, _o9]);\n          } else c.splice(3, 1, [\"L\", t + s, r / 2], [\"L\", l, d], [\"L\", t + s, r / 2], [\"L\", t + s, e + r - a]);\n        } else if (t + l < h) {\n          if (d > e + h && d < e + r - h) c.splice(7, 1, [\"L\", t, d + 6], [\"L\", t - 6, d], [\"L\", t, d - 6], [\"L\", t, e + a]);else if (l > 0) {\n            var _i17 = d < e + h,\n              _s15 = _i17 ? e : e + r;\n            c.splice(_i17 ? 1 : 6, 0, [\"L\", l, d], [\"L\", t + a, _s15]);\n          } else c.splice(7, 1, [\"L\", t, r / 2], [\"L\", l, d], [\"L\", t, r / 2], [\"L\", t, e + a]);\n        } else d > r && l < s - h ? c.splice(5, 1, [\"L\", l + 6, e + r], [\"L\", l, e + r + 6], [\"L\", l - 6, e + r], [\"L\", t + a, e + r]) : d < 0 && l > h && c.splice(1, 1, [\"L\", l - 6, e], [\"L\", l, e - 6], [\"L\", l + 6, e], [\"L\", s - a, e]);\n        return c;\n      },\n      circle: function circle(t, e, i, s) {\n        return r(t + i / 2, e + s / 2, i / 2, s / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function diamond(t, e, i, s) {\n        return [[\"M\", t + i / 2, e], [\"L\", t + i, e + s / 2], [\"L\", t + i / 2, e + s], [\"L\", t, e + s / 2], [\"Z\"]];\n      },\n      rect: o,\n      roundedRect: n,\n      square: o,\n      triangle: function triangle(t, e, i, s) {\n        return [[\"M\", t + i / 2, e], [\"L\", t + i, e + s], [\"L\", t, e + s], [\"Z\"]];\n      },\n      \"triangle-down\": function triangleDown(t, e, i, s) {\n        return [[\"M\", t, e], [\"L\", t + i, e], [\"L\", t + i / 2, e + s], [\"Z\"]];\n      }\n    };\n  }), i(e, \"Core/Renderer/SVG/TextBuilder.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.doc,\n      r = e.SVG_NS,\n      o = e.win,\n      n = i.attr,\n      a = i.extend,\n      h = i.fireEvent,\n      l = i.isString,\n      d = i.objectEach,\n      c = i.pick;\n    return /*#__PURE__*/function () {\n      function _class(t) {\n        _classCallCheck(this, _class);\n        var e = t.styles;\n        this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e && e.lineHeight, this.textOutline = e && e.textOutline, this.ellipsis = !!(e && \"ellipsis\" === e.textOverflow), this.noWrap = !!(e && \"nowrap\" === e.whiteSpace);\n      }\n      return _createClass(_class, [{\n        key: \"buildSVG\",\n        value: function buildSVG() {\n          var e = this.svgElement,\n            i = e.element,\n            r = e.renderer,\n            o = c(e.textStr, \"\").toString(),\n            n = -1 !== o.indexOf(\"<\"),\n            a = i.childNodes,\n            h = !e.added && r.box,\n            d = [o, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, e.getStyle(\"font-size\"), this.width].join(\",\");\n          if (d !== e.textCache) {\n            e.textCache = d, delete e.actualWidth;\n            for (var _t23 = a.length; _t23--;) i.removeChild(a[_t23]);\n            if (n || this.ellipsis || this.width || e.textPath || -1 !== o.indexOf(\" \") && (!this.noWrap || /<br.*?>/g.test(o))) {\n              if (\"\" !== o) {\n                h && h.appendChild(i);\n                var _s16 = new t(o);\n                this.modifyTree(_s16.nodes), _s16.addToDOM(i), this.modifyDOM(), this.ellipsis && -1 !== (i.textContent || \"\").indexOf(\"…\") && e.attr(\"title\", this.unescapeEntities(e.textStr || \"\", [\"&lt;\", \"&gt;\"])), h && h.removeChild(i);\n              }\n            } else i.appendChild(s.createTextNode(this.unescapeEntities(o)));\n            l(this.textOutline) && e.applyTextOutline && e.applyTextOutline(this.textOutline);\n          }\n        }\n      }, {\n        key: \"modifyDOM\",\n        value: function modifyDOM() {\n          var _this3 = this;\n          var t;\n          var e = this.svgElement,\n            i = n(e.element, \"x\");\n          for (e.firstLineMetrics = void 0; t = e.element.firstChild;) if (/^[\\s\\u200B]*$/.test(t.textContent || \" \")) e.element.removeChild(t);else break;\n          [].forEach.call(e.element.querySelectorAll(\"tspan.highcharts-br\"), function (t, s) {\n            t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), n(t, {\n              dy: _this3.getLineHeight(t.nextSibling),\n              x: i\n            }));\n          });\n          var a = this.width || 0;\n          if (!a) return;\n          var h = function h(t, o) {\n              var h = t.textContent || \"\",\n                l = h.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                d = !_this3.noWrap && (l.length > 1 || e.element.childNodes.length > 1),\n                c = _this3.getLineHeight(o),\n                p = 0,\n                u = e.actualWidth;\n              if (_this3.ellipsis) h && _this3.truncate(t, h, void 0, 0, Math.max(0, a - .8 * c), function (t, e) {\n                return t.substring(0, e) + \"…\";\n              });else if (d) {\n                var _h4 = [],\n                  _d = [];\n                for (; o.firstChild && o.firstChild !== t;) _d.push(o.firstChild), o.removeChild(o.firstChild);\n                for (; l.length;) l.length && !_this3.noWrap && p > 0 && (_h4.push(t.textContent || \"\"), t.textContent = l.join(\" \").replace(/- /g, \"-\")), _this3.truncate(t, void 0, l, 0 === p && u || 0, a, function (t, e) {\n                  return l.slice(0, e).join(\" \").replace(/- /g, \"-\");\n                }), u = e.actualWidth, p++;\n                _d.forEach(function (e) {\n                  o.insertBefore(e, t);\n                }), _h4.forEach(function (e) {\n                  o.insertBefore(s.createTextNode(e), t);\n                  var a = s.createElementNS(r, \"tspan\");\n                  a.textContent = \"​\", n(a, {\n                    dy: c,\n                    x: i\n                  }), o.insertBefore(a, t);\n                });\n              }\n            },\n            _l4 = function l(t) {\n              [].slice.call(t.childNodes).forEach(function (i) {\n                i.nodeType === o.Node.TEXT_NODE ? h(i, t) : (-1 !== i.className.baseVal.indexOf(\"highcharts-br\") && (e.actualWidth = 0), _l4(i));\n              });\n            };\n          _l4(e.element);\n        }\n      }, {\n        key: \"getLineHeight\",\n        value: function getLineHeight(t) {\n          var e = t.nodeType === o.Node.TEXT_NODE ? t.parentElement : t;\n          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;\n        }\n      }, {\n        key: \"modifyTree\",\n        value: function modifyTree(t) {\n          var _this4 = this;\n          var _e15 = function e(i, s) {\n            var _i$attributes = i.attributes,\n              r = _i$attributes === void 0 ? {} : _i$attributes,\n              o = i.children,\n              _i$style = i.style,\n              n = _i$style === void 0 ? {} : _i$style,\n              h = i.tagName,\n              l = _this4.renderer.styledMode;\n            if (\"b\" === h || \"strong\" === h ? l ? r[\"class\"] = \"highcharts-strong\" : n.fontWeight = \"bold\" : (\"i\" === h || \"em\" === h) && (l ? r[\"class\"] = \"highcharts-emphasized\" : n.fontStyle = \"italic\"), n && n.color && (n.fill = n.color), \"br\" === h) {\n              r[\"class\"] = \"highcharts-br\", i.textContent = \"​\";\n              var _e14 = t[s + 1];\n              _e14 && _e14.textContent && (_e14.textContent = _e14.textContent.replace(/^ +/gm, \"\"));\n            } else \"a\" === h && o && o.some(function (t) {\n              return \"#text\" === t.tagName;\n            }) && (i.children = [{\n              children: o,\n              tagName: \"tspan\"\n            }]);\n            \"#text\" !== h && \"a\" !== h && (i.tagName = \"tspan\"), a(i, {\n              attributes: r,\n              style: n\n            }), o && o.filter(function (t) {\n              return \"#text\" !== t.tagName;\n            }).forEach(_e15);\n          };\n          t.forEach(_e15), h(this.svgElement, \"afterModifyTree\", {\n            nodes: t\n          });\n        }\n      }, {\n        key: \"truncate\",\n        value: function truncate(t, e, i, s, r, o) {\n          var n, a;\n          var h = this.svgElement,\n            l = h.rotation,\n            d = [],\n            c = i ? 1 : 0,\n            p = (e || i || \"\").length,\n            u = p,\n            g = function g(e, r) {\n              var o = r || e,\n                n = t.parentNode;\n              if (n && void 0 === d[o] && n.getSubStringLength) try {\n                d[o] = s + n.getSubStringLength(0, i ? o + 1 : o);\n              } catch (t) {}\n              return d[o];\n            };\n          if (h.rotation = 0, s + (a = g(t.textContent.length)) > r) {\n            for (; c <= p;) u = Math.ceil((c + p) / 2), i && (n = o(i, u)), a = g(u, n && n.length - 1), c === p ? c = p + 1 : a > r ? p = u - 1 : c = u;\n            0 === p ? t.textContent = \"\" : e && p === e.length - 1 || (t.textContent = n || o(e || i, u));\n          }\n          i && i.splice(0, u), h.actualWidth = a, h.rotation = l;\n        }\n      }, {\n        key: \"unescapeEntities\",\n        value: function unescapeEntities(t, e) {\n          return d(this.renderer.escapes, function (i, s) {\n            e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, \"g\"), s));\n          }), t;\n        }\n      }]);\n    }();\n  }), i(e, \"Core/Renderer/SVG/SVGRenderer.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Defaults.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Renderer/SVG/SVGLabel.js\"], e[\"Core/Renderer/SVG/Symbols.js\"], e[\"Core/Renderer/SVG/TextBuilder.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a, h, l) {\n    var d;\n    var c = e.defaultOptions,\n      p = s.charts,\n      u = s.deg2rad,\n      g = s.doc,\n      f = s.isFirefox,\n      m = s.isMS,\n      x = s.isWebKit,\n      y = s.noop,\n      b = s.SVG_NS,\n      v = s.symbolSizes,\n      S = s.win,\n      C = l.addEvent,\n      k = l.attr,\n      M = l.createElement,\n      w = l.crisp,\n      A = l.css,\n      T = l.defined,\n      P = l.destroyObjectProperties,\n      L = l.extend,\n      O = l.isArray,\n      D = l.isNumber,\n      E = l.isObject,\n      I = l.isString,\n      j = l.merge,\n      B = l.pick,\n      R = l.pInt,\n      z = l.replaceNested,\n      N = l.uniqueKey;\n    var W = /*#__PURE__*/function () {\n      function W(t, e, i, s, r, o, n) {\n        _classCallCheck(this, W);\n        var a, h;\n        var l = this.createElement(\"svg\").attr({\n            version: \"1.1\",\n            \"class\": \"highcharts-root\"\n          }),\n          d = l.element;\n        n || l.css(this.getStyle(s || {})), t.appendChild(d), k(t, \"dir\", \"ltr\"), -1 === t.innerHTML.indexOf(\"xmlns\") && k(d, \"xmlns\", this.SVG_NS), this.box = d, this.boxWrapper = l, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement(\"desc\").add().element.appendChild(g.createTextNode(\"Created with Highcharts 11.4.7\")), this.defs = this.createElement(\"defs\").add(), this.allowHTML = o, this.forExport = r, this.styledMode = n, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l.getStyle(\"font-size\"), this.setSize(e, i, !1), f && t.getBoundingClientRect && ((a = function a() {\n          A(t, {\n            left: 0,\n            top: 0\n          }), h = t.getBoundingClientRect(), A(t, {\n            left: Math.ceil(h.left) - h.left + \"px\",\n            top: Math.ceil(h.top) - h.top + \"px\"\n          });\n        })(), this.unSubPixelFix = C(S, \"resize\", a));\n      }\n      return _createClass(W, [{\n        key: \"definition\",\n        value: function definition(e) {\n          return new t([e]).addToDOM(this.defs.element);\n        }\n      }, {\n        key: \"getReferenceURL\",\n        value: function getReferenceURL() {\n          if ((f || x) && g.getElementsByTagName(\"base\").length) {\n            if (!T(d)) {\n              var _e16 = N(),\n                _i18 = new t([{\n                  tagName: \"svg\",\n                  attributes: {\n                    width: 8,\n                    height: 8\n                  },\n                  children: [{\n                    tagName: \"defs\",\n                    children: [{\n                      tagName: \"clipPath\",\n                      attributes: {\n                        id: _e16\n                      },\n                      children: [{\n                        tagName: \"rect\",\n                        attributes: {\n                          width: 4,\n                          height: 4\n                        }\n                      }]\n                    }]\n                  }, {\n                    tagName: \"rect\",\n                    attributes: {\n                      id: \"hitme\",\n                      width: 8,\n                      height: 8,\n                      \"clip-path\": \"url(#\".concat(_e16, \")\"),\n                      fill: \"rgba(0,0,0,0.001)\"\n                    }\n                  }]\n                }]).addToDOM(g.body);\n              A(_i18, {\n                position: \"fixed\",\n                top: 0,\n                left: 0,\n                zIndex: 9e5\n              });\n              var _s17 = g.elementFromPoint(6, 6);\n              d = \"hitme\" === (_s17 && _s17.id), g.body.removeChild(_i18);\n            }\n            if (d) return z(S.location.href.split(\"#\")[0], [/<[^>]*>/g, \"\"], [/([\\('\\)])/g, \"\\\\$1\"], [/ /g, \"%20\"]);\n          }\n          return \"\";\n        }\n      }, {\n        key: \"getStyle\",\n        value: function getStyle(t) {\n          return this.style = L({\n            fontFamily: \"Helvetica, Arial, sans-serif\",\n            fontSize: \"1rem\"\n          }, t), this.style;\n        }\n      }, {\n        key: \"setStyle\",\n        value: function setStyle(t) {\n          this.boxWrapper.css(this.getStyle(t));\n        }\n      }, {\n        key: \"isHidden\",\n        value: function isHidden() {\n          return !this.boxWrapper.getBBox().width;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var t = this.defs;\n          return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), P(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;\n        }\n      }, {\n        key: \"createElement\",\n        value: function createElement(t) {\n          return new this.Element(this, t);\n        }\n      }, {\n        key: \"getRadialAttr\",\n        value: function getRadialAttr(t, e) {\n          return {\n            cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],\n            cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],\n            r: (e.r || 0) * t[2]\n          };\n        }\n      }, {\n        key: \"shadowDefinition\",\n        value: function shadowDefinition(t) {\n          var e = [\"highcharts-drop-shadow-\".concat(this.chartIndex)].concat(_toConsumableArray(Object.keys(t).map(function (e) {\n              return \"\".concat(e, \"-\").concat(t[e]);\n            }))).join(\"-\").toLowerCase().replace(/[^a-z\\d\\-]/g, \"\"),\n            i = j({\n              color: \"#000000\",\n              offsetX: 1,\n              offsetY: 1,\n              opacity: .15,\n              width: 5\n            }, t);\n          return this.defs.element.querySelector(\"#\".concat(e)) || this.definition({\n            tagName: \"filter\",\n            attributes: {\n              id: e,\n              filterUnits: i.filterUnits\n            },\n            children: this.getShadowFilterContent(i)\n          }), e;\n        }\n      }, {\n        key: \"getShadowFilterContent\",\n        value: function getShadowFilterContent(t) {\n          return [{\n            tagName: \"feDropShadow\",\n            attributes: {\n              dx: t.offsetX,\n              dy: t.offsetY,\n              \"flood-color\": t.color,\n              \"flood-opacity\": Math.min(5 * t.opacity, 1),\n              stdDeviation: t.width / 2\n            }\n          }];\n        }\n      }, {\n        key: \"buildText\",\n        value: function buildText(t) {\n          new h(t).buildSVG();\n        }\n      }, {\n        key: \"getContrast\",\n        value: function getContrast(t) {\n          var e = i.parse(t).rgba.map(function (t) {\n              var e = t / 255;\n              return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);\n            }),\n            s = .2126 * e[0] + .7152 * e[1] + .0722 * e[2];\n          return 1.05 / (s + .05) > (s + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n        }\n      }, {\n        key: \"button\",\n        value: function button(e, i, s, r) {\n          var o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n          var n = arguments.length > 5 ? arguments[5] : undefined;\n          var a = arguments.length > 6 ? arguments[6] : undefined;\n          var h = arguments.length > 7 ? arguments[7] : undefined;\n          var l = arguments.length > 8 ? arguments[8] : undefined;\n          var d = arguments.length > 9 ? arguments[9] : undefined;\n          var p = this.label(e, i, s, l, void 0, void 0, d, void 0, \"button\"),\n            u = this.styledMode,\n            g = arguments,\n            f = 0;\n          o = j(c.global.buttonTheme, o), u && (delete o.fill, delete o.stroke, delete o[\"stroke-width\"]);\n          var x = o.states || {},\n            y = o.style || {};\n          delete o.states, delete o.style;\n          var b = [t.filterUserAttributes(o)],\n            v = [y];\n          return u || [\"hover\", \"select\", \"disabled\"].forEach(function (e, i) {\n            b.push(j(b[0], t.filterUserAttributes(g[i + 5] || x[e] || {}))), v.push(b[i + 1].style), delete b[i + 1].style;\n          }), C(p.element, m ? \"mouseover\" : \"mouseenter\", function () {\n            3 !== f && p.setState(1);\n          }), C(p.element, m ? \"mouseout\" : \"mouseleave\", function () {\n            3 !== f && p.setState(f);\n          }), p.setState = function () {\n            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            if (1 !== t && (p.state = f = t), p.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][t]), !u) {\n              p.attr(b[t]);\n              var _e17 = v[t];\n              E(_e17) && p.css(_e17);\n            }\n          }, p.attr(b[0]), !u && (p.css(L({\n            cursor: \"default\"\n          }, y)), d && p.text.css({\n            pointerEvents: \"none\"\n          })), p.on(\"touchstart\", function (t) {\n            return t.stopPropagation();\n          }).on(\"click\", function (t) {\n            3 !== f && r.call(p, t);\n          });\n        }\n      }, {\n        key: \"crispLine\",\n        value: function crispLine(t, e) {\n          var _t24 = _slicedToArray(t, 2),\n            i = _t24[0],\n            s = _t24[1];\n          return T(i[1]) && i[1] === s[1] && (i[1] = s[1] = w(i[1], e)), T(i[2]) && i[2] === s[2] && (i[2] = s[2] = w(i[2], e)), t;\n        }\n      }, {\n        key: \"path\",\n        value: function path(t) {\n          var e = this.styledMode ? {} : {\n            fill: \"none\"\n          };\n          return O(t) ? e.d = t : E(t) && L(e, t), this.createElement(\"path\").attr(e);\n        }\n      }, {\n        key: \"circle\",\n        value: function circle(t, e, i) {\n          var s = E(t) ? t : void 0 === t ? {} : {\n              x: t,\n              y: e,\n              r: i\n            },\n            r = this.createElement(\"circle\");\n          return r.xSetter = r.ySetter = function (t, e, i) {\n            i.setAttribute(\"c\" + e, t);\n          }, r.attr(s);\n        }\n      }, {\n        key: \"arc\",\n        value: function arc(t, e, i, s, r, o) {\n          var n;\n          E(t) ? (e = (n = t).y, i = n.r, s = n.innerR, r = n.start, o = n.end, t = n.x) : n = {\n            innerR: s,\n            start: r,\n            end: o\n          };\n          var a = this.symbol(\"arc\", t, e, i, i, n);\n          return a.r = i, a;\n        }\n      }, {\n        key: \"rect\",\n        value: function rect(t, e, i, s, r, o) {\n          var n = E(t) ? t : void 0 === t ? {} : {\n              x: t,\n              y: e,\n              r: r,\n              width: Math.max(i || 0, 0),\n              height: Math.max(s || 0, 0)\n            },\n            a = this.createElement(\"rect\");\n          return this.styledMode || (void 0 !== o && (n[\"stroke-width\"] = o, L(n, a.crisp(n))), n.fill = \"none\"), a.rSetter = function (t, e, i) {\n            a.r = t, k(i, {\n              rx: t,\n              ry: t\n            });\n          }, a.rGetter = function () {\n            return a.r || 0;\n          }, a.attr(n);\n        }\n      }, {\n        key: \"roundedRect\",\n        value: function roundedRect(t) {\n          return this.symbol(\"roundedRect\").attr(t);\n        }\n      }, {\n        key: \"setSize\",\n        value: function setSize(t, e, i) {\n          this.width = t, this.height = e, this.boxWrapper.animate({\n            width: t,\n            height: e\n          }, {\n            step: function step() {\n              this.attr({\n                viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n              });\n            },\n            duration: B(i, !0) ? void 0 : 0\n          }), this.alignElements();\n        }\n      }, {\n        key: \"g\",\n        value: function g(t) {\n          var e = this.createElement(\"g\");\n          return t ? e.attr({\n            \"class\": \"highcharts-\" + t\n          }) : e;\n        }\n      }, {\n        key: \"image\",\n        value: function image(t, e, i, s, r, o) {\n          var n = {\n            preserveAspectRatio: \"none\"\n          };\n          D(e) && (n.x = e), D(i) && (n.y = i), D(s) && (n.width = s), D(r) && (n.height = r);\n          var a = this.createElement(\"image\").attr(n),\n            h = function h(e) {\n              a.attr({\n                href: t\n              }), o.call(a, e);\n            };\n          if (o) {\n            a.attr({\n              href: \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n            });\n            var _e18 = new S.Image();\n            C(_e18, \"load\", h), _e18.src = t, _e18.complete && h({});\n          } else a.attr({\n            href: t\n          });\n          return a;\n        }\n      }, {\n        key: \"symbol\",\n        value: function symbol(t, e, i, s, r, o) {\n          var n, a, h, l;\n          var d = this,\n            c = /^url\\((.*?)\\)$/,\n            u = c.test(t),\n            f = !u && (this.symbols[t] ? t : \"circle\"),\n            m = f && this.symbols[f];\n          if (m) \"number\" == typeof e && (a = m.call(this.symbols, e || 0, i || 0, s || 0, r || 0, o)), n = this.path(a), d.styledMode || n.attr(\"fill\", \"none\"), L(n, {\n            symbolName: f || void 0,\n            x: e,\n            y: i,\n            width: s,\n            height: r\n          }), o && L(n, o);else if (u) {\n            h = t.match(c)[1];\n            var _s18 = n = this.image(h);\n            _s18.imgwidth = B(o && o.width, v[h] && v[h].width), _s18.imgheight = B(o && o.height, v[h] && v[h].height), l = function l(t) {\n              return t.attr({\n                width: t.width,\n                height: t.height\n              });\n            }, [\"width\", \"height\"].forEach(function (t) {\n              _s18[\"\".concat(t, \"Setter\")] = function (t, e) {\n                this[e] = t;\n                var i = this.alignByTranslate,\n                  s = this.element,\n                  r = this.width,\n                  n = this.height,\n                  a = this.imgwidth,\n                  h = this.imgheight,\n                  l = \"width\" === e ? a : h,\n                  d = 1;\n                o && \"within\" === o.backgroundSize && r && n && a && h ? (d = Math.min(r / a, n / h), k(s, {\n                  width: Math.round(a * d),\n                  height: Math.round(h * d)\n                })) : s && l && s.setAttribute(e, l), !i && a && h && this.translate(((r || 0) - a * d) / 2, ((n || 0) - h * d) / 2);\n              };\n            }), T(e) && _s18.attr({\n              x: e,\n              y: i\n            }), _s18.isImg = !0, T(_s18.imgwidth) && T(_s18.imgheight) ? l(_s18) : (_s18.attr({\n              width: 0,\n              height: 0\n            }), M(\"img\", {\n              onload: function onload() {\n                var t = p[d.chartIndex];\n                0 === this.width && (A(this, {\n                  position: \"absolute\",\n                  top: \"-999em\"\n                }), g.body.appendChild(this)), v[h] = {\n                  width: this.width,\n                  height: this.height\n                }, _s18.imgwidth = this.width, _s18.imgheight = this.height, _s18.element && l(_s18), this.parentNode && this.parentNode.removeChild(this), d.imgCount--, d.imgCount || !t || t.hasLoaded || t.onload();\n              },\n              src: h\n            }), this.imgCount++);\n          }\n          return n;\n        }\n      }, {\n        key: \"clipRect\",\n        value: function clipRect(t, e, i, s) {\n          return this.rect(t, e, i, s, 0);\n        }\n      }, {\n        key: \"text\",\n        value: function text(t, e, i, s) {\n          var r = {};\n          if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);\n          r.x = Math.round(e || 0), i && (r.y = Math.round(i)), T(t) && (r.text = t);\n          var o = this.createElement(\"text\").attr(r);\n          return s && (!this.forExport || this.allowHTML) || (o.xSetter = function (t, e, i) {\n            var s = i.getElementsByTagName(\"tspan\"),\n              r = i.getAttribute(e);\n            for (var _i19 = 0, _o10; _i19 < s.length; _i19++) (_o10 = s[_i19]).getAttribute(e) === r && _o10.setAttribute(e, t);\n            i.setAttribute(e, t);\n          }), o;\n        }\n      }, {\n        key: \"fontMetrics\",\n        value: function fontMetrics(t) {\n          var e = R(o.prototype.getStyle.call(t, \"font-size\") || 0),\n            i = e < 24 ? e + 3 : Math.round(1.2 * e),\n            s = Math.round(.8 * i);\n          return {\n            h: i,\n            b: s,\n            f: e\n          };\n        }\n      }, {\n        key: \"rotCorr\",\n        value: function rotCorr(t, e, i) {\n          var s = t;\n          return e && i && (s = Math.max(s * Math.cos(e * u), 4)), {\n            x: -t / 3 * Math.sin(e * u),\n            y: s\n          };\n        }\n      }, {\n        key: \"pathToSegments\",\n        value: function pathToSegments(t) {\n          var e = [],\n            i = [],\n            s = {\n              A: 8,\n              C: 7,\n              H: 2,\n              L: 3,\n              M: 3,\n              Q: 5,\n              S: 5,\n              T: 3,\n              V: 2\n            };\n          for (var _r5 = 0; _r5 < t.length; _r5++) I(i[0]) && D(t[_r5]) && i.length === s[i[0].toUpperCase()] && t.splice(_r5, 0, i[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" == typeof t[_r5] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[_r5]);\n          return e.push(i.slice(0)), e;\n        }\n      }, {\n        key: \"label\",\n        value: function label(t, e, i, s, r, o, a, h, l) {\n          return new n(this, t, e, i, s, r, o, a, h, l);\n        }\n      }, {\n        key: \"alignElements\",\n        value: function alignElements() {\n          this.alignedObjects.forEach(function (t) {\n            return t.align();\n          });\n        }\n      }]);\n    }();\n    return L(W.prototype, {\n      Element: o,\n      SVG_NS: b,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: a,\n      draw: y\n    }), r.registerRendererType(\"svg\", W, !0), W;\n  }), i(e, \"Core/Renderer/HTML/HTMLElement.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r = e.composed,\n      o = s.attr,\n      n = s.css,\n      a = s.createElement,\n      h = s.defined,\n      l = s.extend,\n      d = s.pInt,\n      c = s.pushUnique;\n    function p(t, e, s) {\n      var _this$div;\n      var r = ((_this$div = this.div) === null || _this$div === void 0 ? void 0 : _this$div.style) || s.style;\n      i.prototype[\"\".concat(e, \"Setter\")].call(this, t, e, s), r && (r[e] = t);\n    }\n    var u = function u(t, e) {\n      if (!t.div) {\n        var _t$parentGroup;\n        var _s19 = o(t.element, \"class\"),\n          _r6 = t.css,\n          _n4 = a(\"div\", _s19 ? {\n            className: _s19\n          } : void 0, _objectSpread(_objectSpread({\n            position: \"absolute\",\n            left: \"\".concat(t.translateX || 0, \"px\"),\n            top: \"\".concat(t.translateY || 0, \"px\")\n          }, t.styles), {}, {\n            display: t.display,\n            opacity: t.opacity,\n            visibility: t.visibility\n          }), ((_t$parentGroup = t.parentGroup) === null || _t$parentGroup === void 0 ? void 0 : _t$parentGroup.div) || e);\n        t.classSetter = function (t, e, i) {\n          i.setAttribute(\"class\", t), _n4.className = t;\n        }, t.translateXSetter = t.translateYSetter = function (e, i) {\n          t[i] = e, _n4.style[\"translateX\" === i ? \"left\" : \"top\"] = \"\".concat(e, \"px\"), t.doTransform = !0;\n        }, t.opacitySetter = t.visibilitySetter = p, t.css = function (e) {\n          return _r6.call(t, e), e.cursor && (_n4.style.cursor = e.cursor), e.pointerEvents && (_n4.style.pointerEvents = e.pointerEvents), t;\n        }, t.on = function () {\n          return i.prototype.on.apply({\n            element: _n4,\n            onEvents: t.onEvents\n          }, arguments), t;\n        }, t.div = _n4;\n      }\n      return t.div;\n    };\n    var g = /*#__PURE__*/function (_i20) {\n      function g(t, e) {\n        var _this5;\n        _classCallCheck(this, g);\n        _this5 = _callSuper(this, g, [t, e]), _this5.css(_objectSpread({\n          position: \"absolute\"\n        }, t.styledMode ? {} : {\n          fontFamily: t.style.fontFamily,\n          fontSize: t.style.fontSize\n        })), _this5.element.style.whiteSpace = \"nowrap\";\n        return _this5;\n      }\n      _inherits(g, _i20);\n      return _createClass(g, [{\n        key: \"getSpanCorrection\",\n        value: function getSpanCorrection(t, e, i) {\n          this.xCorr = -t * i, this.yCorr = -e;\n        }\n      }, {\n        key: \"css\",\n        value: function css(t) {\n          var e;\n          var i = this.element,\n            s = \"SPAN\" === i.tagName && t && \"width\" in t,\n            r = s && t.width;\n          return s && (delete t.width, this.textWidth = d(r) || void 0, e = !0), (t === null || t === void 0 ? void 0 : t.textOverflow) === \"ellipsis\" && (t.whiteSpace = \"nowrap\", t.overflow = \"hidden\"), l(this.styles, t), n(i, t), e && this.updateTransform(), this;\n        }\n      }, {\n        key: \"htmlGetBBox\",\n        value: function htmlGetBBox() {\n          var t = this.element;\n          return {\n            x: t.offsetLeft,\n            y: t.offsetTop,\n            width: t.offsetWidth,\n            height: t.offsetHeight\n          };\n        }\n      }, {\n        key: \"updateTransform\",\n        value: function updateTransform() {\n          if (!this.added) {\n            this.alignOnAdd = !0;\n            return;\n          }\n          var t = this.element,\n            e = this.renderer,\n            i = this.rotation,\n            s = this.rotationOriginX,\n            r = this.rotationOriginY,\n            o = this.styles,\n            _this$textAlign = this.textAlign,\n            a = _this$textAlign === void 0 ? \"left\" : _this$textAlign,\n            l = this.textWidth,\n            _this$translateX3 = this.translateX,\n            d = _this$translateX3 === void 0 ? 0 : _this$translateX3,\n            _this$translateY3 = this.translateY,\n            c = _this$translateY3 === void 0 ? 0 : _this$translateY3,\n            _this$x = this.x,\n            p = _this$x === void 0 ? 0 : _this$x,\n            _this$y = this.y,\n            u = _this$y === void 0 ? 0 : _this$y,\n            _g2 = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[a],\n            f = o.whiteSpace;\n          if (n(t, {\n            marginLeft: \"\".concat(d, \"px\"),\n            marginTop: \"\".concat(c, \"px\")\n          }), \"SPAN\" === t.tagName) {\n            var _this$parentGroup2;\n            var _o11 = [i, a, t.innerHTML, l, this.textAlign].join(\",\"),\n              _d2 = -(((_this$parentGroup2 = this.parentGroup) === null || _this$parentGroup2 === void 0 ? void 0 : _this$parentGroup2.padding) * 1) || 0,\n              _c2,\n              m = !1;\n            if (l !== this.oldTextWidth) {\n              var _e19 = this.textPxLength ? this.textPxLength : (n(t, {\n                  width: \"\",\n                  whiteSpace: f || \"nowrap\"\n                }), t.offsetWidth),\n                _s20 = l || 0;\n              (_s20 > this.oldTextWidth || _e19 > _s20) && (/[ \\-]/.test(t.textContent || t.innerText) || \"ellipsis\" === t.style.textOverflow) && (n(t, {\n                width: _e19 > _s20 || i ? l + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: f || \"normal\"\n              }), this.oldTextWidth = l, m = !0);\n            }\n            this.hasBoxWidthChanged = m, _o11 !== this.cTT && (_c2 = e.fontMetrics(t).b, h(i) && (i !== (this.oldRotation || 0) || a !== this.oldAlign) && this.setSpanRotation(i, _d2, _d2), this.getSpanCorrection(!h(i) && this.textPxLength || t.offsetWidth, _c2, _g2));\n            var _this$xCorr = this.xCorr,\n              x = _this$xCorr === void 0 ? 0 : _this$xCorr,\n              _this$yCorr = this.yCorr,\n              y = _this$yCorr === void 0 ? 0 : _this$yCorr,\n              b = (s !== null && s !== void 0 ? s : p) - x - p - _d2,\n              v = (r !== null && r !== void 0 ? r : u) - y - u - _d2;\n            n(t, {\n              left: \"\".concat(p + x, \"px\"),\n              top: \"\".concat(u + y, \"px\"),\n              transformOrigin: \"\".concat(b, \"px \").concat(v, \"px\")\n            }), this.cTT = _o11, this.oldRotation = i, this.oldAlign = a;\n          }\n        }\n      }, {\n        key: \"setSpanRotation\",\n        value: function setSpanRotation(t, e, i) {\n          n(this.element, {\n            transform: \"rotate(\".concat(t, \"deg)\"),\n            transformOrigin: \"\".concat(e, \"% \").concat(i, \"px\")\n          });\n        }\n      }, {\n        key: \"add\",\n        value: function add(t) {\n          var e;\n          var i = this.renderer.box.parentNode,\n            s = [];\n          if (this.parentGroup = t, t && !(e = t.div)) {\n            var _r7 = t;\n            for (; _r7;) s.push(_r7), _r7 = _r7.parentGroup;\n            var _iterator2 = _createForOfIteratorHelper(s.reverse()),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var _t25 = _step2.value;\n                e = u(_t25, i);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n          return (e || i).appendChild(this.element), this.added = !0, this.alignOnAdd && this.updateTransform(), this;\n        }\n      }, {\n        key: \"textSetter\",\n        value: function textSetter(e) {\n          e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t.setElementHTML(this.element, e !== null && e !== void 0 ? e : \"\"), this.textStr = e, this.doTransform = !0);\n        }\n      }, {\n        key: \"alignSetter\",\n        value: function alignSetter(t) {\n          this.alignValue = this.textAlign = t, this.doTransform = !0;\n        }\n      }, {\n        key: \"xSetter\",\n        value: function xSetter(t, e) {\n          this[e] = t, this.doTransform = !0;\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t) {\n          c(r, this.compose) && (t.prototype.html = function (t, e, i) {\n            return new g(this, \"span\").attr({\n              text: t,\n              x: Math.round(e),\n              y: Math.round(i)\n            });\n          });\n        }\n      }]);\n    }(i);\n    var f = g.prototype;\n    return f.visibilitySetter = f.opacitySetter = p, f.ySetter = f.rotationSetter = f.rotationOriginXSetter = f.rotationOriginYSetter = f.xSetter, g;\n  }), i(e, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var t, e;\n    return (e = t || (t = {})).xAxis = {\n      alignTicks: !0,\n      allowDecimals: void 0,\n      panningEnabled: !0,\n      zIndex: 2,\n      zoomEnabled: !0,\n      dateTimeLabelFormats: {\n        millisecond: {\n          main: \"%H:%M:%S.%L\",\n          range: !1\n        },\n        second: {\n          main: \"%H:%M:%S\",\n          range: !1\n        },\n        minute: {\n          main: \"%H:%M\",\n          range: !1\n        },\n        hour: {\n          main: \"%H:%M\",\n          range: !1\n        },\n        day: {\n          main: \"%e %b\"\n        },\n        week: {\n          main: \"%e %b\"\n        },\n        month: {\n          main: \"%b '%y\"\n        },\n        year: {\n          main: \"%Y\"\n        }\n      },\n      endOnTick: !1,\n      gridLineDashStyle: \"Solid\",\n      gridZIndex: 1,\n      labels: {\n        autoRotationLimit: 80,\n        distance: 15,\n        enabled: !0,\n        indentation: 10,\n        overflow: \"justify\",\n        reserveSpace: void 0,\n        rotation: void 0,\n        staggerLines: 0,\n        step: 0,\n        useHTML: !1,\n        zIndex: 7,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"0.8em\"\n        }\n      },\n      maxPadding: .01,\n      minorGridLineDashStyle: \"Solid\",\n      minorTickLength: 2,\n      minorTickPosition: \"outside\",\n      minorTicksPerMajor: 5,\n      minPadding: .01,\n      offset: void 0,\n      reversed: void 0,\n      reversedStacks: !1,\n      showEmpty: !0,\n      showFirstLabel: !0,\n      showLastLabel: !0,\n      startOfWeek: 1,\n      startOnTick: !1,\n      tickLength: 10,\n      tickPixelInterval: 100,\n      tickmarkPlacement: \"between\",\n      tickPosition: \"outside\",\n      title: {\n        align: \"middle\",\n        useHTML: !1,\n        x: 0,\n        y: 0,\n        style: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        }\n      },\n      type: \"linear\",\n      uniqueNames: !0,\n      visible: !0,\n      minorGridLineColor: \"#f2f2f2\",\n      minorGridLineWidth: 1,\n      minorTickColor: \"#999999\",\n      lineColor: \"#333333\",\n      lineWidth: 1,\n      gridLineColor: \"#e6e6e6\",\n      gridLineWidth: void 0,\n      tickColor: \"#333333\"\n    }, e.yAxis = {\n      reversedStacks: !0,\n      endOnTick: !0,\n      maxPadding: .05,\n      minPadding: .05,\n      tickPixelInterval: 72,\n      showLastLabel: !0,\n      labels: {\n        x: void 0\n      },\n      startOnTick: !0,\n      title: {\n        text: \"Values\"\n      },\n      stackLabels: {\n        animation: {},\n        allowOverlap: !1,\n        enabled: !1,\n        crop: !0,\n        overflow: \"justify\",\n        formatter: function formatter() {\n          var t = this.axis.chart.numberFormatter;\n          return t(this.total || 0, -1);\n        },\n        style: {\n          color: \"#000000\",\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          textOutline: \"1px contrast\"\n        }\n      },\n      gridLineWidth: 1,\n      lineWidth: 0\n    }, t;\n  }), i(e, \"Core/Foundation.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.addEvent,\n      s = t.isFunction,\n      r = t.objectEach,\n      o = t.removeEvent;\n    return (e || (e = {})).registerEventOptions = function (t, e) {\n      t.eventOptions = t.eventOptions || {}, r(e.events, function (e, r) {\n        t.eventOptions[r] !== e && (t.eventOptions[r] && (o(t, r, t.eventOptions[r]), delete t.eventOptions[r]), s(e) && (t.eventOptions[r] = e, i(t, r, e, {\n          order: 0\n        })));\n      });\n    }, e;\n  }), i(e, \"Core/Axis/Tick.js\", [e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.deg2rad,\n      r = i.clamp,\n      o = i.correctFloat,\n      n = i.defined,\n      a = i.destroyObjectProperties,\n      h = i.extend,\n      l = i.fireEvent,\n      d = i.isNumber,\n      c = i.merge,\n      p = i.objectEach,\n      u = i.pick;\n    return /*#__PURE__*/function () {\n      function _class2(t, e, i, s, r) {\n        _classCallCheck(this, _class2);\n        this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || \"\", this.parameters = r || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, l(this, \"init\"), i || s || this.addLabel();\n      }\n      return _createClass(_class2, [{\n        key: \"addLabel\",\n        value: function addLabel() {\n          var e = this,\n            i = e.axis,\n            s = i.options,\n            r = i.chart,\n            a = i.categories,\n            c = i.logarithmic,\n            p = i.names,\n            g = e.pos,\n            f = u(e.options && e.options.labels, s.labels),\n            m = i.tickPositions,\n            x = g === m[0],\n            y = g === m[m.length - 1],\n            b = (!f.step || 1 === f.step) && 1 === i.tickInterval,\n            v = m.info,\n            S = e.label,\n            C,\n            k,\n            M,\n            w = this.parameters.category || (a ? u(a[g], p[g], g) : g);\n          c && d(w) && (w = o(c.lin2log(w))), i.dateTime && (v ? C = (k = r.time.resolveDTLFormat(s.dateTimeLabelFormats[!s.grid && v.higherRanks[g] || v.unitName])).main : d(w) && (C = i.dateTime.getXDateFormat(w, s.dateTimeLabelFormats || {}))), e.isFirst = x, e.isLast = y;\n          var A = {\n            axis: i,\n            chart: r,\n            dateTimeLabelFormat: C,\n            isFirst: x,\n            isLast: y,\n            pos: g,\n            tick: e,\n            tickPositionInfo: v,\n            value: w\n          };\n          l(this, \"labelFormat\", A);\n          var T = function T(e) {\n              return f.formatter ? f.formatter.call(e, e) : f.format ? (e.text = i.defaultLabelFormatter.call(e), t.format(f.format, e, r)) : i.defaultLabelFormatter.call(e);\n            },\n            P = T.call(A, A),\n            L = k && k.list;\n          L ? e.shortenLabel = function () {\n            for (M = 0; M < L.length; M++) if (h(A, {\n              dateTimeLabelFormat: L[M]\n            }), S.attr({\n              text: T.call(A, A)\n            }), S.getBBox().width < i.getSlotWidth(e) - 2 * (f.padding || 0)) return;\n            S.attr({\n              text: \"\"\n            });\n          } : e.shortenLabel = void 0, b && i._addedPlotLB && e.moveLabel(P, f), n(S) || e.movedLabel ? S && S.textStr !== P && !b && (!S.textWidth || f.style.width || S.styles.width || S.css({\n            width: null\n          }), S.attr({\n            text: P\n          }), S.textPxLength = S.getBBox().width) : (e.label = S = e.createLabel(P, f), e.rotation = 0);\n        }\n      }, {\n        key: \"createLabel\",\n        value: function createLabel(t, e, i) {\n          var s = this.axis,\n            r = s.chart,\n            o = n(t) && e.enabled ? r.renderer.text(t, i === null || i === void 0 ? void 0 : i.x, i === null || i === void 0 ? void 0 : i.y, e.useHTML).add(s.labelGroup) : void 0;\n          return o && (r.styledMode || o.css(c(e.style)), o.textPxLength = o.getBBox().width), o;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          a(this, this.axis);\n        }\n      }, {\n        key: \"getPosition\",\n        value: function getPosition(t, e, i, s) {\n          var n = this.axis,\n            a = n.chart,\n            h = s && a.oldChartHeight || a.chartHeight,\n            d = {\n              x: t ? o(n.translate(e + i, void 0, void 0, s) + n.transB) : n.left + n.offset + (n.opposite ? (s && a.oldChartWidth || a.chartWidth) - n.right - n.left : 0),\n              y: t ? h - n.bottom + n.offset - (n.opposite ? n.height : 0) : o(h - n.translate(e + i, void 0, void 0, s) - n.transB)\n            };\n          return d.y = r(d.y, -1e5, 1e5), l(this, \"afterGetPosition\", {\n            pos: d\n          }), d;\n        }\n      }, {\n        key: \"getLabelPosition\",\n        value: function getLabelPosition(t, e, i, r, o, a, h, d) {\n          var c, p;\n          var g = this.axis,\n            f = g.transA,\n            m = g.isLinked && g.linkedParent ? g.linkedParent.reversed : g.reversed,\n            x = g.staggerLines,\n            y = g.tickRotCorr || {\n              x: 0,\n              y: 0\n            },\n            b = r || g.reserveSpaceDefault ? 0 : -g.labelOffset * (\"center\" === g.labelAlign ? .5 : 1),\n            v = o.distance,\n            S = {};\n          return c = 0 === g.side ? i.rotation ? -v : -i.getBBox().height : 2 === g.side ? y.y + v : Math.cos(i.rotation * s) * (y.y - i.getBBox(!1, 0).height / 2), n(o.y) && (c = 0 === g.side && g.horiz ? o.y + c : o.y), t = t + u(o.x, [0, 1, 0, -1][g.side] * v) + b + y.x - (a && r ? a * f * (m ? -1 : 1) : 0), e = e + c - (a && !r ? a * f * (m ? 1 : -1) : 0), x && (p = h / (d || 1) % x, g.opposite && (p = x - p - 1), e += p * (g.labelOffset / x)), S.x = t, S.y = Math.round(e), l(this, \"afterGetLabelPosition\", {\n            pos: S,\n            tickmarkOffset: a,\n            index: h\n          }), S;\n        }\n      }, {\n        key: \"getLabelSize\",\n        value: function getLabelSize() {\n          return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n        }\n      }, {\n        key: \"getMarkPath\",\n        value: function getMarkPath(t, e, i, s) {\n          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n          var o = arguments.length > 5 ? arguments[5] : undefined;\n          return o.crispLine([[\"M\", t, e], [\"L\", t + (r ? 0 : -i), e + (r ? i : 0)]], s);\n        }\n      }, {\n        key: \"handleOverflow\",\n        value: function handleOverflow(t) {\n          var e = this.axis,\n            i = e.options.labels,\n            r = t.x,\n            o = e.chart.chartWidth,\n            n = e.chart.spacing,\n            a = u(e.labelLeft, Math.min(e.pos, n[3])),\n            h = u(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, o - n[1])),\n            l = this.label,\n            d = this.rotation,\n            c = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[e.labelAlign || l.attr(\"align\")],\n            p = l.getBBox().width,\n            g = e.getSlotWidth(this),\n            f = {},\n            m = g,\n            x = 1,\n            y,\n            b,\n            v;\n          d || \"justify\" !== i.overflow ? d < 0 && r - c * p < a ? v = Math.round(r / Math.cos(d * s) - a) : d > 0 && r + c * p > h && (v = Math.round((o - r) / Math.cos(d * s))) : (y = r - c * p, b = r + (1 - c) * p, y < a ? m = t.x + m * (1 - c) - a : b > h && (m = h - t.x + m * c, x = -1), (m = Math.min(g, m)) < g && \"center\" === e.labelAlign && (t.x += x * (g - m - c * (g - Math.min(p, m)))), (p > m || e.autoRotation && (l.styles || {}).width) && (v = m)), v && (this.shortenLabel ? this.shortenLabel() : (f.width = Math.floor(v) + \"px\", (i.style || {}).textOverflow || (f.textOverflow = \"ellipsis\"), l.css(f)));\n        }\n      }, {\n        key: \"moveLabel\",\n        value: function moveLabel(t, e) {\n          var i = this,\n            s = i.label,\n            r = i.axis,\n            o = !1,\n            n;\n          s && s.textStr === t ? (i.movedLabel = s, o = !0, delete i.label) : p(r.ticks, function (e) {\n            o || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, o = !0, e.labelPos = i.movedLabel.xy, delete e.label);\n          }), !o && (i.labelPos || s) && (n = i.labelPos || s.xy, i.movedLabel = i.createLabel(t, e, n), i.movedLabel && i.movedLabel.attr({\n            opacity: 0\n          }));\n        }\n      }, {\n        key: \"render\",\n        value: function render(t, e, i) {\n          var s = this.axis,\n            r = s.horiz,\n            n = this.pos,\n            a = u(this.tickmarkOffset, s.tickmarkOffset),\n            h = this.getPosition(r, n, a, e),\n            d = h.x,\n            c = h.y,\n            p = s.pos,\n            g = p + s.len,\n            f = r ? d : c;\n          !s.chart.polar && this.isNew && (o(f) < p || f > g) && (i = 0);\n          var m = u(i, this.label && this.label.newOpacity, 1);\n          i = u(i, 1), this.isActive = !0, this.renderGridLine(e, i), this.renderMark(h, i), this.renderLabel(h, e, m, t), this.isNew = !1, l(this, \"afterRender\");\n        }\n      }, {\n        key: \"renderGridLine\",\n        value: function renderGridLine(t, e) {\n          var i = this.axis,\n            s = i.options,\n            r = {},\n            o = this.pos,\n            n = this.type,\n            a = u(this.tickmarkOffset, i.tickmarkOffset),\n            h = i.chart.renderer,\n            l = this.gridLine,\n            d,\n            c = s.gridLineWidth,\n            p = s.gridLineColor,\n            g = s.gridLineDashStyle;\n          \"minor\" === this.type && (c = s.minorGridLineWidth, p = s.minorGridLineColor, g = s.minorGridLineDashStyle), l || (i.chart.styledMode || (r.stroke = p, r[\"stroke-width\"] = c || 0, r.dashstyle = g), n || (r.zIndex = 1), t && (e = 0), this.gridLine = l = h.path().attr(r).addClass(\"highcharts-\" + (n ? n + \"-\" : \"\") + \"grid-line\").add(i.gridGroup)), l && (d = i.getPlotLinePath({\n            value: o + a,\n            lineWidth: l.strokeWidth(),\n            force: \"pass\",\n            old: t,\n            acrossPanes: !1\n          })) && l[t || this.isNew ? \"attr\" : \"animate\"]({\n            d: d,\n            opacity: e\n          });\n        }\n      }, {\n        key: \"renderMark\",\n        value: function renderMark(t, e) {\n          var i = this.axis,\n            s = i.options,\n            r = i.chart.renderer,\n            o = this.type,\n            n = i.tickSize(o ? o + \"Tick\" : \"tick\"),\n            a = t.x,\n            h = t.y,\n            l = u(s[\"minor\" !== o ? \"tickWidth\" : \"minorTickWidth\"], !o && i.isXAxis ? 1 : 0),\n            d = s[\"minor\" !== o ? \"tickColor\" : \"minorTickColor\"],\n            c = this.mark,\n            p = !c;\n          n && (i.opposite && (n[0] = -n[0]), c || (this.mark = c = r.path().addClass(\"highcharts-\" + (o ? o + \"-\" : \"\") + \"tick\").add(i.axisGroup), i.chart.styledMode || c.attr({\n            stroke: d,\n            \"stroke-width\": l\n          })), c[p ? \"attr\" : \"animate\"]({\n            d: this.getMarkPath(a, h, n[0], c.strokeWidth(), i.horiz, r),\n            opacity: e\n          }));\n        }\n      }, {\n        key: \"renderLabel\",\n        value: function renderLabel(t, e, i, s) {\n          var r = this.axis,\n            o = r.horiz,\n            n = r.options,\n            a = this.label,\n            h = n.labels,\n            l = h.step,\n            c = u(this.tickmarkOffset, r.tickmarkOffset),\n            p = t.x,\n            g = t.y,\n            f = !0;\n          a && d(p) && (a.xy = t = this.getLabelPosition(p, g, a, o, h, c, s, l), (!this.isFirst || this.isLast || n.showFirstLabel) && (!this.isLast || this.isFirst || n.showLastLabel) ? !o || h.step || h.rotation || e || 0 === i || this.handleOverflow(t) : f = !1, l && s % l && (f = !1), f && d(t.y) ? (t.opacity = i, a[this.isNewLabel ? \"attr\" : \"animate\"](t).show(!0), this.isNewLabel = !1) : (a.hide(), this.isNewLabel = !0));\n        }\n      }, {\n        key: \"replaceMovedLabel\",\n        value: function replaceMovedLabel() {\n          var t = this.label,\n            e = this.axis;\n          t && !this.isNew && (t.animate({\n            opacity: 0\n          }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;\n        }\n      }]);\n    }();\n  }), i(e, \"Core/Axis/Axis.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/AxisDefaults.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Defaults.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Axis/Tick.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a) {\n    var h = t.animObject,\n      l = e.xAxis,\n      d = e.yAxis,\n      c = s.defaultOptions,\n      p = r.registerEventOptions,\n      u = o.deg2rad,\n      g = a.arrayMax,\n      f = a.arrayMin,\n      m = a.clamp,\n      x = a.correctFloat,\n      y = a.defined,\n      b = a.destroyObjectProperties,\n      v = a.erase,\n      S = a.error,\n      C = a.extend,\n      k = a.fireEvent,\n      M = a.getClosestDistance,\n      w = a.insertItem,\n      A = a.isArray,\n      T = a.isNumber,\n      P = a.isString,\n      L = a.merge,\n      O = a.normalizeTickInterval,\n      D = a.objectEach,\n      E = a.pick,\n      I = a.relativeLength,\n      j = a.removeEvent,\n      B = a.splat,\n      R = a.syncTimeout,\n      z = function z(t, e) {\n        return O(e, void 0, void 0, E(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);\n      };\n    C(c, {\n      xAxis: l,\n      yAxis: L(l, d)\n    });\n    var N = /*#__PURE__*/function () {\n      function N(t, e, i) {\n        _classCallCheck(this, N);\n        this.init(t, e, i);\n      }\n      return _createClass(N, [{\n        key: \"init\",\n        value: function init(t, e) {\n          var _this$len;\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.coll;\n          var s = \"xAxis\" === i,\n            r = this.isZAxis || (t.inverted ? !s : s);\n          this.chart = t, this.horiz = r, this.isXAxis = s, this.coll = i, k(this, \"init\", {\n            userOptions: e\n          }), this.opposite = E(e.opposite, this.opposite), this.side = E(e.side, this.side, r ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e);\n          var o = this.options,\n            n = o.labels,\n            a = o.type;\n          this.userOptions = e, this.minPixelPadding = 0, this.reversed = E(o.reversed, this.reversed), this.visible = o.visible, this.zoomEnabled = o.zoomEnabled, this.hasNames = \"category\" === a || !0 === o.categories, this.categories = A(o.categories) && o.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = y(o.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, (_this$len = this.len) !== null && _this$len !== void 0 ? _this$len : this.len = 0, this.minRange = this.userMinRange = o.minRange || o.maxZoom, this.range = o.range, this.offset = o.offset || 0, this.max = void 0, this.min = void 0;\n          var h = E(o.crosshair, B(t.options.tooltip.crosshairs)[s ? 0 : 1]);\n          this.crosshair = !0 === h ? {} : h, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), w(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !y(this.reversed) && (this.reversed = !0), this.labelRotation = T(n.rotation) ? n.rotation : void 0, p(this, o), k(this, \"afterInit\");\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(t) {\n          var e = this.horiz ? {\n            labels: {\n              autoRotation: [-45],\n              padding: 4\n            },\n            margin: 15\n          } : {\n            labels: {\n              padding: 1\n            },\n            title: {\n              rotation: 90 * this.side\n            }\n          };\n          this.options = L(e, c[this.coll], t), k(this, \"afterSetOptions\", {\n            userOptions: t\n          });\n        }\n      }, {\n        key: \"defaultLabelFormatter\",\n        value: function defaultLabelFormatter() {\n          var t = this.axis,\n            e = this.chart.numberFormatter,\n            i = T(this.value) ? this.value : NaN,\n            s = t.chart.time,\n            r = t.categories,\n            o = this.dateTimeLabelFormat,\n            n = c.lang,\n            a = n.numericSymbols,\n            h = n.numericSymbolMagnitude || 1e3,\n            l = t.logarithmic ? Math.abs(i) : t.tickInterval,\n            d = a && a.length,\n            p,\n            u;\n          if (r) u = \"\".concat(this.value);else if (o) u = s.dateFormat(o, i);else if (d && a && l >= 1e3) for (; d-- && void 0 === u;) l >= (p = Math.pow(h, d + 1)) && 10 * i % p == 0 && null !== a[d] && 0 !== i && (u = e(i / p, -1) + a[d]);\n          return void 0 === u && (u = Math.abs(i) >= 1e4 ? e(i, -1) : e(i, -1, void 0, \"\")), u;\n        }\n      }, {\n        key: \"getSeriesExtremes\",\n        value: function getSeriesExtremes() {\n          var t;\n          var e = this;\n          k(this, \"getSeriesExtremes\", null, function () {\n            e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach(function (i) {\n              if (i.reserveSpace()) {\n                var _s21 = i.options,\n                  _r8,\n                  _o12 = _s21.threshold,\n                  _n5,\n                  _a6;\n                if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (_o12 || 0) && (_o12 = void 0), e.isXAxis) (_r8 = i.xData) && _r8.length && (_r8 = e.logarithmic ? _r8.filter(function (t) {\n                  return t > 0;\n                }) : _r8, _n5 = (t = i.getXExtremes(_r8)).min, _a6 = t.max, T(_n5) || _n5 instanceof Date || (_r8 = _r8.filter(T), _n5 = (t = i.getXExtremes(_r8)).min, _a6 = t.max), _r8.length && (e.dataMin = Math.min(E(e.dataMin, _n5), _n5), e.dataMax = Math.max(E(e.dataMax, _a6), _a6)));else {\n                  var _t26 = i.applyExtremes();\n                  T(_t26.dataMin) && (_n5 = _t26.dataMin, e.dataMin = Math.min(E(e.dataMin, _n5), _n5)), T(_t26.dataMax) && (_a6 = _t26.dataMax, e.dataMax = Math.max(E(e.dataMax, _a6), _a6)), y(_o12) && (e.threshold = _o12), (!_s21.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);\n                }\n              }\n            });\n          }), k(this, \"afterGetSeriesExtremes\");\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(t, e, i, s, r, o) {\n          var _n$brokenAxis;\n          var n = this.linkedParent || this,\n            a = s && n.old ? n.old.min : n.min;\n          if (!T(a)) return NaN;\n          var h = n.minPixelPadding,\n            l = (n.isOrdinal || ((_n$brokenAxis = n.brokenAxis) === null || _n$brokenAxis === void 0 ? void 0 : _n$brokenAxis.hasBreaks) || n.logarithmic && r) && n.lin2val,\n            d = 1,\n            c = 0,\n            p = s && n.old ? n.old.transA : n.transA,\n            u = 0;\n          return p || (p = n.transA), i && (d *= -1, c = n.len), n.reversed && (d *= -1, c -= d * (n.sector || n.len)), e ? (u = (t = t * d + c - h) / p + a, l && (u = n.lin2val(u))) : (l && (t = n.val2lin(t)), u = d * (t - a) * p + c + d * h + (T(o) ? p * o : 0), n.isRadial || (u = x(u))), u;\n        }\n      }, {\n        key: \"toPixels\",\n        value: function toPixels(t, e) {\n          return this.translate(t, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);\n        }\n      }, {\n        key: \"toValue\",\n        value: function toValue(t, e) {\n          return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n        }\n      }, {\n        key: \"getPlotLinePath\",\n        value: function getPlotLinePath(t) {\n          var e = this,\n            i = e.chart,\n            s = e.left,\n            r = e.top,\n            o = t.old,\n            n = t.value,\n            a = t.lineWidth,\n            h = o && i.oldChartHeight || i.chartHeight,\n            l = o && i.oldChartWidth || i.chartWidth,\n            d = e.transB,\n            c = t.translatedValue,\n            p = t.force,\n            u,\n            g,\n            f,\n            x,\n            y;\n          function b(t, e, i) {\n            return \"pass\" !== p && (t < e || t > i) && (p ? t = m(t, e, i) : y = !0), t;\n          }\n          var v = {\n            value: n,\n            lineWidth: a,\n            old: o,\n            force: p,\n            acrossPanes: t.acrossPanes,\n            translatedValue: c\n          };\n          return k(this, \"getPlotLinePath\", v, function (t) {\n            u = f = (c = m(c = E(c, e.translate(n, void 0, void 0, o)), -1e5, 1e5)) + d, g = x = h - c - d, T(c) ? e.horiz ? (g = r, x = h - e.bottom + (e.options.isInternal ? 0 : i.scrollablePixelsY || 0), u = f = b(u, s, s + e.width)) : (u = s, f = l - e.right + (i.scrollablePixelsX || 0), g = x = b(g, r, r + e.height)) : (y = !0, p = !1), t.path = y && !p ? void 0 : i.renderer.crispLine([[\"M\", u, g], [\"L\", f, x]], a || 1);\n          }), v.path;\n        }\n      }, {\n        key: \"getLinearTickPositions\",\n        value: function getLinearTickPositions(t, e, i) {\n          var s, r, o;\n          var n = x(Math.floor(e / t) * t),\n            a = x(Math.ceil(i / t) * t),\n            h = [];\n          if (x(n + t) === n && (o = 20), this.single) return [e];\n          for (s = n; s <= a && (h.push(s), (s = x(s + t, o)) !== r);) r = s;\n          return h;\n        }\n      }, {\n        key: \"getMinorTickInterval\",\n        value: function getMinorTickInterval() {\n          var _this$options = this.options,\n            t = _this$options.minorTicks,\n            e = _this$options.minorTickInterval;\n          return !0 === t ? E(e, \"auto\") : !1 !== t ? e : void 0;\n        }\n      }, {\n        key: \"getMinorTickPositions\",\n        value: function getMinorTickPositions() {\n          var t = this.options,\n            e = this.tickPositions,\n            i = this.minorTickInterval,\n            s = this.pointRangePadding || 0,\n            r = (this.min || 0) - s,\n            o = (this.max || 0) + s,\n            n = o - r,\n            a = [],\n            h;\n          if (n && n / i < this.len / 3) {\n            var _s22 = this.logarithmic;\n            if (_s22) this.paddedTicks.forEach(function (t, e, r) {\n              e && a.push.apply(a, _s22.getLogTickPositions(i, r[e - 1], r[e], !0));\n            });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) a = a.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), r, o, t.startOfWeek));else for (h = r + (e[0] - r) % i; h <= o && h !== a[0]; h += i) a.push(h);\n          }\n          return 0 !== a.length && this.trimTicks(a), a;\n        }\n      }, {\n        key: \"adjustForMinRange\",\n        value: function adjustForMinRange() {\n          var t = this.options,\n            e = this.logarithmic,\n            i = this.max,\n            s = this.min,\n            r = this.minRange,\n            o,\n            n,\n            a,\n            h;\n          this.isXAxis && void 0 === r && !e && (r = y(t.min) || y(t.max) || y(t.floor) || y(t.ceiling) ? null : Math.min(5 * (M(this.series.map(function (t) {\n            var _t$xData;\n            return (t.xIncrement ? (_t$xData = t.xData) === null || _t$xData === void 0 ? void 0 : _t$xData.slice(0, 2) : t.xData) || [];\n          })) || 0), this.dataMax - this.dataMin)), T(i) && T(s) && T(r) && i - s < r && (n = this.dataMax - this.dataMin >= r, o = (r - i + s) / 2, a = [s - o, E(t.min, s - o)], n && (a[2] = e ? e.log2lin(this.dataMin) : this.dataMin), h = [(s = g(a)) + r, E(t.max, s + r)], n && (h[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (i = f(h)) - s < r && (a[0] = i - r, a[1] = E(t.min, i - r), s = g(a))), this.minRange = r, this.min = s, this.max = i;\n        }\n      }, {\n        key: \"getClosest\",\n        value: function getClosest() {\n          var t, e;\n          if (this.categories) e = 1;else {\n            var _i21 = [];\n            this.series.forEach(function (t) {\n              var _t$xData2;\n              var s = t.closestPointRange;\n              ((_t$xData2 = t.xData) === null || _t$xData2 === void 0 ? void 0 : _t$xData2.length) === 1 ? _i21.push(t.xData[0]) : !t.noSharedTooltip && y(s) && t.reserveSpace() && (e = y(e) ? Math.min(e, s) : s);\n            }), _i21.length && (_i21.sort(function (t, e) {\n              return t - e;\n            }), t = M([_i21]));\n          }\n          return t && e ? Math.min(t, e) : t || e;\n        }\n      }, {\n        key: \"nameToX\",\n        value: function nameToX(t) {\n          var e = A(this.options.categories),\n            i = e ? this.categories : this.names,\n            s = t.options.x,\n            r;\n          return t.series.requireSorting = !1, y(s) || (s = this.options.uniqueNames && i ? e ? i.indexOf(t.name) : E(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (r = i.length) : r = s, void 0 !== r ? (this.names[r] = t.name, this.names.keys[t.name] = r) : t.x && (r = t.x), r;\n        }\n      }, {\n        key: \"updateNames\",\n        value: function updateNames() {\n          var t = this,\n            e = this.names;\n          e.length > 0 && (Object.keys(e.keys).forEach(function (t) {\n            delete e.keys[t];\n          }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {\n            e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max, e.xData.length - 1), e.processData(), e.generatePoints()), e.data.forEach(function (i, s) {\n              var r;\n              (i === null || i === void 0 ? void 0 : i.options) && void 0 !== i.name && void 0 !== (r = t.nameToX(i)) && r !== i.x && (i.x = r, e.xData[s] = r);\n            });\n          }));\n        }\n      }, {\n        key: \"setAxisTranslation\",\n        value: function setAxisTranslation() {\n          var t = this,\n            e = t.max - t.min,\n            i = t.linkedParent,\n            s = !!t.categories,\n            r = t.isXAxis,\n            o = t.axisPointRange || 0,\n            n,\n            a = 0,\n            h = 0,\n            l,\n            d = t.transA;\n          (r || s || o) && (n = t.getClosest(), i ? (a = i.minPointOffset, h = i.pointRangePadding) : t.series.forEach(function (e) {\n            var i = s ? 1 : r ? E(e.options.pointRange, n, 0) : t.axisPointRange || 0,\n              l = e.options.pointPlacement;\n            if (o = Math.max(o, i), !t.single || s) {\n              var _t27 = e.is(\"xrange\") ? !r : r;\n              a = Math.max(a, _t27 && P(l) ? 0 : i / 2), h = Math.max(h, _t27 && \"on\" === l ? 0 : i);\n            }\n          }), l = t.ordinal && t.ordinal.slope && n ? t.ordinal.slope / n : 1, t.minPointOffset = a *= l, t.pointRangePadding = h *= l, t.pointRange = Math.min(o, t.single && s ? 1 : e), r && n && (t.closestPointRange = n)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + h || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * a, k(this, \"afterSetAxisTranslation\");\n        }\n      }, {\n        key: \"minFromRange\",\n        value: function minFromRange() {\n          var t = this.max,\n            e = this.min;\n          return T(t) && T(e) && t - e || void 0;\n        }\n      }, {\n        key: \"setTickInterval\",\n        value: function setTickInterval(t) {\n          var _i$this$coll;\n          var e = this.categories,\n            i = this.chart,\n            s = this.dataMax,\n            r = this.dataMin,\n            o = this.dateTime,\n            n = this.isXAxis,\n            a = this.logarithmic,\n            h = this.options,\n            l = this.softThreshold,\n            d = T(this.threshold) ? this.threshold : void 0,\n            c = this.minRange || 0,\n            p = h.ceiling,\n            u = h.floor,\n            g = h.linkedTo,\n            f = h.softMax,\n            m = h.softMin,\n            b = T(g) && ((_i$this$coll = i[this.coll]) === null || _i$this$coll === void 0 ? void 0 : _i$this$coll[g]),\n            v = h.tickPixelInterval,\n            C = h.maxPadding,\n            M = h.minPadding,\n            w = 0,\n            A,\n            P = T(h.tickInterval) && h.tickInterval >= 0 ? h.tickInterval : void 0,\n            L,\n            O,\n            D,\n            I;\n          if (o || e || b || this.getTickAmount(), D = E(this.userMin, h.min), I = E(this.userMax, h.max), b ? (this.linkedParent = b, A = b.getExtremes(), this.min = E(A.min, A.dataMin), this.max = E(A.max, A.dataMax), h.type !== b.options.type && S(11, !0, i)) : (l && y(d) && T(s) && T(r) && (r >= d ? (L = d, M = 0) : s <= d && (O = d, C = 0)), this.min = E(D, L, r), this.max = E(I, O, s)), T(this.max) && T(this.min) && (a && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, E(r, this.min)) && S(10, !0, i), this.min = x(a.log2lin(this.min), 16), this.max = x(a.log2lin(this.max), 16)), this.range && T(r) && (this.userMin = this.min = D = Math.max(r, this.minFromRange() || 0), this.userMax = I = this.max, this.range = void 0)), k(this, \"foundExtremes\"), this.adjustForMinRange(), T(this.min) && T(this.max)) {\n            var _this$stacking;\n            if (!T(this.userMin) && T(m) && m < this.min && (this.min = D = m), !T(this.userMax) && T(f) && f > this.max && (this.max = I = f), e || this.axisPointRange || (_this$stacking = this.stacking) !== null && _this$stacking !== void 0 && _this$stacking.usePercentage || b || !(w = this.max - this.min) || (!y(D) && M && (this.min -= w * M), y(I) || !C || (this.max += w * C)), !T(this.userMin) && T(u) && (this.min = Math.max(this.min, u)), !T(this.userMax) && T(p) && (this.max = Math.min(this.max, p)), l && T(r) && T(s)) {\n              var _t28 = d || 0;\n              !y(D) && this.min < _t28 && r >= _t28 ? this.min = h.minRange ? Math.min(_t28, this.max - c) : _t28 : !y(I) && this.max > _t28 && s <= _t28 && (this.max = h.minRange ? Math.max(_t28, this.min + c) : _t28);\n            }\n            !i.polar && this.min > this.max && (y(h.min) ? this.max = this.min : y(h.max) && (this.min = this.max)), w = this.max - this.min;\n          }\n          if (this.min !== this.max && T(this.min) && T(this.max) ? b && !P && v === b.options.tickPixelInterval ? this.tickInterval = P = b.tickInterval : this.tickInterval = E(P, this.tickAmount ? w / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : w * v / Math.max(this.len, v)) : this.tickInterval = 1, n && !t) {\n            var _this$old, _this$old2;\n            var _t29 = this.min !== ((_this$old = this.old) === null || _this$old === void 0 ? void 0 : _this$old.min) || this.max !== ((_this$old2 = this.old) === null || _this$old2 === void 0 ? void 0 : _this$old2.max);\n            this.series.forEach(function (e) {\n              var _e$forceCropping;\n              e.forceCrop = (_e$forceCropping = e.forceCropping) === null || _e$forceCropping === void 0 ? void 0 : _e$forceCropping.call(e), e.processData(_t29);\n            }), k(this, \"postProcessData\", {\n              hasExtremesChanged: _t29\n            });\n          }\n          this.setAxisTranslation(), k(this, \"initialAxisTranslation\"), this.pointRange && !P && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n          var j = E(h.minTickInterval, o && !this.series.some(function (t) {\n            return t.noSharedTooltip;\n          }) ? this.closestPointRange : 0);\n          !P && this.tickInterval < j && (this.tickInterval = j), o || a || P || (this.tickInterval = z(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();\n        }\n      }, {\n        key: \"setTickPositions\",\n        value: function setTickPositions() {\n          var t = this.options,\n            e = t.tickPositions,\n            i = t.tickPositioner,\n            s = this.getMinorTickInterval(),\n            r = !this.isPanning,\n            o = r && t.startOnTick,\n            n = r && t.endOnTick,\n            a = [],\n            h;\n          if (this.tickmarkOffset = this.categories && \"between\" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.minorTickInterval = \"auto\" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.single = this.min === this.max && y(this.min) && !this.tickAmount && (this.min % 1 == 0 || !1 !== t.allowDecimals), e) a = e.slice();else if (T(this.min) && T(this.max)) {\n            var _this$ordinal, _this$ordinal2;\n            if (!((_this$ordinal = this.ordinal) !== null && _this$ordinal !== void 0 && _this$ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) a = [this.min, this.max], S(19, !1, this.chart);else if (this.dateTime) a = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, (_this$ordinal2 = this.ordinal) === null || _this$ordinal2 === void 0 ? void 0 : _this$ordinal2.positions, this.closestPointRange, !0);else if (this.logarithmic) a = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else {\n              var _t30 = this.tickInterval,\n                _e20 = _t30;\n              for (; _e20 <= 2 * _t30;) if (a = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && a.length > this.tickAmount) this.tickInterval = z(this, _e20 *= 1.1);else break;\n            }\n            a.length > this.len && (a = [a[0], a[a.length - 1]])[0] === a[1] && (a.length = 1), i && (this.tickPositions = a, (h = i.apply(this, [this.min, this.max])) && (a = h));\n          }\n          this.tickPositions = a, this.paddedTicks = a.slice(0), this.trimTicks(a, o, n), !this.isLinked && T(this.min) && T(this.max) && (this.single && a.length < 2 && !this.categories && !this.series.some(function (t) {\n            return t.is(\"heatmap\") && \"between\" === t.options.pointPlacement;\n          }) && (this.min -= .5, this.max += .5), e || h || this.adjustTickAmount()), k(this, \"afterSetTickPositions\");\n        }\n      }, {\n        key: \"trimTicks\",\n        value: function trimTicks(t, e, i) {\n          var s = t[0],\n            r = t[t.length - 1],\n            o = !this.isOrdinal && this.minPointOffset || 0;\n          if (k(this, \"trimTicks\"), !this.isLinked) {\n            if (e && s !== -1 / 0) this.min = s;else for (; this.min - o > t[0];) t.shift();\n            if (i) this.max = r;else for (; this.max + o < t[t.length - 1];) t.pop();\n            0 === t.length && y(s) && !this.options.tickPositions && t.push((r + s) / 2);\n          }\n        }\n      }, {\n        key: \"alignToOthers\",\n        value: function alignToOthers() {\n          var t;\n          var e = this,\n            i = e.chart,\n            s = [this],\n            r = e.options,\n            o = i.options.chart,\n            n = \"yAxis\" === this.coll && o.alignThresholds,\n            a = [];\n          if (e.thresholdAlignment = void 0, (!1 !== o.alignTicks && r.alignTicks || n) && !1 !== r.startOnTick && !1 !== r.endOnTick && !e.logarithmic) {\n            var _r9 = function _r9(t) {\n                var e = t.horiz,\n                  i = t.options;\n                return [e ? i.left : i.top, i.width, i.height, i.pane].join(\",\");\n              },\n              _o13 = _r9(this);\n            i[this.coll].forEach(function (i) {\n              var n = i.series;\n              n.length && n.some(function (t) {\n                return t.visible;\n              }) && i !== e && _r9(i) === _o13 && (t = !0, s.push(i));\n            });\n          }\n          if (t && n) {\n            s.forEach(function (t) {\n              var i = t.getThresholdAlignment(e);\n              T(i) && a.push(i);\n            });\n            var _t31 = a.length > 1 ? a.reduce(function (t, e) {\n              return t += e;\n            }, 0) / a.length : void 0;\n            s.forEach(function (e) {\n              e.thresholdAlignment = _t31;\n            });\n          }\n          return t;\n        }\n      }, {\n        key: \"getThresholdAlignment\",\n        value: function getThresholdAlignment(t) {\n          if ((!T(this.dataMin) || this !== t && this.series.some(function (t) {\n            return t.isDirty || t.isDirtyData;\n          })) && this.getSeriesExtremes(), T(this.threshold)) {\n            var _t32 = m((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);\n            return this.options.reversed && (_t32 = 1 - _t32), _t32;\n          }\n        }\n      }, {\n        key: \"getTickAmount\",\n        value: function getTickAmount() {\n          var t = this.options,\n            e = t.tickPixelInterval,\n            i = t.tickAmount;\n          y(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;\n        }\n      }, {\n        key: \"adjustTickAmount\",\n        value: function adjustTickAmount() {\n          var t = this,\n            e = t.finalTickAmt,\n            i = t.max,\n            s = t.min,\n            r = t.options,\n            o = t.tickPositions,\n            n = t.tickAmount,\n            a = t.thresholdAlignment,\n            h = o === null || o === void 0 ? void 0 : o.length,\n            l = E(t.threshold, t.softThreshold ? 0 : null),\n            d,\n            c,\n            p = t.tickInterval,\n            u,\n            g = function g() {\n              return o.push(x(o[o.length - 1] + p));\n            },\n            f = function f() {\n              return o.unshift(x(o[0] - p));\n            };\n          if (T(a) && (u = a < .5 ? Math.ceil(a * (n - 1)) : Math.floor(a * (n - 1)), r.reversed && (u = n - 1 - u)), t.hasData() && T(s) && T(i)) {\n            var _a7 = function _a7() {\n              t.transA *= (h - 1) / (n - 1), t.min = r.startOnTick ? o[0] : Math.min(s, o[0]), t.max = r.endOnTick ? o[o.length - 1] : Math.max(i, o[o.length - 1]);\n            };\n            if (T(u) && T(t.threshold)) {\n              for (; o[u] !== l || o.length !== n || o[0] > s || o[o.length - 1] < i;) {\n                for (o.length = 0, o.push(t.threshold); o.length < n;) void 0 === o[u] || o[u] > t.threshold ? f() : g();\n                if (p > 8 * t.tickInterval) break;\n                p *= 2;\n              }\n              _a7();\n            } else if (h < n) {\n              for (; o.length < n;) o.length % 2 || s === l ? g() : f();\n              _a7();\n            }\n            if (y(e)) {\n              for (c = d = o.length; c--;) (3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && o.splice(c, 1);\n              t.finalTickAmt = void 0;\n            }\n          }\n        }\n      }, {\n        key: \"setScale\",\n        value: function setScale() {\n          var _this$old3, _this$old4;\n          var t = this.coll,\n            e = this.stacking,\n            i = !1,\n            s = !1;\n          this.series.forEach(function (t) {\n            i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis && t.xAxis.isDirty || !1;\n          }), this.setAxisSize();\n          var r = this.len !== (this.old && this.old.len);\n          r || i || s || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e && \"yAxis\" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && \"xAxis\" === t && e.buildStacks(), this.isDirty || (this.isDirty = r || this.min !== ((_this$old3 = this.old) === null || _this$old3 === void 0 ? void 0 : _this$old3.min) || this.max !== ((_this$old4 = this.old) === null || _this$old4 === void 0 ? void 0 : _this$old4.max))) : e && e.cleanStacks(), i && delete this.allExtremes, k(this, \"afterSetScale\");\n        }\n      }, {\n        key: \"setExtremes\",\n        value: function setExtremes(t, e) {\n          var _this6 = this;\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n          var s = arguments.length > 3 ? arguments[3] : undefined;\n          var r = arguments.length > 4 ? arguments[4] : undefined;\n          this.series.forEach(function (t) {\n            delete t.kdTree;\n          }), k(this, \"setExtremes\", r = C(r, {\n            min: t,\n            max: e\n          }), function (t) {\n            _this6.userMin = t.min, _this6.userMax = t.max, _this6.eventArgs = t, i && _this6.chart.redraw(s);\n          });\n        }\n      }, {\n        key: \"setAxisSize\",\n        value: function setAxisSize() {\n          var t = this.chart,\n            e = this.options,\n            i = e.offsets || [0, 0, 0, 0],\n            s = this.horiz,\n            r = this.width = Math.round(I(E(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)),\n            o = this.height = Math.round(I(E(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)),\n            n = this.top = Math.round(I(E(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)),\n            a = this.left = Math.round(I(E(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));\n          this.bottom = t.chartHeight - o - n, this.right = t.chartWidth - r - a, this.len = Math.max(s ? r : o, 0), this.pos = s ? a : n;\n        }\n      }, {\n        key: \"getExtremes\",\n        value: function getExtremes() {\n          var t = this.logarithmic;\n          return {\n            min: t ? x(t.lin2log(this.min)) : this.min,\n            max: t ? x(t.lin2log(this.max)) : this.max,\n            dataMin: this.dataMin,\n            dataMax: this.dataMax,\n            userMin: this.userMin,\n            userMax: this.userMax\n          };\n        }\n      }, {\n        key: \"getThreshold\",\n        value: function getThreshold(t) {\n          var e = this.logarithmic,\n            i = e ? e.lin2log(this.min) : this.min,\n            s = e ? e.lin2log(this.max) : this.max;\n          return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);\n        }\n      }, {\n        key: \"autoLabelAlign\",\n        value: function autoLabelAlign(t) {\n          var e = (E(t, 0) - 90 * this.side + 720) % 360,\n            i = {\n              align: \"center\"\n            };\n          return k(this, \"autoLabelAlign\", i, function (t) {\n            e > 15 && e < 165 ? t.align = \"right\" : e > 195 && e < 345 && (t.align = \"left\");\n          }), i.align;\n        }\n      }, {\n        key: \"tickSize\",\n        value: function tickSize(t) {\n          var e = this.options,\n            i = E(e[\"tick\" === t ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === t && this.isXAxis && !this.categories ? 1 : 0),\n            s = e[\"tick\" === t ? \"tickLength\" : \"minorTickLength\"],\n            r;\n          i && s && (\"inside\" === e[t + \"Position\"] && (s = -s), r = [s, i]);\n          var o = {\n            tickSize: r\n          };\n          return k(this, \"afterTickSize\", o), o.tickSize;\n        }\n      }, {\n        key: \"labelMetrics\",\n        value: function labelMetrics() {\n          var t = this.chart.renderer,\n            e = this.ticks,\n            i = e[Object.keys(e)[0]] || {};\n          return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);\n        }\n      }, {\n        key: \"unsquish\",\n        value: function unsquish() {\n          var t = this.options.labels,\n            e = t.padding || 0,\n            i = this.horiz,\n            s = this.tickInterval,\n            r = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / s),\n            o = t.rotation,\n            n = x(.8 * this.labelMetrics().h),\n            a = Math.max(this.max - this.min, 0),\n            h = function h(t) {\n              var i = (t + 2 * e) / (r || 1);\n              return (i = i > 1 ? Math.ceil(i) : 1) * s > a && t !== 1 / 0 && r !== 1 / 0 && a && (i = Math.ceil(a / s)), x(i * s);\n            },\n            l = s,\n            d,\n            c = Number.MAX_VALUE,\n            p;\n          if (i) {\n            if (!t.staggerLines && (T(o) ? p = [o] : r < t.autoRotationLimit && (p = t.autoRotation)), p) {\n              var _t33, _e21;\n              var _iterator3 = _createForOfIteratorHelper(p),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var _i22 = _step3.value;\n                  (_i22 === o || _i22 && _i22 >= -90 && _i22 <= 90) && (_e21 = (_t33 = h(Math.abs(n / Math.sin(u * _i22)))) + Math.abs(_i22 / 360)) < c && (c = _e21, d = _i22, l = _t33);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n          } else l = h(.75 * n);\n          return this.autoRotation = p, this.labelRotation = E(d, T(o) ? o : 0), t.step ? s : l;\n        }\n      }, {\n        key: \"getSlotWidth\",\n        value: function getSlotWidth(t) {\n          var e = this.chart,\n            i = this.horiz,\n            s = this.options.labels,\n            r = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            o = e.margin[3];\n          if (t && T(t.slotWidth)) return t.slotWidth;\n          if (i && s.step < 2) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / r;\n          if (!i) {\n            var _t34 = s.style.width;\n            if (void 0 !== _t34) return parseInt(String(_t34), 10);\n            if (o) return o - e.spacing[3];\n          }\n          return .33 * e.chartWidth;\n        }\n      }, {\n        key: \"renderUnsquish\",\n        value: function renderUnsquish() {\n          var t = this.chart,\n            e = t.renderer,\n            i = this.tickPositions,\n            s = this.ticks,\n            r = this.options.labels,\n            o = r.style,\n            n = this.horiz,\n            a = this.getSlotWidth(),\n            h = Math.max(1, Math.round(a - (n ? 2 * (r.padding || 0) : r.distance || 0))),\n            l = {},\n            d = this.labelMetrics(),\n            c = o.textOverflow,\n            p,\n            u,\n            g = 0,\n            f,\n            m;\n          if (P(r.rotation) || (l.rotation = r.rotation || 0), i.forEach(function (t) {\n            var e = s[t];\n            e.movedLabel && e.replaceMovedLabel(), e && e.label && e.label.textPxLength > g && (g = e.label.textPxLength);\n          }), this.maxLabelLength = g, this.autoRotation) g > h && g > d.h ? l.rotation = this.labelRotation : this.labelRotation = 0;else if (a && (p = h, !c)) for (u = \"clip\", m = i.length; !n && m--;) (f = s[i[m]].label) && (\"ellipsis\" === f.styles.textOverflow ? f.css({\n            textOverflow: \"clip\"\n          }) : f.textPxLength > a && f.css({\n            width: a + \"px\"\n          }), f.getBBox().height > this.len / i.length - (d.h - d.f) && (f.specificTextOverflow = \"ellipsis\"));\n          l.rotation && (p = g > .5 * t.chartHeight ? .33 * t.chartHeight : g, c || (u = \"ellipsis\")), this.labelAlign = r.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l.align = this.labelAlign), i.forEach(function (t) {\n            var e = s[t],\n              i = e && e.label,\n              r = o.width,\n              n = {};\n            i && (i.attr(l), e.shortenLabel ? e.shortenLabel() : p && !r && \"nowrap\" !== o.whiteSpace && (p < i.textPxLength || \"SPAN\" === i.element.tagName) ? (n.width = p + \"px\", c || (n.textOverflow = i.specificTextOverflow || u), i.css(n)) : !i.styles.width || n.width || r || i.css({\n              width: null\n            }), delete i.specificTextOverflow, e.rotation = l.rotation);\n          }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return this.series.some(function (t) {\n            return t.hasData();\n          }) || this.options.showEmpty && y(this.min) && y(this.max);\n        }\n      }, {\n        key: \"addTitle\",\n        value: function addTitle(t) {\n          var e;\n          var i = this.chart.renderer,\n            s = this.horiz,\n            r = this.opposite,\n            o = this.options.title,\n            n = this.chart.styledMode;\n          this.axisTitle || ((e = o.textAlign) || (e = (s ? {\n            low: \"left\",\n            middle: \"center\",\n            high: \"right\"\n          } : {\n            low: r ? \"right\" : \"left\",\n            middle: \"center\",\n            high: r ? \"left\" : \"right\"\n          })[o.align]), this.axisTitle = i.text(o.text || \"\", 0, 0, o.useHTML).attr({\n            zIndex: 7,\n            rotation: o.rotation || 0,\n            align: e\n          }).addClass(\"highcharts-axis-title\"), n || this.axisTitle.css(L(o.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), n || o.style.width || this.isRadial || this.axisTitle.css({\n            width: this.len + \"px\"\n          }), this.axisTitle[t ? \"show\" : \"hide\"](t);\n        }\n      }, {\n        key: \"generateTick\",\n        value: function generateTick(t) {\n          var e = this.ticks;\n          e[t] ? e[t].addLabel() : e[t] = new n(this, t);\n        }\n      }, {\n        key: \"createGroups\",\n        value: function createGroups() {\n          var _this7 = this;\n          var t = this.axisParent,\n            e = this.chart,\n            i = this.coll,\n            s = this.options,\n            r = e.renderer,\n            o = function o(e, _o14, n) {\n              return r.g(e).attr({\n                zIndex: n\n              }).addClass(\"highcharts-\".concat(i.toLowerCase()).concat(_o14, \" \") + (_this7.isRadial ? \"highcharts-radial-axis\".concat(_o14, \" \") : \"\") + (s.className || \"\")).add(t);\n            };\n          this.axisGroup || (this.gridGroup = o(\"grid\", \"-grid\", s.gridZIndex), this.axisGroup = o(\"axis\", \"\", s.zIndex), this.labelGroup = o(\"axis-labels\", \"-labels\", s.labels.zIndex));\n        }\n      }, {\n        key: \"getOffset\",\n        value: function getOffset() {\n          var t = this,\n            e = t.chart,\n            i = t.horiz,\n            s = t.options,\n            r = t.side,\n            o = t.ticks,\n            n = t.tickPositions,\n            a = t.coll,\n            h = e.inverted && !t.isZAxis ? [1, 0, 3, 2][r] : r,\n            l = t.hasData(),\n            d = s.title,\n            c = s.labels,\n            p = T(s.crossing),\n            u = e.axisOffset,\n            g = e.clipOffset,\n            f = [-1, 1, 1, -1][r],\n            m,\n            x = 0,\n            b,\n            v = 0,\n            S = 0,\n            C,\n            M;\n          if (t.showAxis = m = l || s.showEmpty, t.staggerLines = t.horiz && c.staggerLines || void 0, t.createGroups(), l || t.isLinked ? (n.forEach(function (e) {\n            t.generateTick(e);\n          }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === r || 2 === r || {\n            1: \"left\",\n            3: \"right\"\n          }[r] === t.labelAlign, E(c.reserveSpace, !p && null, \"center\" === t.labelAlign || null, t.reserveSpaceDefault) && n.forEach(function (t) {\n            S = Math.max(o[t].getLabelSize(), S);\n          }), t.staggerLines && (S *= t.staggerLines), t.labelOffset = S * (t.opposite ? -1 : 1)) : D(o, function (t, e) {\n            t.destroy(), delete o[e];\n          }), d !== null && d !== void 0 && d.text && !1 !== d.enabled && (t.addTitle(m), m && !p && !1 !== d.reserveSpace && (t.titleOffset = x = t.axisTitle.getBBox()[i ? \"height\" : \"width\"], v = y(b = d.offset) ? 0 : E(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * E(s.offset, u[r] ? u[r] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {\n            x: 0,\n            y: 0\n          }, M = 0 === r ? -t.labelMetrics().h : 2 === r ? t.tickRotCorr.y : 0, C = Math.abs(S) + v, S && (C -= M, C += f * (i ? E(c.y, t.tickRotCorr.y + f * c.distance) : E(c.x, f * c.distance))), t.axisTitleMargin = E(b, C), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(o, n)), \"colorAxis\" !== a && g) {\n            var _e22 = this.tickSize(\"tick\");\n            u[r] = Math.max(u[r], (t.axisTitleMargin || 0) + x + f * t.offset, C, n && n.length && _e22 ? _e22[0] + f * t.offset : 0);\n            var _i23 = !t.axisLine || s.offset ? 0 : t.axisLine.strokeWidth() / 2;\n            g[h] = Math.max(g[h], _i23);\n          }\n          k(this, \"afterGetOffset\");\n        }\n      }, {\n        key: \"getLinePath\",\n        value: function getLinePath(t) {\n          var e = this.chart,\n            i = this.opposite,\n            s = this.offset,\n            r = this.horiz,\n            o = this.left + (i ? this.width : 0) + s,\n            n = e.chartHeight - this.bottom - (i ? this.height : 0) + s;\n          return i && (t *= -1), e.renderer.crispLine([[\"M\", r ? this.left : o, r ? n : this.top], [\"L\", r ? e.chartWidth - this.right : o, r ? n : e.chartHeight - this.bottom]], t);\n        }\n      }, {\n        key: \"renderLine\",\n        value: function renderLine() {\n          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n            stroke: this.options.lineColor,\n            \"stroke-width\": this.options.lineWidth,\n            zIndex: 7\n          }));\n        }\n      }, {\n        key: \"getTitlePosition\",\n        value: function getTitlePosition(t) {\n          var e = this.horiz,\n            i = this.left,\n            s = this.top,\n            r = this.len,\n            o = this.options.title,\n            n = e ? i : s,\n            a = this.opposite,\n            h = this.offset,\n            l = o.x,\n            d = o.y,\n            c = this.chart.renderer.fontMetrics(t),\n            p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0,\n            u = {\n              low: n + (e ? 0 : r),\n              middle: n + r / 2,\n              high: n + (e ? r : 0)\n            }[o.align],\n            g = (e ? s + this.height : i) + (e ? 1 : -1) * (a ? -1 : 1) * (this.axisTitleMargin || 0) + [-p, p, c.f, -p][this.side],\n            f = {\n              x: e ? u + l : g + (a ? this.width : 0) + h + l,\n              y: e ? g + d - (a ? this.height : 0) + h : u + d\n            };\n          return k(this, \"afterGetTitlePosition\", {\n            titlePosition: f\n          }), f;\n        }\n      }, {\n        key: \"renderMinorTick\",\n        value: function renderMinorTick(t, e) {\n          var i = this.minorTicks;\n          i[t] || (i[t] = new n(this, t, \"minor\")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);\n        }\n      }, {\n        key: \"renderTick\",\n        value: function renderTick(t, e, i) {\n          var s = this.isLinked,\n            r = this.ticks;\n          (!s || t >= this.min && t <= this.max || this.grid && this.grid.isColumn) && (r[t] || (r[t] = new n(this, t)), i && r[t].isNew && r[t].render(e, !0, -1), r[t].render(e));\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t, e;\n          var i = this,\n            s = i.chart,\n            r = i.logarithmic,\n            a = s.renderer,\n            l = i.options,\n            d = i.isLinked,\n            c = i.tickPositions,\n            p = i.axisTitle,\n            u = i.ticks,\n            g = i.minorTicks,\n            f = i.alternateBands,\n            m = l.stackLabels,\n            x = l.alternateGridColor,\n            y = l.crossing,\n            b = i.tickmarkOffset,\n            v = i.axisLine,\n            S = i.showAxis,\n            C = h(a.globalAnimation);\n          if (i.labelEdge.length = 0, i.overlap = !1, [u, g, f].forEach(function (t) {\n            D(t, function (t) {\n              t.isActive = !1;\n            });\n          }), T(y)) {\n            var _t35 = this.isXAxis ? s.yAxis[0] : s.xAxis[0],\n              _e23 = [1, -1, -1, 1][this.side];\n            if (_t35) {\n              var _s23 = _t35.toPixels(y, !0);\n              i.horiz && (_s23 = _t35.len - _s23), i.offset = _e23 * _s23;\n            }\n          }\n          if (i.hasData() || d) {\n            var _a8 = i.chart.hasRendered && i.old && T(i.old.min);\n            i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function (t) {\n              i.renderMinorTick(t, _a8);\n            }), c.length && (c.forEach(function (t, e) {\n              i.renderTick(t, e, _a8);\n            }), b && (0 === i.min || i.single) && (u[-1] || (u[-1] = new n(i, -1, null, !0)), u[-1].render(-1))), x && c.forEach(function (n, a) {\n              e = void 0 !== c[a + 1] ? c[a + 1] + b : i.max - b, a % 2 == 0 && n < i.max && e <= i.max + (s.polar ? -b : b) && (f[n] || (f[n] = new o.PlotLineOrBand(i, {})), t = n + b, f[n].options = {\n                from: r ? r.lin2log(t) : t,\n                to: r ? r.lin2log(e) : e,\n                color: x,\n                className: \"highcharts-alternate-grid\"\n              }, f[n].render(), f[n].isActive = !0);\n            }), i._addedPlotLB || (i._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function (t) {\n              i.addPlotBandOrLine(t);\n            }));\n          }\n          [u, g, f].forEach(function (t) {\n            var e = [],\n              i = C.duration;\n            D(t, function (t, i) {\n              t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));\n            }), R(function () {\n              var i = e.length;\n              for (; i--;) t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);\n            }, t !== f && s.hasRendered && i ? i : 0);\n          }), v && (v[v.isPlaced ? \"animate\" : \"attr\"]({\n            d: this.getLinePath(v.strokeWidth())\n          }), v.isPlaced = !0, v[S ? \"show\" : \"hide\"](S)), p && S && (p[p.isNew ? \"attr\" : \"animate\"](i.getTitlePosition(p)), p.isNew = !1), m && m.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {\n            len: i.len,\n            max: i.max,\n            min: i.min,\n            transA: i.transA,\n            userMax: i.userMax,\n            userMin: i.userMin\n          }, i.isDirty = !1, k(this, \"afterRender\");\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw() {\n          this.visible && (this.render(), this.plotLinesAndBands.forEach(function (t) {\n            t.render();\n          })), this.series.forEach(function (t) {\n            t.isDirty = !0;\n          });\n        }\n      }, {\n        key: \"getKeepProps\",\n        value: function getKeepProps() {\n          return this.keepProps || N.keepProps;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy(t) {\n          var e = this,\n            i = e.plotLinesAndBands,\n            s = this.eventOptions;\n          if (k(this, \"destroy\", {\n            keepEvents: t\n          }), t || j(e), [e.ticks, e.minorTicks, e.alternateBands].forEach(function (t) {\n            b(t);\n          }), i) {\n            var _t36 = i.length;\n            for (; _t36--;) i[_t36].destroy();\n          }\n          for (var _t37 in [\"axisLine\", \"axisTitle\", \"axisGroup\", \"gridGroup\", \"labelGroup\", \"cross\", \"scrollbar\"].forEach(function (t) {\n            e[t] && (e[t] = e[t].destroy());\n          }), e.plotLinesAndBandsGroups) e.plotLinesAndBandsGroups[_t37] = e.plotLinesAndBandsGroups[_t37].destroy();\n          D(e, function (t, i) {\n            -1 === e.getKeepProps().indexOf(i) && delete e[i];\n          }), this.eventOptions = s;\n        }\n      }, {\n        key: \"drawCrosshair\",\n        value: function drawCrosshair(t, e) {\n          var s = this.crosshair,\n            r = E(s && s.snap, !0),\n            o = this.chart,\n            n,\n            a,\n            h,\n            l = this.cross,\n            d;\n          if (k(this, \"drawCrosshair\", {\n            e: t,\n            point: e\n          }), t || (t = this.cross && this.cross.e), s && !1 !== (y(e) || !r)) {\n            if (r ? y(e) && (a = E(\"colorAxis\" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : a = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), y(a) && (d = {\n              value: e && (this.isXAxis ? e.x : E(e.stackY, e.y)),\n              translatedValue: a\n            }, o.polar && C(d, {\n              isCrosshair: !0,\n              chartX: t && t.chartX,\n              chartY: t && t.chartY,\n              point: e\n            }), n = this.getPlotLinePath(d) || null), !y(n)) {\n              this.hideCrosshair();\n              return;\n            }\n            h = this.categories && !this.isRadial, l || (this.cross = l = o.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (h ? \"category \" : \"thin \") + (s.className || \"\")).attr({\n              zIndex: E(s.zIndex, 2)\n            }).add(), !o.styledMode && (l.attr({\n              stroke: s.color || (h ? i.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n              \"stroke-width\": E(s.width, 1)\n            }).css({\n              \"pointer-events\": \"none\"\n            }), s.dashStyle && l.attr({\n              dashstyle: s.dashStyle\n            }))), l.show().attr({\n              d: n\n            }), h && !s.width && l.attr({\n              \"stroke-width\": this.transA\n            }), this.cross.e = t;\n          } else this.hideCrosshair();\n          k(this, \"afterDrawCrosshair\", {\n            e: t,\n            point: e\n          });\n        }\n      }, {\n        key: \"hideCrosshair\",\n        value: function hideCrosshair() {\n          this.cross && this.cross.hide(), k(this, \"afterHideCrosshair\");\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e) {\n          var i = this.chart;\n          t = L(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, E(e, !0) && i.redraw();\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(t) {\n          var e = this.chart,\n            i = this.coll,\n            s = this.series,\n            r = s.length;\n          for (; r--;) s[r] && s[r].remove(!1);\n          v(e.axes, this), v(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, E(t, !0) && e.redraw();\n        }\n      }, {\n        key: \"setTitle\",\n        value: function setTitle(t, e) {\n          this.update({\n            title: t\n          }, e);\n        }\n      }, {\n        key: \"setCategories\",\n        value: function setCategories(t, e) {\n          this.update({\n            categories: t\n          }, e);\n        }\n      }]);\n    }();\n    return N.keepProps = [\"coll\", \"extKey\", \"hcEvents\", \"len\", \"names\", \"series\", \"userMax\", \"userMin\"], N;\n  }), i(e, \"Core/Axis/DateTimeAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.addEvent,\n      s = t.getMagnitude,\n      r = t.normalizeTickInterval,\n      o = t.timeUnits;\n    return function (t) {\n      function e() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function n() {\n        if (\"datetime\" !== this.options.type) {\n          this.dateTime = void 0;\n          return;\n        }\n        this.dateTime || (this.dateTime = new a(this));\n      }\n      t.compose = function (t) {\n        return t.keepProps.includes(\"dateTime\") || (t.keepProps.push(\"dateTime\"), t.prototype.getTimeTicks = e, i(t, \"afterSetOptions\", n)), t;\n      };\n      var a = /*#__PURE__*/function () {\n        function a(t) {\n          _classCallCheck(this, a);\n          this.axis = t;\n        }\n        return _createClass(a, [{\n          key: \"normalizeTimeTickInterval\",\n          value: function normalizeTimeTickInterval(t, e) {\n            var i = e || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]],\n              n = i[i.length - 1],\n              _a9 = o[n[0]],\n              h = n[1],\n              l;\n            for (l = 0; l < i.length && (_a9 = o[(n = i[l])[0]], h = n[1], !i[l + 1] || !(t <= (_a9 * h[h.length - 1] + o[i[l + 1][0]]) / 2)); l++);\n            _a9 === o.year && t < 5 * _a9 && (h = [1, 2, 5]);\n            var d = r(t / _a9, h, \"year\" === n[0] ? Math.max(s(t / _a9), 1) : 1);\n            return {\n              unitRange: _a9,\n              count: d,\n              unitName: n[0]\n            };\n          }\n        }, {\n          key: \"getXDateFormat\",\n          value: function getXDateFormat(t, e) {\n            var i = this.axis,\n              s = i.chart.time;\n            return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;\n          }\n        }]);\n      }();\n      t.Additions = a;\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/LogarithmicAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.addEvent,\n      s = t.normalizeTickInterval,\n      r = t.pick;\n    return function (t) {\n      function e(t) {\n        var e = t.userOptions,\n          i = this.logarithmic;\n        \"logarithmic\" !== e.type ? this.logarithmic = void 0 : i || (i = this.logarithmic = new n(this));\n      }\n      function o() {\n        var t = this.logarithmic;\n        t && (this.lin2val = function (e) {\n          return t.lin2log(e);\n        }, this.val2lin = function (e) {\n          return t.log2lin(e);\n        });\n      }\n      t.compose = function (t) {\n        return t.keepProps.includes(\"logarithmic\") || (t.keepProps.push(\"logarithmic\"), i(t, \"init\", e), i(t, \"afterInit\", o)), t;\n      };\n      var n = /*#__PURE__*/function () {\n        function n(t) {\n          _classCallCheck(this, n);\n          this.axis = t;\n        }\n        return _createClass(n, [{\n          key: \"getLogTickPositions\",\n          value: function getLogTickPositions(t, e, i, o) {\n            var _n6 = this.axis,\n              a = _n6.len,\n              h = _n6.options,\n              l = [];\n            if (o || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), l = _n6.getLinearTickPositions(t, e, i);else if (t >= .08) {\n              var _s24, _r10, _n7, _a10, _h5, d, c;\n              var _p3 = Math.floor(e);\n              for (_s24 = t > .3 ? [1, 2, 4] : t > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], _r10 = _p3; _r10 < i + 1 && !c; _r10++) for (_n7 = 0, _a10 = _s24.length; _n7 < _a10 && !c; _n7++) (_h5 = this.log2lin(this.lin2log(_r10) * _s24[_n7])) > e && (!o || d <= i) && void 0 !== d && l.push(d), d > i && (c = !0), d = _h5;\n            } else {\n              var _d3 = this.lin2log(e),\n                _c3 = this.lin2log(i),\n                _p4 = o ? _n6.getMinorTickInterval() : h.tickInterval,\n                u = h.tickPixelInterval / (o ? 5 : 1),\n                g = o ? a / _n6.tickPositions.length : a;\n              t = s(t = r(\"auto\" === _p4 ? null : _p4, this.minorAutoInterval, (_c3 - _d3) * u / (g || 1))), l = _n6.getLinearTickPositions(t, _d3, _c3).map(this.log2lin), o || (this.minorAutoInterval = t / 5);\n            }\n            return o || (_n6.tickInterval = t), l;\n          }\n        }, {\n          key: \"lin2log\",\n          value: function lin2log(t) {\n            return Math.pow(10, t);\n          }\n        }, {\n          key: \"log2lin\",\n          value: function log2lin(t) {\n            return Math.log(t) / Math.LN10;\n          }\n        }]);\n      }();\n      t.Additions = n;\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.erase,\n      s = t.extend,\n      r = t.isNumber;\n    return function (t) {\n      var e;\n      function o(t) {\n        return this.addPlotBandOrLine(t, \"plotBands\");\n      }\n      function n(t, i) {\n        var _this8 = this;\n        var s = this.userOptions,\n          r = new e(this, t);\n        if (this.visible && (r = r.render()), r) {\n          if (this._addedPlotLB || (this._addedPlotLB = !0, (s.plotLines || []).concat(s.plotBands || []).forEach(function (t) {\n            _this8.addPlotBandOrLine(t);\n          })), i) {\n            var _e24 = s[i] || [];\n            _e24.push(t), s[i] = _e24;\n          }\n          this.plotLinesAndBands.push(r);\n        }\n        return r;\n      }\n      function a(t) {\n        return this.addPlotBandOrLine(t, \"plotLines\");\n      }\n      function h(t, e, i) {\n        i = i || this.options;\n        var s = this.getPlotLinePath({\n            value: e,\n            force: !0,\n            acrossPanes: i.acrossPanes\n          }),\n          o = [],\n          n = this.horiz,\n          a = !r(this.min) || !r(this.max) || t < this.min && e < this.min || t > this.max && e > this.max,\n          h = this.getPlotLinePath({\n            value: t,\n            force: !0,\n            acrossPanes: i.acrossPanes\n          }),\n          l,\n          d = 1,\n          c;\n        if (h && s) for (a && (c = h.toString() === s.toString(), d = 0), l = 0; l < h.length; l += 2) {\n          var _t38 = h[l],\n            _e25 = h[l + 1],\n            _i24 = s[l],\n            _r11 = s[l + 1];\n          (\"M\" === _t38[0] || \"L\" === _t38[0]) && (\"M\" === _e25[0] || \"L\" === _e25[0]) && (\"M\" === _i24[0] || \"L\" === _i24[0]) && (\"M\" === _r11[0] || \"L\" === _r11[0]) && (n && _i24[1] === _t38[1] ? (_i24[1] += d, _r11[1] += d) : n || _i24[2] !== _t38[2] || (_i24[2] += d, _r11[2] += d), o.push([\"M\", _t38[1], _t38[2]], [\"L\", _e25[1], _e25[2]], [\"L\", _r11[1], _r11[2]], [\"L\", _i24[1], _i24[2]], [\"Z\"])), o.isFlat = c;\n        }\n        return o;\n      }\n      function l(t) {\n        this.removePlotBandOrLine(t);\n      }\n      function d(t) {\n        var e = this.plotLinesAndBands,\n          s = this.options,\n          r = this.userOptions;\n        if (e) {\n          var _o15 = e.length;\n          for (; _o15--;) e[_o15].id === t && e[_o15].destroy();\n          [s.plotLines || [], r.plotLines || [], s.plotBands || [], r.plotBands || []].forEach(function (e) {\n            for (_o15 = e.length; _o15--;) (e[_o15] || {}).id === t && i(e, e[_o15]);\n          });\n        }\n      }\n      function c(t) {\n        this.removePlotBandOrLine(t);\n      }\n      t.compose = function (t, i) {\n        var r = i.prototype;\n        return r.addPlotBand || (e = t, s(r, {\n          addPlotBand: o,\n          addPlotLine: a,\n          addPlotBandOrLine: n,\n          getPlotBandPath: h,\n          removePlotBand: l,\n          removePlotLine: c,\n          removePlotBandOrLine: d\n        })), i;\n      };\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [e[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = e.arrayMax,\n      s = e.arrayMin,\n      r = e.defined,\n      o = e.destroyObjectProperties,\n      n = e.erase,\n      a = e.fireEvent,\n      h = e.merge,\n      l = e.objectEach,\n      d = e.pick;\n    var c = /*#__PURE__*/function () {\n      function c(t, e) {\n        _classCallCheck(this, c);\n        this.axis = t, this.options = e, this.id = e.id;\n      }\n      return _createClass(c, [{\n        key: \"render\",\n        value: function render() {\n          var _s$log2lin,\n            _this9 = this,\n            _S,\n            _S2;\n          a(this, \"render\");\n          var t = this.axis,\n            e = this.options,\n            i = t.horiz,\n            s = t.logarithmic,\n            o = e.color,\n            n = e.events,\n            _e$zIndex = e.zIndex,\n            _c4 = _e$zIndex === void 0 ? 0 : _e$zIndex,\n            p = {},\n            u = t.chart.renderer,\n            g = e.to,\n            f = e.from,\n            m = e.value,\n            x = e.borderWidth,\n            y = e.label,\n            b = this.label,\n            v = this.svgElem,\n            S = [],\n            C,\n            k = r(f) && r(g),\n            M = r(m),\n            w = !v,\n            A = {\n              \"class\": \"highcharts-plot-\" + (k ? \"band \" : \"line \") + (e.className || \"\")\n            },\n            T = k ? \"bands\" : \"lines\";\n          if (!t.chart.styledMode && (M ? (A.stroke = o || \"#999999\", A[\"stroke-width\"] = d(e.width, 1), e.dashStyle && (A.dashstyle = e.dashStyle)) : k && (A.fill = o || \"#e6e9ff\", x && (A.stroke = e.borderColor, A[\"stroke-width\"] = x))), p.zIndex = _c4, T += \"-\" + _c4, (C = t.plotLinesAndBandsGroups[T]) || (t.plotLinesAndBandsGroups[T] = C = u.g(\"plot-\" + T).attr(p).add()), v || (this.svgElem = v = u.path().attr(A).add(C)), r(m)) S = t.getPlotLinePath({\n            value: (_s$log2lin = s === null || s === void 0 ? void 0 : s.log2lin(m)) !== null && _s$log2lin !== void 0 ? _s$log2lin : m,\n            lineWidth: v.strokeWidth(),\n            acrossPanes: e.acrossPanes\n          });else {\n            var _s$log2lin2, _s$log2lin3;\n            if (!(r(f) && r(g))) return;\n            S = t.getPlotBandPath((_s$log2lin2 = s === null || s === void 0 ? void 0 : s.log2lin(f)) !== null && _s$log2lin2 !== void 0 ? _s$log2lin2 : f, (_s$log2lin3 = s === null || s === void 0 ? void 0 : s.log2lin(g)) !== null && _s$log2lin3 !== void 0 ? _s$log2lin3 : g, e);\n          }\n          return !this.eventsAdded && n && (l(n, function (t, e) {\n            var _v2;\n            (_v2 = v) === null || _v2 === void 0 || _v2.on(e, function (t) {\n              n[e].apply(_this9, [t]);\n            });\n          }), this.eventsAdded = !0), (w || !v.d) && (_S = S) !== null && _S !== void 0 && _S.length ? v.attr({\n            d: S\n          }) : v && (S ? (v.show(), v.animate({\n            d: S\n          })) : v.d && (v.hide(), b && (this.label = b = b.destroy()))), y && (r(y.text) || r(y.formatter)) && (_S2 = S) !== null && _S2 !== void 0 && _S2.length && t.width > 0 && t.height > 0 && !S.isFlat ? (y = h({\n            align: i && k ? \"center\" : void 0,\n            x: i ? !k && 4 : 10,\n            verticalAlign: !i && k ? \"middle\" : void 0,\n            y: i ? k ? 16 : 10 : k ? 6 : -4,\n            rotation: i && !k ? 90 : 0\n          }, y), this.renderLabel(y, S, k, _c4)) : b && b.hide(), this;\n        }\n      }, {\n        key: \"renderLabel\",\n        value: function renderLabel(t, e, r, o) {\n          var n = this.axis,\n            a = n.chart.renderer,\n            l = this.label;\n          l || (this.label = l = a.text(this.getLabelText(t), 0, 0, t.useHTML).attr({\n            align: t.textAlign || t.align,\n            rotation: t.rotation,\n            \"class\": \"highcharts-plot-\" + (r ? \"band\" : \"line\") + \"-label \" + (t.className || \"\"),\n            zIndex: o\n          }), n.chart.styledMode || l.css(h({\n            fontSize: \"0.8em\",\n            textOverflow: \"ellipsis\"\n          }, t.style)), l.add());\n          var d = e.xBounds || [e[0][1], e[1][1], r ? e[2][1] : e[0][1]],\n            _c5 = e.yBounds || [e[0][2], e[1][2], r ? e[2][2] : e[0][2]],\n            p = s(d),\n            u = s(_c5);\n          if (l.align(t, !1, {\n            x: p,\n            y: u,\n            width: i(d) - p,\n            height: i(_c5) - u\n          }), !l.alignValue || \"left\" === l.alignValue) {\n            var _e26 = t.clip ? n.width : n.chart.chartWidth;\n            l.css({\n              width: (90 === l.rotation ? n.height - (l.alignAttr.y - n.top) : _e26 - (l.alignAttr.x - n.left)) + \"px\"\n            });\n          }\n          l.show(!0);\n        }\n      }, {\n        key: \"getLabelText\",\n        value: function getLabelText(t) {\n          return r(t.formatter) ? t.formatter.call(this) : t.text;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          n(this.axis.plotLinesAndBands, this), delete this.axis, o(this);\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(e) {\n          return t.compose(c, e);\n        }\n      }]);\n    }();\n    return c;\n  }), i(e, \"Core/Tooltip.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Templating.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o) {\n    var n;\n    var a = t.animObject,\n      h = e.format,\n      l = i.composed,\n      d = i.doc,\n      c = i.isSafari,\n      p = s.distribute,\n      u = o.addEvent,\n      g = o.clamp,\n      f = o.css,\n      m = o.discardElement,\n      x = o.extend,\n      y = o.fireEvent,\n      b = o.isArray,\n      v = o.isNumber,\n      S = o.isString,\n      C = o.merge,\n      k = o.pick,\n      M = o.pushUnique,\n      w = o.splat,\n      A = o.syncTimeout;\n    var T = /*#__PURE__*/function () {\n      function T(t, e, i) {\n        _classCallCheck(this, T);\n        this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e), this.pointer = i;\n      }\n      return _createClass(T, [{\n        key: \"bodyFormatter\",\n        value: function bodyFormatter(t) {\n          return t.map(function (t) {\n            var e = t.series.tooltipOptions;\n            return (e[(t.point.formatPrefix || \"point\") + \"Formatter\"] || t.point.tooltipFormatter).call(t.point, e[(t.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n          });\n        }\n      }, {\n        key: \"cleanSplit\",\n        value: function cleanSplit(t) {\n          this.chart.series.forEach(function (e) {\n            var i = e && e.tt;\n            i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);\n          });\n        }\n      }, {\n        key: \"defaultFormatter\",\n        value: function defaultFormatter(t) {\n          var e;\n          var i = this.points || w(this);\n          return (e = (e = [t.tooltipFooterHeaderFormatter(i[0])]).concat(t.bodyFormatter(i))).push(t.tooltipFooterHeaderFormatter(i[0], !0)), e;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), m(this.container)), o.clearTimeout(this.hideTimer);\n        }\n      }, {\n        key: \"getAnchor\",\n        value: function getAnchor(t, e) {\n          var i;\n          var s = this.chart,\n            r = this.pointer,\n            o = s.inverted,\n            n = s.plotTop,\n            a = s.plotLeft;\n          if ((t = w(t))[0].series && t[0].series.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = r.normalize(e)), i = [e.chartX - a, e.chartY - n];else if (t[0].tooltipPos) i = t[0].tooltipPos;else {\n            var _s25 = 0,\n              _r12 = 0;\n            t.forEach(function (t) {\n              var e = t.pos(!0);\n              e && (_s25 += e[0], _r12 += e[1]);\n            }), _s25 /= t.length, _r12 /= t.length, this.shared && t.length > 1 && e && (o ? _s25 = e.chartX : _r12 = e.chartY), i = [_s25 - a, _r12 - n];\n          }\n          return i.map(Math.round);\n        }\n      }, {\n        key: \"getClassName\",\n        value: function getClassName(t, e, i) {\n          var s = this.options,\n            r = t.series,\n            o = r.options;\n          return [s.className, \"highcharts-label\", i && \"highcharts-tooltip-header\", e ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !i && \"highcharts-color-\" + k(t.colorIndex, r.colorIndex), o && o.className].filter(S).join(\" \");\n        }\n      }, {\n        key: \"getLabel\",\n        value: function getLabel() {\n          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n              anchorX: 0,\n              anchorY: 0\n            },\n            t = _ref.anchorX,\n            e = _ref.anchorY;\n          var s = this,\n            o = this.chart.styledMode,\n            n = this.options,\n            a = this.split && this.allowShared,\n            h = this.container,\n            l = this.chart.renderer;\n          if (this.label) {\n            var _t39 = !this.label.hasClass(\"highcharts-label\");\n            (!a && _t39 || a && !_t39) && this.destroy();\n          }\n          if (!this.label) {\n            if (this.outside) {\n              var _t40 = this.chart.options.chart.style,\n                _e27 = r.getRendererType();\n              this.container = h = i.doc.createElement(\"div\"), h.className = \"highcharts-tooltip-container\", f(h, {\n                position: \"absolute\",\n                top: \"1px\",\n                pointerEvents: \"none\",\n                zIndex: Math.max(this.options.style.zIndex || 0, (_t40 && _t40.zIndex || 0) + 3)\n              }), this.renderer = l = new _e27(h, 0, 0, _t40, void 0, void 0, l.styledMode);\n            }\n            if (a ? this.label = l.g(\"tooltip\") : (this.label = l.label(\"\", t, e, n.shape, void 0, void 0, n.useHTML, void 0, \"tooltip\").attr({\n              padding: n.padding,\n              r: n.borderRadius\n            }), o || this.label.attr({\n              fill: n.backgroundColor,\n              \"stroke-width\": n.borderWidth || 0\n            }).css(n.style).css({\n              pointerEvents: n.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\")\n            })), s.outside) {\n              var _t41 = this.label;\n              [_t41.xSetter, _t41.ySetter].forEach(function (e, i) {\n                _t41[i ? \"ySetter\" : \"xSetter\"] = function (r) {\n                  e.call(_t41, s.distance), _t41[i ? \"y\" : \"x\"] = r, h && (h.style[i ? \"top\" : \"left\"] = \"\".concat(r, \"px\"));\n                };\n              });\n            }\n            this.label.attr({\n              zIndex: 8\n            }).shadow(n.shadow).add();\n          }\n          return h && !h.parentElement && i.doc.body.appendChild(h), this.label;\n        }\n      }, {\n        key: \"getPlayingField\",\n        value: function getPlayingField() {\n          var t = d.body,\n            e = d.documentElement,\n            i = this.chart,\n            s = this.distance,\n            r = this.outside;\n          return {\n            width: r ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s : i.chartWidth,\n            height: r ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight\n          };\n        }\n      }, {\n        key: \"getPosition\",\n        value: function getPosition(t, e, i) {\n          var _r$hoverSeries;\n          var s = this.distance,\n            r = this.chart,\n            o = this.outside,\n            n = this.pointer,\n            a = r.inverted,\n            h = r.plotLeft,\n            l = r.plotTop,\n            d = r.polar,\n            _i$plotX = i.plotX,\n            c = _i$plotX === void 0 ? 0 : _i$plotX,\n            _i$plotY = i.plotY,\n            p = _i$plotY === void 0 ? 0 : _i$plotY,\n            u = {},\n            g = a && i.h || 0,\n            _this$getPlayingField = this.getPlayingField(),\n            f = _this$getPlayingField.height,\n            m = _this$getPlayingField.width,\n            x = n.getChartPosition(),\n            y = function y(t) {\n              return t * x.scaleX;\n            },\n            b = function b(t) {\n              return t * x.scaleY;\n            },\n            v = function v(i) {\n              var n = \"x\" === i;\n              return [i, n ? m : f, n ? t : e].concat(o ? [n ? y(t) : b(e), n ? x.left - s + y(c + h) : x.top - s + b(p + l), 0, n ? m : f] : [n ? t : e, n ? c + h : p + l, n ? h : l, n ? h + r.plotWidth : l + r.plotHeight]);\n            },\n            S = v(\"y\"),\n            C = v(\"x\"),\n            M,\n            w = !!i.negative;\n          !d && ((_r$hoverSeries = r.hoverSeries) === null || _r$hoverSeries === void 0 || (_r$hoverSeries = _r$hoverSeries.yAxis) === null || _r$hoverSeries === void 0 ? void 0 : _r$hoverSeries.reversed) && (w = !w);\n          var A = !this.followPointer && k(i.ttBelow, !d && !a === w),\n            _T = function _T(t, e, i, r, n, a, h) {\n              var l = o ? \"y\" === t ? b(s) : y(s) : s,\n                d = (i - r) / 2,\n                c = r < n - s,\n                p = n + s + r < e,\n                f = n - l - i + d,\n                m = n + l - d;\n              if (A && p) u[t] = m;else if (!A && c) u[t] = f;else if (c) u[t] = Math.min(h - r, f - g < 0 ? f : f - g);else {\n                if (!p) return !1;\n                u[t] = Math.max(a, m + g + i > e ? m : m + g);\n              }\n            },\n            P = function P(t, e, i, r, o) {\n              if (o < s || o > e - s) return !1;\n              o < i / 2 ? u[t] = 1 : o > e - r / 2 ? u[t] = e - r - 2 : u[t] = o - i / 2;\n            },\n            L = function L(t) {\n              var _ref2;\n              (_ref2 = [C, S], S = _ref2[0], C = _ref2[1]), M = t;\n            },\n            _O = function O() {\n              !1 !== _T.apply(0, S) ? !1 !== P.apply(0, C) || M || (L(!0), _O()) : M ? u.x = u.y = 0 : (L(!0), _O());\n            };\n          return (a && !d || this.len > 1) && L(), _O(), u;\n        }\n      }, {\n        key: \"hide\",\n        value: function hide(t) {\n          var e = this;\n          o.clearTimeout(this.hideTimer), t = k(t, this.options.hideDelay), this.isHidden || (this.hideTimer = A(function () {\n            var i = e.getLabel();\n            e.getLabel().animate({\n              opacity: 0\n            }, {\n              duration: t ? 150 : t,\n              complete: function complete() {\n                i.hide(), e.container && e.container.remove();\n              }\n            }), e.isHidden = !0;\n          }, t));\n        }\n      }, {\n        key: \"init\",\n        value: function init(t, e) {\n          this.chart = t, this.options = e, this.crosshairs = [], this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = k(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));\n        }\n      }, {\n        key: \"shouldStickOnContact\",\n        value: function shouldStickOnContact(t) {\n          return !!(!this.followPointer && this.options.stickOnContact && (!t || this.pointer.inClass(t.target, \"highcharts-tooltip\")));\n        }\n      }, {\n        key: \"move\",\n        value: function move(t, e, i, s) {\n          var r = this,\n            o = a(!r.isHidden && r.options.animation),\n            n = r.followPointer || (r.len || 0) > 1,\n            h = {\n              x: t,\n              y: e\n            };\n          n || (h.anchorX = i, h.anchorY = s), o.step = function () {\n            return r.drawTracker();\n          }, r.getLabel().animate(h, o);\n        }\n      }, {\n        key: \"refresh\",\n        value: function refresh(t, e) {\n          var i = this.chart,\n            s = this.options,\n            r = this.pointer,\n            n = this.shared,\n            a = w(t),\n            l = a[0],\n            d = [],\n            c = s.format,\n            p = s.formatter || this.defaultFormatter,\n            u = i.styledMode,\n            g = {},\n            f = this.allowShared;\n          if (!s.enabled || !l.series) return;\n          o.clearTimeout(this.hideTimer), this.allowShared = !(!b(t) && t.series && t.series.noSharedTooltip), f = f && !this.allowShared, this.followPointer = !this.split && l.series.tooltipOptions.followPointer;\n          var m = this.getAnchor(t, e),\n            x = m[0],\n            v = m[1];\n          n && this.allowShared ? (r.applyInactiveState(a), a.forEach(function (t) {\n            t.setState(\"hover\"), d.push(t.getLabelConfig());\n          }), (g = l.getLabelConfig()).points = d) : g = l.getLabelConfig(), this.len = d.length;\n          var C = S(c) ? h(c, g, i) : p.call(g, this),\n            M = l.series;\n          if (this.distance = k(M.tooltipOptions.distance, 16), !1 === C) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(C, a);else {\n              var _t42 = x,\n                _o16 = v;\n              if (e && r.isDirectTouch && (_t42 = e.chartX - i.plotLeft, _o16 = e.chartY - i.plotTop), i.polar || !1 === M.options.clip || a.some(function (e) {\n                return r.isDirectTouch || e.series.shouldShowTooltip(_t42, _o16);\n              })) {\n                var _t43 = this.getLabel(f && this.tt || {});\n                (!s.style.width || u) && _t43.css({\n                  width: (this.outside ? this.getPlayingField() : i.spacingBox).width + \"px\"\n                }), _t43.attr({\n                  \"class\": this.getClassName(l),\n                  text: C && C.join ? C.join(\"\") : C\n                }), u || _t43.attr({\n                  stroke: s.borderColor || l.color || M.color || \"#666666\"\n                }), this.updatePosition({\n                  plotX: x,\n                  plotY: v,\n                  negative: l.negative,\n                  ttBelow: l.ttBelow,\n                  h: m[2] || 0\n                });\n              } else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show(), this.isHidden = !1;\n          }\n          y(this, \"refresh\");\n        }\n      }, {\n        key: \"renderSplit\",\n        value: function renderSplit(t, e) {\n          var _s$scrollablePlotArea;\n          var i = this,\n            s = i.chart,\n            _i$chart = i.chart,\n            r = _i$chart.chartWidth,\n            o = _i$chart.chartHeight,\n            n = _i$chart.plotHeight,\n            a = _i$chart.plotLeft,\n            h = _i$chart.plotTop,\n            _i$chart$scrollablePi = _i$chart.scrollablePixelsY,\n            l = _i$chart$scrollablePi === void 0 ? 0 : _i$chart$scrollablePi,\n            u = _i$chart.scrollablePixelsX,\n            f = _i$chart.styledMode,\n            m = i.distance,\n            y = i.options,\n            b = i.options.positioner,\n            v = i.pointer,\n            _ref3 = ((_s$scrollablePlotArea = s.scrollablePlotArea) === null || _s$scrollablePlotArea === void 0 ? void 0 : _s$scrollablePlotArea.scrollingContainer) || {},\n            _ref3$scrollLeft = _ref3.scrollLeft,\n            C = _ref3$scrollLeft === void 0 ? 0 : _ref3$scrollLeft,\n            _ref3$scrollTop = _ref3.scrollTop,\n            M = _ref3$scrollTop === void 0 ? 0 : _ref3$scrollTop,\n            w = i.outside && \"number\" != typeof u ? d.documentElement.getBoundingClientRect() : {\n              left: C,\n              right: C + r,\n              top: M,\n              bottom: M + o\n            },\n            A = i.getLabel(),\n            _T2 = this.renderer || s.renderer,\n            P = !!(s.xAxis[0] && s.xAxis[0].opposite),\n            _v$getChartPosition = v.getChartPosition(),\n            L = _v$getChartPosition.left,\n            O = _v$getChartPosition.top,\n            D = h + M,\n            E = 0,\n            I = n - l;\n          function j(t, e, s, r) {\n            var o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;\n            var n, a;\n            return s ? (n = P ? 0 : I, a = g(t - r / 2, w.left, w.right - r - (i.outside ? L : 0))) : (n = e - D, a = g(a = o ? t - r - m : t + m, o ? a : w.left, w.right)), {\n              x: a,\n              y: n\n            };\n          }\n          S(t) && (t = [!1, t]);\n          var B = t.slice(0, e.length + 1).reduce(function (t, s, r) {\n            if (!1 !== s && \"\" !== s) {\n              var _o17 = e[r - 1] || {\n                  isHeader: !0,\n                  plotX: e[0].plotX,\n                  plotY: n,\n                  series: {}\n                },\n                _l5 = _o17.isHeader,\n                _d4 = _l5 ? i : _o17.series,\n                _c6 = _d4.tt = function (t, e, s) {\n                  var r = t,\n                    o = e.isHeader,\n                    n = e.series;\n                  if (!r) {\n                    var _y$borderWidth;\n                    var _t44 = {\n                      padding: y.padding,\n                      r: y.borderRadius\n                    };\n                    f || (_t44.fill = y.backgroundColor, _t44[\"stroke-width\"] = (_y$borderWidth = y.borderWidth) !== null && _y$borderWidth !== void 0 ? _y$borderWidth : 1), r = _T2.label(\"\", 0, 0, y[o ? \"headerShape\" : \"shape\"], void 0, void 0, y.useHTML).addClass(i.getClassName(e, !0, o)).attr(_t44).add(A);\n                  }\n                  return r.isActive = !0, r.attr({\n                    text: s\n                  }), f || r.css(y.style).attr({\n                    stroke: y.borderColor || e.color || n.color || \"#333333\"\n                  }), r;\n                }(_d4.tt, _o17, s.toString()),\n                _p5 = _c6.getBBox(),\n                _u = _p5.width + _c6.strokeWidth();\n              _l5 && (E = _p5.height, I += E, P && (D -= E));\n              var _ref4 = function (t) {\n                  var e, i;\n                  var s = t.isHeader,\n                    _t$plotX = t.plotX,\n                    r = _t$plotX === void 0 ? 0 : _t$plotX,\n                    _t$plotY = t.plotY,\n                    o = _t$plotY === void 0 ? 0 : _t$plotY,\n                    l = t.series;\n                  if (s) e = Math.max(a + r, a), i = h + n / 2;else {\n                    var _t45 = l.xAxis,\n                      _s26 = l.yAxis;\n                    e = _t45.pos + g(r, -m, _t45.len + m), l.shouldShowTooltip(0, _s26.pos - h + o, {\n                      ignoreX: !0\n                    }) && (i = _s26.pos + o);\n                  }\n                  return {\n                    anchorX: e = g(e, w.left - m, w.right + m),\n                    anchorY: i\n                  };\n                }(_o17),\n                _x2 = _ref4.anchorX,\n                _v3 = _ref4.anchorY;\n              if (\"number\" == typeof _v3) {\n                var _e28 = _p5.height + 1,\n                  _s27 = b ? b.call(i, _u, _e28, _o17) : j(_x2, _v3, _l5, _u);\n                t.push({\n                  align: b ? 0 : void 0,\n                  anchorX: _x2,\n                  anchorY: _v3,\n                  boxWidth: _u,\n                  point: _o17,\n                  rank: k(_s27.rank, _l5 ? 1 : 0),\n                  size: _e28,\n                  target: _s27.y,\n                  tt: _c6,\n                  x: _s27.x\n                });\n              } else _c6.isActive = !1;\n            }\n            return t;\n          }, []);\n          !b && B.some(function (t) {\n            var e = i.outside,\n              s = (e ? L : 0) + t.anchorX;\n            return s < w.left && s + t.boxWidth < w.right || s < L - w.left + t.boxWidth && w.right - s > s;\n          }) && (B = B.map(function (t) {\n            var _j = j(t.anchorX, t.anchorY, t.point.isHeader, t.boxWidth, !1),\n              e = _j.x,\n              i = _j.y;\n            return x(t, {\n              target: i,\n              x: e\n            });\n          })), i.cleanSplit(), p(B, I);\n          var R = {\n            left: L,\n            right: L\n          };\n          B.forEach(function (t) {\n            var e = t.x,\n              s = t.boxWidth,\n              r = t.isHeader;\n            !r && (i.outside && L + e < R.left && (R.left = L + e), !r && i.outside && R.left + s > R.right && (R.right = L + e));\n          }), B.forEach(function (t) {\n            var e = t.x,\n              s = t.anchorX,\n              r = t.anchorY,\n              o = t.pos,\n              n = t.point.isHeader,\n              a = {\n                visibility: void 0 === o ? \"hidden\" : \"inherit\",\n                x: e,\n                y: (o || 0) + D,\n                anchorX: s,\n                anchorY: r\n              };\n            if (i.outside && e < s) {\n              var _t46 = L - R.left;\n              _t46 > 0 && (n || (a.x = e + _t46, a.anchorX = s + _t46), n && (a.x = (R.right - R.left) / 2, a.anchorX = s + _t46));\n            }\n            t.tt.attr(a);\n          });\n          var z = i.container,\n            N = i.outside,\n            W = i.renderer;\n          if (N && z && W) {\n            var _A$getBBox = A.getBBox(),\n              _t47 = _A$getBBox.width,\n              _e29 = _A$getBBox.height,\n              _i25 = _A$getBBox.x,\n              _s28 = _A$getBBox.y;\n            W.setSize(_t47 + _i25, _e29 + _s28, !1), z.style.left = R.left + \"px\", z.style.top = O + \"px\";\n          }\n          c && A.attr({\n            opacity: 1 === A.opacity ? .999 : 1\n          });\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          if (!this.shouldStickOnContact()) {\n            this.tracker && (this.tracker = this.tracker.destroy());\n            return;\n          }\n          var t = this.chart,\n            e = this.label,\n            i = this.shared ? t.hoverPoints : t.hoverPoint;\n          if (!e || !i) return;\n          var s = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            },\n            r = this.getAnchor(i),\n            o = e.getBBox();\n          r[0] += t.plotLeft - (e.translateX || 0), r[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, r[0]), s.y = Math.min(0, r[1]), s.width = r[0] < 0 ? Math.max(Math.abs(r[0]), o.width - r[0]) : Math.max(Math.abs(r[0]), o.width), s.height = r[1] < 0 ? Math.max(Math.abs(r[1]), o.height - Math.abs(r[1])) : Math.max(Math.abs(r[1]), o.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass(\"highcharts-tracker\").add(e), t.styledMode || this.tracker.attr({\n            fill: \"rgba(0,0,0,0)\"\n          }));\n        }\n      }, {\n        key: \"styledModeFormat\",\n        value: function styledModeFormat(t) {\n          return t.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n        }\n      }, {\n        key: \"tooltipFooterHeaderFormatter\",\n        value: function tooltipFooterHeaderFormatter(t, e) {\n          var i = t.series,\n            s = i.tooltipOptions,\n            r = i.xAxis,\n            o = r && r.dateTime,\n            n = {\n              isFooter: e,\n              labelConfig: t\n            },\n            a = s.xDateFormat,\n            l = s[e ? \"footerFormat\" : \"headerFormat\"];\n          return y(this, \"headerFormatter\", n, function (e) {\n            o && !a && v(t.key) && (a = o.getXDateFormat(t.key, s.dateTimeLabelFormats)), o && a && (t.point && t.point.tooltipDateKeys || [\"key\"]).forEach(function (t) {\n              l = l.replace(\"{point.\" + t + \"}\", \"{point.\" + t + \":\" + a + \"}\");\n            }), i.chart.styledMode && (l = this.styledModeFormat(l)), e.text = h(l, {\n              point: t,\n              series: i\n            }, this.chart);\n          }), n.text;\n        }\n      }, {\n        key: \"update\",\n        value: function update(t) {\n          this.destroy(), this.init(this.chart, C(!0, this.options, t));\n        }\n      }, {\n        key: \"updatePosition\",\n        value: function updatePosition(t) {\n          var e = this.chart,\n            i = this.container,\n            s = this.distance,\n            r = this.options,\n            o = this.pointer,\n            n = this.renderer,\n            _this$getLabel = this.getLabel(),\n            _this$getLabel$height = _this$getLabel.height,\n            a = _this$getLabel$height === void 0 ? 0 : _this$getLabel$height,\n            _this$getLabel$width = _this$getLabel.width,\n            h = _this$getLabel$width === void 0 ? 0 : _this$getLabel$width,\n            _o$getChartPosition = o.getChartPosition(),\n            l = _o$getChartPosition.left,\n            d = _o$getChartPosition.top,\n            c = _o$getChartPosition.scaleX,\n            p = _o$getChartPosition.scaleY,\n            u = (r.positioner || this.getPosition).call(this, h, a, t),\n            g = (t.plotX || 0) + e.plotLeft,\n            m = (t.plotY || 0) + e.plotTop,\n            x;\n          n && i && (r.positioner && (u.x += l - s, u.y += d - s), x = (r.borderWidth || 0) + 2 * s + 2, n.setSize(h + x, a + x, !1), (1 !== c || 1 !== p) && (f(i, {\n            transform: \"scale(\".concat(c, \", \").concat(p, \")\")\n          }), g *= c, m *= p), g += l - u.x, m += d - u.y), this.move(Math.round(u.x), Math.round(u.y || 0), g, m);\n        }\n      }]);\n    }();\n    return (n = T || (T = {})).compose = function (t) {\n      M(l, \"Core.Tooltip\") && u(t, \"afterInit\", function () {\n        var t = this.chart;\n        t.options.tooltip && (t.tooltip = new n(t, t.options.tooltip, this));\n      });\n    }, T;\n  }), i(e, \"Core/Series/Point.js\", [e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Templating.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r) {\n    var o = e.animObject,\n      n = i.defaultOptions,\n      a = s.format,\n      h = r.addEvent,\n      l = r.crisp,\n      d = r.erase,\n      c = r.extend,\n      p = r.fireEvent,\n      u = r.getNestedProperty,\n      g = r.isArray,\n      f = r.isFunction,\n      m = r.isNumber,\n      x = r.isObject,\n      y = r.merge,\n      b = r.pick,\n      v = r.syncTimeout,\n      S = r.removeEvent,\n      C = r.uniqueKey;\n    var k = /*#__PURE__*/function () {\n      function k(t, e, i) {\n        var _this$id;\n        _classCallCheck(this, k);\n        this.formatPrefix = \"point\", this.visible = !0, this.series = t, this.applyOptions(e, i), (_this$id = this.id) !== null && _this$id !== void 0 ? _this$id : this.id = C(), this.resolveColor(), t.chart.pointCount++, p(this, \"afterInit\");\n      }\n      return _createClass(k, [{\n        key: \"animateBeforeDestroy\",\n        value: function animateBeforeDestroy() {\n          var t = this,\n            e = {\n              x: t.startXPos,\n              opacity: 0\n            },\n            i = t.getGraphicalProps();\n          i.singular.forEach(function (i) {\n            t[i] = t[i].animate(\"dataLabel\" === i ? {\n              x: t[i].startXPos,\n              y: t[i].startYPos,\n              opacity: 0\n            } : e);\n          }), i.plural.forEach(function (e) {\n            t[e].forEach(function (e) {\n              e.element && e.animate(c({\n                x: t.startXPos\n              }, e.startYPos ? {\n                x: e.startXPos,\n                y: e.startYPos\n              } : {}));\n            });\n          });\n        }\n      }, {\n        key: \"applyOptions\",\n        value: function applyOptions(t, e) {\n          var i = this.series,\n            s = i.options.pointValKey || i.pointValKey;\n          return c(this, t = k.prototype.optionsToObject.call(this, t)), this.options = this.options ? c(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = k.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = \"select\"), \"name\" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? this.x = e !== null && e !== void 0 ? e : i.autoIncrement() : m(t.x) && i.options.relativeXValue && (this.x = i.autoIncrement(t.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? \"null\" : \"point\", this;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          if (!this.destroyed) {\n            var _t48 = this,\n              _e30 = _t48.series,\n              _i26 = _e30.chart,\n              _s29 = _e30.options.dataSorting,\n              _r13 = _i26.hoverPoints,\n              _n8 = o(_t48.series.chart.renderer.globalAnimation),\n              _a11 = function _a11() {\n                for (var _e31 in (_t48.graphic || _t48.graphics || _t48.dataLabel || _t48.dataLabels) && (S(_t48), _t48.destroyElements()), _t48) delete _t48[_e31];\n              };\n            _t48.legendItem && _i26.legend.destroyItem(_t48), _r13 && (_t48.setState(), d(_r13, _t48), _r13.length || (_i26.hoverPoints = null)), _t48 === _i26.hoverPoint && _t48.onMouseOut(), _s29 && _s29.enabled ? (this.animateBeforeDestroy(), v(_a11, _n8.duration)) : _a11(), _i26.pointCount--;\n          }\n          this.destroyed = !0;\n        }\n      }, {\n        key: \"destroyElements\",\n        value: function destroyElements(t) {\n          var e = this,\n            i = e.getGraphicalProps(t);\n          i.singular.forEach(function (t) {\n            e[t] = e[t].destroy();\n          }), i.plural.forEach(function (t) {\n            e[t].forEach(function (t) {\n              t && t.element && t.destroy();\n            }), delete e[t];\n          });\n        }\n      }, {\n        key: \"firePointEvent\",\n        value: function firePointEvent(t, e, i) {\n          var s = this,\n            r = this.series.options;\n          s.manageEvent(t), \"click\" === t && r.allowPointSelect && (i = function i(t) {\n            !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);\n          }), p(s, t, e, i);\n        }\n      }, {\n        key: \"getClassName\",\n        value: function getClassName() {\n          return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n        }\n      }, {\n        key: \"getGraphicalProps\",\n        value: function getGraphicalProps(t) {\n          var e, i;\n          var s = this,\n            r = [],\n            o = {\n              singular: [],\n              plural: []\n            };\n          for ((t = t || {\n            graphic: 1,\n            dataLabel: 1\n          }).graphic && r.push(\"graphic\", \"connector\"), t.dataLabel && r.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\"), i = r.length; i--;) s[e = r[i]] && o.singular.push(e);\n          return [\"graphic\", \"dataLabel\"].forEach(function (e) {\n            var i = e + \"s\";\n            t[e] && s[i] && o.plural.push(i);\n          }), o;\n        }\n      }, {\n        key: \"getLabelConfig\",\n        value: function getLabelConfig() {\n          return {\n            x: this.category,\n            y: this.y,\n            color: this.color,\n            colorIndex: this.colorIndex,\n            key: this.name || this.category,\n            series: this.series,\n            point: this,\n            percentage: this.percentage,\n            total: this.total || this.stackTotal\n          };\n        }\n      }, {\n        key: \"getNestedProperty\",\n        value: function getNestedProperty(t) {\n          return t ? 0 === t.indexOf(\"custom.\") ? u(t, this.options) : this[t] : void 0;\n        }\n      }, {\n        key: \"getZone\",\n        value: function getZone() {\n          var t = this.series,\n            e = t.zones,\n            i = t.zoneAxis || \"y\",\n            s,\n            r = 0;\n          for (s = e[0]; this[i] >= s.value;) s = e[++r];\n          return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;\n        }\n      }, {\n        key: \"hasNewShapeType\",\n        value: function hasNewShapeType() {\n          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return (m(this.x) || this.x instanceof Date) && m(this.y);\n        }\n      }, {\n        key: \"optionsToObject\",\n        value: function optionsToObject(t) {\n          var e = this.series,\n            i = e.options.keys,\n            s = i || e.pointArrayMap || [\"y\"],\n            r = s.length,\n            o = {},\n            n,\n            a = 0,\n            h = 0;\n          if (m(t) || null === t) o[s[0]] = t;else if (g(t)) for (!i && t.length > r && (\"string\" == (n = _typeof(t[0])) ? o.name = t[0] : \"number\" === n && (o.x = t[0]), a++); h < r;) i && void 0 === t[a] || (s[h].indexOf(\".\") > 0 ? k.prototype.setNestedProperty(o, t[a], s[h]) : o[s[h]] = t[a]), a++, h++;else \"object\" == _typeof(t) && (o = t, t.dataLabels && (e.hasDataLabels = function () {\n            return !0;\n          }), t.marker && (e._hasPointMarkers = !0));\n          return o;\n        }\n      }, {\n        key: \"pos\",\n        value: function pos(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.plotY;\n          if (!this.destroyed) {\n            var _i27 = this.plotX,\n              _s30 = this.series,\n              _r14 = _s30.chart,\n              _o18 = _s30.xAxis,\n              _n9 = _s30.yAxis,\n              _a12 = 0,\n              _h6 = 0;\n            if (m(_i27) && m(e)) return t && (_a12 = _o18 ? _o18.pos : _r14.plotLeft, _h6 = _n9 ? _n9.pos : _r14.plotTop), _r14.inverted && _o18 && _n9 ? [_n9.len - e + _h6, _o18.len - _i27 + _a12] : [_i27 + _a12, e + _h6];\n          }\n        }\n      }, {\n        key: \"resolveColor\",\n        value: function resolveColor() {\n          var t = this.series,\n            e = t.chart.options.chart,\n            i = t.chart.styledMode,\n            s,\n            r,\n            o = e.colorCount,\n            n;\n          delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (r = t.options.colors || t.chart.options.colors)[t.colorCounter], o = r.length), n = t.colorCounter, t.colorCounter++, t.colorCounter === o && (t.colorCounter = 0)) : (i || (s = t.color), n = t.colorIndex), this.colorIndex = b(this.options.colorIndex, n), this.color = b(this.options.color, s);\n        }\n      }, {\n        key: \"setNestedProperty\",\n        value: function setNestedProperty(t, e, i) {\n          return i.split(\".\").reduce(function (t, i, s, r) {\n            var o = r.length - 1 === s;\n            return t[i] = o ? e : x(t[i], !0) ? t[i] : {}, t[i];\n          }, t), t;\n        }\n      }, {\n        key: \"shouldDraw\",\n        value: function shouldDraw() {\n          return !this.isNull;\n        }\n      }, {\n        key: \"tooltipFormatter\",\n        value: function tooltipFormatter(t) {\n          var e = this.series,\n            i = e.tooltipOptions,\n            s = b(i.valueDecimals, \"\"),\n            r = i.valuePrefix || \"\",\n            o = i.valueSuffix || \"\";\n          return e.chart.styledMode && (t = e.chart.tooltip.styledModeFormat(t)), (e.pointArrayMap || [\"y\"]).forEach(function (e) {\n            e = \"{point.\" + e, (r || o) && (t = t.replace(RegExp(e + \"}\", \"g\"), r + e + \"}\" + o)), t = t.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + s + \"f}\");\n          }), a(t, {\n            point: this,\n            series: this.series\n          }, e.chart);\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e, i, s) {\n          var r;\n          var o = this,\n            n = o.series,\n            a = o.graphic,\n            h = n.chart,\n            l = n.options;\n          function d() {\n            o.applyOptions(t);\n            var s = a && o.hasMockGraphic,\n              d = null === o.y ? !s : s;\n            a && d && (o.graphic = a.destroy(), delete o.hasMockGraphic), x(t, !0) && (a && a.element && t && t.marker && void 0 !== t.marker.symbol && (o.graphic = a.destroy()), t !== null && t !== void 0 && t.dataLabels && o.dataLabel && (o.dataLabel = o.dataLabel.destroy())), r = o.index, n.updateParallelArrays(o, r), l.data[r] = x(l.data[r], !0) || x(t, !0) ? o.options : b(t, l.data[r]), n.isDirty = n.isDirtyData = !0, !n.fixedBox && n.hasCartesianSeries && (h.isDirtyBox = !0), \"point\" === l.legendType && (h.isDirtyLegend = !0), e && h.redraw(i);\n          }\n          e = b(e, !0), !1 === s ? d() : o.firePointEvent(\"update\", {\n            options: t\n          }, d);\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(t, e) {\n          this.series.removePoint(this.series.data.indexOf(this), t, e);\n        }\n      }, {\n        key: \"select\",\n        value: function select(t, e) {\n          var i = this,\n            s = i.series,\n            r = s.chart;\n          t = b(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? \"select\" : \"unselect\", {\n            accumulate: e\n          }, function () {\n            i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && \"select\"), e || r.getSelectedPoints().forEach(function (t) {\n              var e = t.series;\n              t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(r.hoverPoints && e.options.inactiveOtherPoints ? \"inactive\" : \"\"), t.firePointEvent(\"unselect\"));\n            });\n          }), delete this.selectedStaging;\n        }\n      }, {\n        key: \"onMouseOver\",\n        value: function onMouseOver(t) {\n          var _this$series$chart = this.series.chart,\n            e = _this$series$chart.inverted,\n            i = _this$series$chart.pointer;\n          i && (t = t ? i.normalize(t) : i.getChartCoordinatesFromPoint(this, e), i.runPointActions(t, this));\n        }\n      }, {\n        key: \"onMouseOut\",\n        value: function onMouseOut() {\n          var t = this.series.chart;\n          this.firePointEvent(\"mouseOut\"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function (t) {\n            t.setState();\n          }), t.hoverPoints = t.hoverPoint = null;\n        }\n      }, {\n        key: \"manageEvent\",\n        value: function manageEvent(t) {\n          var _e$events, _this$hcEvents, _this$hcEvents2, _this$importedUserEve, _this$hcEvents3;\n          var e = y(this.series.options.point, this.options),\n            i = (_e$events = e.events) === null || _e$events === void 0 ? void 0 : _e$events[t];\n          f(i) && (!((_this$hcEvents = this.hcEvents) !== null && _this$hcEvents !== void 0 && _this$hcEvents[t]) || ((_this$hcEvents2 = this.hcEvents) === null || _this$hcEvents2 === void 0 || (_this$hcEvents2 = _this$hcEvents2[t]) === null || _this$hcEvents2 === void 0 ? void 0 : _this$hcEvents2.map(function (t) {\n            return t.fn;\n          }).indexOf(i)) === -1) ? ((_this$importedUserEve = this.importedUserEvent) !== null && _this$importedUserEve !== void 0 && _this$importedUserEve.call(this), this.importedUserEvent = h(this, t, i)) : this.importedUserEvent && !i && ((_this$hcEvents3 = this.hcEvents) === null || _this$hcEvents3 === void 0 ? void 0 : _this$hcEvents3[t]) && (S(this, t), delete this.hcEvents[t], Object.keys(this.hcEvents) || delete this.importedUserEvent);\n        }\n      }, {\n        key: \"setState\",\n        value: function setState(e, i) {\n          var _x3;\n          var s = this.series,\n            r = this.state,\n            o = s.options.states[e || \"normal\"] || {},\n            a = n.plotOptions[s.type].marker && s.options.marker,\n            h = a && !1 === a.enabled,\n            l = a && a.states && a.states[e || \"normal\"] || {},\n            d = !1 === l.enabled,\n            u = this.marker || {},\n            g = s.chart,\n            f = a && s.markerAttribs,\n            x = s.halo,\n            y,\n            v,\n            S,\n            C = s.stateMarkerGraphic,\n            _k;\n          if ((e = e || \"\") === this.state && !i || this.selected && \"select\" !== e || !1 === o.enabled || e && (d || h && !1 === l.enabled) || e && u.states && u.states[e] && !1 === u.states[e].enabled) return;\n          if (this.state = e, f && (y = s.markerAttribs(this, e)), this.graphic && !this.hasMockGraphic) {\n            if (r && this.graphic.removeClass(\"highcharts-point-\" + r), e && this.graphic.addClass(\"highcharts-point-\" + e), !g.styledMode) {\n              v = s.pointAttribs(this, e), S = b(g.options.chart.animation, o.animation);\n              var _t49 = v.opacity;\n              s.options.inactiveOtherPoints && m(_t49) && (this.dataLabels || []).forEach(function (e) {\n                e && !e.hasClass(\"highcharts-data-label-hidden\") && (e.animate({\n                  opacity: _t49\n                }, S), e.connector && e.connector.animate({\n                  opacity: _t49\n                }, S));\n              }), this.graphic.animate(v, S);\n            }\n            y && this.graphic.animate(y, b(g.options.chart.animation, l.animation, a.animation)), C && C.hide();\n          } else e && l && (_k = u.symbol || s.symbol, C && C.currentSymbol !== _k && (C = C.destroy()), y && (C ? C[i ? \"animate\" : \"attr\"]({\n            x: y.x,\n            y: y.y\n          }) : _k && (s.stateMarkerGraphic = C = g.renderer.symbol(_k, y.x, y.y, y.width, y.height).add(s.markerGroup), C.currentSymbol = _k)), !g.styledMode && C && \"inactive\" !== this.state && C.attr(s.pointAttribs(this, e))), C && (C[e && this.isInside ? \"show\" : \"hide\"](), C.element.point = this, C.addClass(this.getClassName(), !0));\n          var M = o.halo,\n            w = this.graphic || C,\n            A = w && w.visibility || \"inherit\";\n          M && M.size && w && \"hidden\" !== A && !this.isCluster ? (x || (s.halo = x = g.renderer.path().add(w.parentGroup)), x.show()[i ? \"animate\" : \"attr\"]({\n            d: this.haloPath(M.size)\n          }), x.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + b(this.colorIndex, s.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: A,\n            zIndex: -1\n          }), x.point = this, g.styledMode || x.attr(c({\n            fill: this.color || s.color,\n            \"fill-opacity\": M.opacity\n          }, t.filterUserAttributes(M.attributes || {})))) : ((_x3 = x) === null || _x3 === void 0 || (_x3 = _x3.point) === null || _x3 === void 0 ? void 0 : _x3.haloPath) && !x.point.destroyed && x.animate({\n            d: x.point.haloPath(0)\n          }, null, x.hide), p(this, \"afterSetState\", {\n            state: e\n          });\n        }\n      }, {\n        key: \"haloPath\",\n        value: function haloPath(t) {\n          var e = this.pos();\n          return e ? this.series.chart.renderer.symbols.circle(l(e[0], 1) - t, e[1] - t, 2 * t, 2 * t) : [];\n        }\n      }]);\n    }();\n    return k;\n  }), i(e, \"Core/Pointer.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    var r = t.parse,\n      o = e.charts,\n      n = e.composed,\n      a = e.isTouchDevice,\n      h = i.addEvent,\n      l = i.attr,\n      d = i.css,\n      c = i.extend,\n      p = i.find,\n      u = i.fireEvent,\n      g = i.isNumber,\n      f = i.isObject,\n      m = i.objectEach,\n      x = i.offset,\n      y = i.pick,\n      b = i.pushUnique,\n      v = i.splat;\n    var S = /*#__PURE__*/function () {\n      function S(t, e) {\n        var _e$chart$events;\n        _classCallCheck(this, S);\n        this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!((_e$chart$events = e.chart.events) !== null && _e$chart$events !== void 0 && _e$chart$events.click), this.pinchDown = [], this.setDOMEvents(), u(this, \"afterInit\");\n      }\n      return _createClass(S, [{\n        key: \"applyInactiveState\",\n        value: function applyInactiveState(t) {\n          var e = [],\n            i;\n          (t || []).forEach(function (t) {\n            i = t.series, e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && (e = e.concat(i.linkedSeries)), i.navigatorSeries && e.push(i.navigatorSeries);\n          }), this.chart.series.forEach(function (t) {\n            -1 === e.indexOf(t) ? t.setState(\"inactive\", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState(\"inactive\");\n          });\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var t = this;\n          this.eventsToUnbind.forEach(function (t) {\n            return t();\n          }), this.eventsToUnbind = [], !e.chartCount && (S.unbindDocumentMouseUp && S.unbindDocumentMouseUp.forEach(function (t) {\n            return t();\n          }), S.unbindDocumentTouchEnd && (S.unbindDocumentTouchEnd = S.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), m(t, function (e, i) {\n            t[i] = void 0;\n          });\n        }\n      }, {\n        key: \"getSelectionMarkerAttrs\",\n        value: function getSelectionMarkerAttrs(t, e) {\n          var _this10 = this;\n          var i = {\n            args: {\n              chartX: t,\n              chartY: e\n            },\n            attrs: {},\n            shapeType: \"rect\"\n          };\n          return u(this, \"getSelectionMarkerAttrs\", i, function (i) {\n            var s;\n            var r = _this10.chart,\n              o = _this10.zoomHor,\n              n = _this10.zoomVert,\n              _r$mouseDownX = r.mouseDownX,\n              a = _r$mouseDownX === void 0 ? 0 : _r$mouseDownX,\n              _r$mouseDownY = r.mouseDownY,\n              h = _r$mouseDownY === void 0 ? 0 : _r$mouseDownY,\n              l = i.attrs;\n            l.x = r.plotLeft, l.y = r.plotTop, l.width = o ? 1 : r.plotWidth, l.height = n ? 1 : r.plotHeight, o && (s = t - a, l.width = Math.max(1, Math.abs(s)), l.x = (s > 0 ? 0 : s) + a), n && (s = e - h, l.height = Math.max(1, Math.abs(s)), l.y = (s > 0 ? 0 : s) + h);\n          }), i;\n        }\n      }, {\n        key: \"drag\",\n        value: function drag(t) {\n          var e = this.chart,\n            _e$mouseDownX = e.mouseDownX,\n            i = _e$mouseDownX === void 0 ? 0 : _e$mouseDownX,\n            _e$mouseDownY = e.mouseDownY,\n            s = _e$mouseDownY === void 0 ? 0 : _e$mouseDownY,\n            _e$options$chart = e.options.chart,\n            o = _e$options$chart.panning,\n            n = _e$options$chart.panKey,\n            a = _e$options$chart.selectionMarkerFill,\n            h = e.plotLeft,\n            l = e.plotTop,\n            d = e.plotWidth,\n            c = e.plotHeight,\n            p = f(o) ? o.enabled : o,\n            u = n && t[\"\".concat(n, \"Key\")],\n            g = t.chartX,\n            m = t.chartY,\n            x,\n            y = this.selectionMarker;\n          if ((!y || !y.touch) && (g < h ? g = h : g > h + d && (g = h + d), m < l ? m = l : m > l + c && (m = l + c), this.hasDragged = Math.sqrt(Math.pow(i - g, 2) + Math.pow(s - m, 2)), this.hasDragged > 10)) {\n            x = e.isInsidePlot(i - h, s - l, {\n              visiblePlotOnly: !0\n            });\n            var _this$getSelectionMar = this.getSelectionMarkerAttrs(g, m),\n              _n10 = _this$getSelectionMar.shapeType,\n              _d5 = _this$getSelectionMar.attrs;\n            (e.hasCartesianSeries || e.mapView) && this.hasZoom && x && !u && !y && (this.selectionMarker = y = e.renderer[_n10](), y.attr({\n              \"class\": \"highcharts-selection-marker\",\n              zIndex: 7\n            }).add(), e.styledMode || y.attr({\n              fill: a || r(\"#334eff\").setOpacity(.25).get()\n            })), y && y.attr(_d5), x && !y && p && e.pan(t, o);\n          }\n        }\n      }, {\n        key: \"dragStart\",\n        value: function dragStart(t) {\n          var e = this.chart;\n          e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = t.chartX, e.mouseDownY = t.chartY;\n        }\n      }, {\n        key: \"getSelectionBox\",\n        value: function getSelectionBox(t) {\n          var e = {\n            args: {\n              marker: t\n            },\n            result: t.getBBox()\n          };\n          return u(this, \"getSelectionBox\", e), e.result;\n        }\n      }, {\n        key: \"drop\",\n        value: function drop(t) {\n          var _this11 = this;\n          var e;\n          var i = this.chart,\n            s = this.selectionMarker;\n          var _iterator4 = _createForOfIteratorHelper(i.axes),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _t50 = _step4.value;\n              _t50.isPanning && (_t50.isPanning = !1, (_t50.options.startOnTick || _t50.options.endOnTick || _t50.series.some(function (t) {\n                return t.boosted;\n              })) && (_t50.forceRedraw = !0, _t50.setExtremes(_t50.userMin, _t50.userMax, !1), e = !0));\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          if (e && i.redraw(), s && t) {\n            if (this.hasDragged) {\n              var _e32 = this.getSelectionBox(s);\n              i.transform({\n                axes: i.axes.filter(function (t) {\n                  return t.zoomEnabled && (\"xAxis\" === t.coll && _this11.zoomX || \"yAxis\" === t.coll && _this11.zoomY);\n                }),\n                selection: _objectSpread({\n                  originalEvent: t,\n                  xAxis: [],\n                  yAxis: []\n                }, _e32),\n                from: _e32\n              });\n            }\n            g(i.index) && (this.selectionMarker = s.destroy());\n          }\n          i && g(i.index) && (d(i.container, {\n            cursor: i._cursor\n          }), i.cancelClick = this.hasDragged > 10, i.mouseIsDown = !1, this.hasDragged = 0, this.pinchDown = []);\n        }\n      }, {\n        key: \"findNearestKDPoint\",\n        value: function findNearestKDPoint(t, e, i) {\n          var s;\n          return t.forEach(function (t) {\n            var r = !(t.noSharedTooltip && e) && 0 > t.options.findNearestPointBy.indexOf(\"y\"),\n              o = t.searchPoint(i, r);\n            f(o, !0) && o.series && (!f(s, !0) || function (t, i, _i$series$group, _t$series$group) {\n              var s = t.distX - i.distX,\n                r = t.dist - i.dist,\n                o = ((_i$series$group = i.series.group) === null || _i$series$group === void 0 ? void 0 : _i$series$group.zIndex) - ((_t$series$group = t.series.group) === null || _t$series$group === void 0 ? void 0 : _t$series$group.zIndex);\n              return 0 !== s && e ? s : 0 !== r ? r : 0 !== o ? o : t.series.index > i.series.index ? -1 : 1;\n            }(s, o) > 0) && (s = o);\n          }), s;\n        }\n      }, {\n        key: \"getChartCoordinatesFromPoint\",\n        value: function getChartCoordinatesFromPoint(t, e) {\n          var _t$series = t.series,\n            i = _t$series.xAxis,\n            s = _t$series.yAxis,\n            r = t.shapeArgs;\n          if (i && s) {\n            var _ref5, _t$clientX;\n            var _o19 = (_ref5 = (_t$clientX = t.clientX) !== null && _t$clientX !== void 0 ? _t$clientX : t.plotX) !== null && _ref5 !== void 0 ? _ref5 : 0,\n              _n11 = t.plotY || 0;\n            return t.isNode && r && g(r.x) && g(r.y) && (_o19 = r.x, _n11 = r.y), e ? {\n              chartX: s.len + s.pos - _n11,\n              chartY: i.len + i.pos - _o19\n            } : {\n              chartX: _o19 + i.pos,\n              chartY: _n11 + s.pos\n            };\n          }\n          if (r && r.x && r.y) return {\n            chartX: r.x,\n            chartY: r.y\n          };\n        }\n      }, {\n        key: \"getChartPosition\",\n        value: function getChartPosition() {\n          if (this.chartPosition) return this.chartPosition;\n          var t = this.chart.container,\n            e = x(t);\n          this.chartPosition = {\n            left: e.left,\n            top: e.top,\n            scaleX: 1,\n            scaleY: 1\n          };\n          var i = t.offsetHeight,\n            s = t.offsetWidth;\n          return s > 2 && i > 2 && (this.chartPosition.scaleX = e.width / s, this.chartPosition.scaleY = e.height / i), this.chartPosition;\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function getCoordinates(t) {\n          var e = {\n            xAxis: [],\n            yAxis: []\n          };\n          var _iterator5 = _createForOfIteratorHelper(this.chart.axes),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _i28 = _step5.value;\n              e[_i28.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n                axis: _i28,\n                value: _i28.toValue(t[_i28.horiz ? \"chartX\" : \"chartY\"])\n              });\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          return e;\n        }\n      }, {\n        key: \"getHoverData\",\n        value: function getHoverData(t, e, i, s, r, o) {\n          var n = [],\n            a = function a(t) {\n              return t.visible && !(!r && t.directTouch) && y(t.options.enableMouseTracking, !0);\n            },\n            h = e,\n            l,\n            d = {\n              chartX: o ? o.chartX : void 0,\n              chartY: o ? o.chartY : void 0,\n              shared: r\n            };\n          u(this, \"beforeGetHoverData\", d), l = h && !h.stickyTracking ? [h] : i.filter(function (t) {\n            return t.stickyTracking && (d.filter || a)(t);\n          });\n          var c = s && t || !o ? t : this.findNearestKDPoint(l, r, o);\n          return h = c && c.series, c && (r && !h.noSharedTooltip ? (l = i.filter(function (t) {\n            return d.filter ? d.filter(t) : a(t) && !t.noSharedTooltip;\n          })).forEach(function (t) {\n            var e = p(t.points, function (t) {\n              return t.x === c.x && !t.isNull;\n            });\n            f(e) && (t.boosted && t.boost && (e = t.boost.getPoint(e)), n.push(e));\n          }) : n.push(c)), u(this, \"afterGetHoverData\", d = {\n            hoverPoint: c\n          }), {\n            hoverPoint: d.hoverPoint,\n            hoverSeries: h,\n            hoverPoints: n\n          };\n        }\n      }, {\n        key: \"getPointFromEvent\",\n        value: function getPointFromEvent(t) {\n          var e = t.target,\n            i;\n          for (; e && !i;) i = e.point, e = e.parentNode;\n          return i;\n        }\n      }, {\n        key: \"onTrackerMouseOut\",\n        value: function onTrackerMouseOut(t) {\n          var e = this.chart,\n            i = t.relatedTarget,\n            s = e.hoverSeries;\n          this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, \"highcharts-tooltip\") || this.inClass(i, \"highcharts-series-\" + s.index) && this.inClass(i, \"highcharts-tracker\") || s.onMouseOut();\n        }\n      }, {\n        key: \"inClass\",\n        value: function inClass(t, e) {\n          var i = t,\n            s;\n          for (; i;) {\n            if (s = l(i, \"class\")) {\n              if (-1 !== s.indexOf(e)) return !0;\n              if (-1 !== s.indexOf(\"highcharts-container\")) return !1;\n            }\n            i = i.parentElement;\n          }\n        }\n      }, {\n        key: \"normalize\",\n        value: function normalize(t, e) {\n          var i = t.touches,\n            s = i ? i.length ? i.item(0) : y(i.changedTouches, t.changedTouches)[0] : t;\n          e || (e = this.getChartPosition());\n          var r = s.pageX - e.left,\n            o = s.pageY - e.top;\n          return c(t, {\n            chartX: Math.round(r /= e.scaleX),\n            chartY: Math.round(o /= e.scaleY)\n          });\n        }\n      }, {\n        key: \"onContainerClick\",\n        value: function onContainerClick(t) {\n          var e = this.chart,\n            i = e.hoverPoint,\n            s = this.normalize(t),\n            r = e.plotLeft,\n            o = e.plotTop;\n          !e.cancelClick && (i && this.inClass(s.target, \"highcharts-tracker\") ? (u(i.series, \"click\", c(s, {\n            point: i\n          })), e.hoverPoint && i.firePointEvent(\"click\", s)) : (c(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - r, s.chartY - o, {\n            visiblePlotOnly: !0\n          }) && u(e, \"click\", s)));\n        }\n      }, {\n        key: \"onContainerMouseDown\",\n        value: function onContainerMouseDown(t) {\n          var _t$preventDefault, _t51;\n          var i = (1 & (t.buttons || t.button)) == 1;\n          t = this.normalize(t), e.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || i) && (this.zoomOption(t), i && (_t$preventDefault = (_t51 = t).preventDefault) !== null && _t$preventDefault !== void 0 && _t$preventDefault.call(_t51), this.dragStart(t));\n        }\n      }, {\n        key: \"onContainerMouseLeave\",\n        value: function onContainerMouseLeave(t) {\n          var _ref6 = o[y(S.hoverChartIndex, -1)] || {},\n            e = _ref6.pointer;\n          t = this.normalize(t), this.onContainerMouseMove(t), e && !this.inClass(t.relatedTarget, \"highcharts-tooltip\") && (e.reset(), e.chartPosition = void 0);\n        }\n      }, {\n        key: \"onContainerMouseEnter\",\n        value: function onContainerMouseEnter() {\n          delete this.chartPosition;\n        }\n      }, {\n        key: \"onContainerMouseMove\",\n        value: function onContainerMouseMove(t) {\n          var e = this.chart,\n            i = e.tooltip,\n            s = this.normalize(t);\n          this.setHoverChartIndex(t), (\"mousedown\" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.openMenu && (this.inClass(s.target, \"highcharts-tracker\") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {\n            visiblePlotOnly: !0\n          })) && !(i && i.shouldStickOnContact(s)) && (this.inClass(s.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(s));\n        }\n      }, {\n        key: \"onDocumentTouchEnd\",\n        value: function onDocumentTouchEnd(t) {\n          this.onDocumentMouseUp(t);\n        }\n      }, {\n        key: \"onContainerTouchMove\",\n        value: function onContainerTouchMove(t) {\n          this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);\n        }\n      }, {\n        key: \"onContainerTouchStart\",\n        value: function onContainerTouchStart(t) {\n          this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));\n        }\n      }, {\n        key: \"onDocumentMouseMove\",\n        value: function onDocumentMouseMove(t) {\n          var e = this.chart,\n            i = e.tooltip,\n            s = this.chartPosition,\n            r = this.normalize(t, s);\n          !s || e.isInsidePlot(r.chartX - e.plotLeft, r.chartY - e.plotTop, {\n            visiblePlotOnly: !0\n          }) || i && i.shouldStickOnContact(r) || r.target !== e.container.ownerDocument && this.inClass(r.target, \"highcharts-tracker\") || this.reset();\n        }\n      }, {\n        key: \"onDocumentMouseUp\",\n        value: function onDocumentMouseUp(t) {\n          var _o$y;\n          (_o$y = o[y(S.hoverChartIndex, -1)]) === null || _o$y === void 0 || (_o$y = _o$y.pointer) === null || _o$y === void 0 || _o$y.drop(t);\n        }\n      }, {\n        key: \"pinch\",\n        value: function pinch(t) {\n          var _this12 = this;\n          var e = this,\n            i = e.chart,\n            s = e.hasZoom,\n            r = e.lastTouches,\n            o = [].map.call(t.touches || [], function (t) {\n              return e.normalize(t);\n            }),\n            n = o.length,\n            a = 1 === n && (e.inClass(t.target, \"highcharts-tracker\") && i.runTrackerClick || e.runChartClick),\n            h = i.tooltip,\n            l = 1 === n && y(h === null || h === void 0 ? void 0 : h.options.followTouchMove, !0);\n          n > 1 ? e.initiated = !0 : l && (e.initiated = !1), s && e.initiated && !a && !1 !== t.cancelable && t.preventDefault(), \"touchstart\" === t.type ? (e.pinchDown = o, e.res = !0, i.mouseDownX = t.chartX) : l ? this.runPointActions(e.normalize(t)) : r && (u(i, \"touchpan\", {\n            originalEvent: t,\n            touches: o\n          }, function () {\n            var e = function e(t) {\n              var e = t[0],\n                i = t[1] || e;\n              return {\n                x: e.chartX,\n                y: e.chartY,\n                width: i.chartX - e.chartX,\n                height: i.chartY - e.chartY\n              };\n            };\n            i.transform({\n              axes: i.axes.filter(function (t) {\n                return t.zoomEnabled && (_this12.zoomHor && t.horiz || _this12.zoomVert && !t.horiz);\n              }),\n              to: e(o),\n              from: e(r),\n              trigger: t.type\n            });\n          }), e.res && (e.res = !1, this.reset(!1, 0))), e.lastTouches = o;\n        }\n      }, {\n        key: \"reset\",\n        value: function reset(t, e) {\n          var i = this.chart,\n            s = i.hoverSeries,\n            r = i.hoverPoint,\n            o = i.hoverPoints,\n            n = i.tooltip,\n            a = n && n.shared ? o : r;\n          t && a && v(a).forEach(function (e) {\n            e.series.isCartesian && void 0 === e.plotX && (t = !1);\n          }), t ? n && a && v(a).length && (n.refresh(a), n.shared && o ? o.forEach(function (t) {\n            t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));\n          }) : r && (r.setState(r.state, !0), i.axes.forEach(function (t) {\n            t.crosshair && r.series[t.coll] === t && t.drawCrosshair(null, r);\n          }))) : (r && r.onMouseOut(), o && o.forEach(function (t) {\n            t.setState();\n          }), s && s.onMouseOut(), n && n.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function (t) {\n            t.hideCrosshair();\n          }), i.hoverPoints = i.hoverPoint = void 0);\n        }\n      }, {\n        key: \"runPointActions\",\n        value: function runPointActions(t, e, i) {\n          var s = this.chart,\n            r = s.series,\n            n = s.tooltip && s.tooltip.options.enabled ? s.tooltip : void 0,\n            a = !!n && n.shared,\n            l = e || s.hoverPoint,\n            d = l && l.series || s.hoverSeries,\n            c = (!t || \"touchmove\" !== t.type) && (!!e || d && d.directTouch && this.isDirectTouch),\n            u = this.getHoverData(l, d, r, c, a, t);\n          l = u.hoverPoint, d = u.hoverSeries;\n          var g = u.hoverPoints,\n            f = d && d.tooltipOptions.followPointer && !d.tooltipOptions.split,\n            m = a && d && !d.noSharedTooltip;\n          if (l && (i || l !== s.hoverPoint || n && n.isHidden)) {\n            if ((s.hoverPoints || []).forEach(function (t) {\n              -1 === g.indexOf(t) && t.setState();\n            }), s.hoverSeries !== d && d.onMouseOver(), this.applyInactiveState(g), (g || []).forEach(function (t) {\n              t.setState(\"hover\");\n            }), s.hoverPoint && s.hoverPoint.firePointEvent(\"mouseOut\"), !l.series) return;\n            s.hoverPoints = g, s.hoverPoint = l, l.firePointEvent(\"mouseOver\", void 0, function () {\n              n && l && n.refresh(m ? g : l, t);\n            });\n          } else if (f && n && !n.isHidden) {\n            var _e33 = n.getAnchor([{}], t);\n            s.isInsidePlot(_e33[0], _e33[1], {\n              visiblePlotOnly: !0\n            }) && n.updatePosition({\n              plotX: _e33[0],\n              plotY: _e33[1]\n            });\n          }\n          this.unDocMouseMove || (this.unDocMouseMove = h(s.container.ownerDocument, \"mousemove\", function (t) {\n            var _o20, _S$hoverChartIndex;\n            return (_o20 = o[(_S$hoverChartIndex = S.hoverChartIndex) !== null && _S$hoverChartIndex !== void 0 ? _S$hoverChartIndex : -1]) === null || _o20 === void 0 || (_o20 = _o20.pointer) === null || _o20 === void 0 ? void 0 : _o20.onDocumentMouseMove(t);\n          }), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function (e) {\n            var i;\n            var r = y((e.crosshair || {}).snap, !0);\n            !r || (i = s.hoverPoint) && i.series[e.coll] === e || (i = p(g, function (t) {\n              return t.series && t.series[e.coll] === e;\n            })), i || !r ? e.drawCrosshair(t, i) : e.hideCrosshair();\n          });\n        }\n      }, {\n        key: \"setDOMEvents\",\n        value: function setDOMEvents() {\n          var _this13 = this;\n          var t = this.chart.container,\n            e = t.ownerDocument;\n          t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(h(t, \"mouseenter\", this.onContainerMouseEnter.bind(this)), h(t, \"mouseleave\", this.onContainerMouseLeave.bind(this))), S.unbindDocumentMouseUp || (S.unbindDocumentMouseUp = []), S.unbindDocumentMouseUp.push(h(e, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n          var i = this.chart.renderTo.parentElement;\n          for (; i && \"BODY\" !== i.tagName;) this.eventsToUnbind.push(h(i, \"scroll\", function () {\n            delete _this13.chartPosition;\n          })), i = i.parentElement;\n          this.eventsToUnbind.push(h(t, \"touchstart\", this.onContainerTouchStart.bind(this), {\n            passive: !1\n          }), h(t, \"touchmove\", this.onContainerTouchMove.bind(this), {\n            passive: !1\n          })), S.unbindDocumentTouchEnd || (S.unbindDocumentTouchEnd = h(e, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n            passive: !1\n          })), this.setPointerCapture(), h(this.chart, \"redraw\", this.setPointerCapture.bind(this));\n        }\n      }, {\n        key: \"setPointerCapture\",\n        value: function setPointerCapture() {\n          var _e$options$tooltip, _e$options$chart$styl;\n          if (!a) return;\n          var t = this.pointerCaptureEventsToUnbind,\n            e = this.chart,\n            i = e.container,\n            s = y((_e$options$tooltip = e.options.tooltip) === null || _e$options$tooltip === void 0 ? void 0 : _e$options$tooltip.followTouchMove, !0) && e.series.some(function (t) {\n              return t.options.findNearestPointBy.indexOf(\"y\") > -1;\n            });\n          !this.hasPointerCapture && s ? (t.push(h(i, \"pointerdown\", function (t) {\n            var _t$target, _t$target2;\n            ((_t$target = t.target) === null || _t$target === void 0 ? void 0 : _t$target.hasPointerCapture(t.pointerId)) && ((_t$target2 = t.target) === null || _t$target2 === void 0 ? void 0 : _t$target2.releasePointerCapture(t.pointerId));\n          }), h(i, \"pointermove\", function (t) {\n            var _e$pointer;\n            (_e$pointer = e.pointer) === null || _e$pointer === void 0 || (_e$pointer = _e$pointer.getPointFromEvent(t)) === null || _e$pointer === void 0 || _e$pointer.onMouseOver(t);\n          })), e.styledMode || d(i, {\n            \"touch-action\": \"none\"\n          }), i.className += \" highcharts-no-touch-action\", this.hasPointerCapture = !0) : this.hasPointerCapture && !s && (t.forEach(function (t) {\n            return t();\n          }), t.length = 0, e.styledMode || d(i, {\n            \"touch-action\": y((_e$options$chart$styl = e.options.chart.style) === null || _e$options$chart$styl === void 0 ? void 0 : _e$options$chart$styl[\"touch-action\"], \"manipulation\")\n          }), i.className = i.className.replace(\" highcharts-no-touch-action\", \"\"), this.hasPointerCapture = !1);\n        }\n      }, {\n        key: \"setHoverChartIndex\",\n        value: function setHoverChartIndex(t) {\n          var i = this.chart,\n            s = e.charts[y(S.hoverChartIndex, -1)];\n          if (s && s !== i) {\n            var _t52, _s$pointer;\n            var _e34 = {\n              relatedTarget: i.container\n            };\n            t && !((_t52 = t) !== null && _t52 !== void 0 && _t52.relatedTarget) && (t = _objectSpread(_objectSpread({}, _e34), t)), (_s$pointer = s.pointer) === null || _s$pointer === void 0 ? void 0 : _s$pointer.onContainerMouseLeave(t || _e34);\n          }\n          s && s.mouseIsDown || (S.hoverChartIndex = i.index);\n        }\n      }, {\n        key: \"touch\",\n        value: function touch(t, e) {\n          var i;\n          var s = this.chart,\n            _this$pinchDown = this.pinchDown,\n            r = _this$pinchDown === void 0 ? [] : _this$pinchDown;\n          this.setHoverChartIndex(), 1 === (t = this.normalize(t)).touches.length ? s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, {\n            visiblePlotOnly: !0\n          }) && !s.openMenu ? (e && this.runPointActions(t), \"touchmove\" === t.type && (i = !!r[0] && Math.pow(r[0].chartX - t.chartX, 2) + Math.pow(r[0].chartY - t.chartY, 2) >= 16), y(i, !0) && this.pinch(t)) : e && this.reset() : 2 === t.touches.length && this.pinch(t);\n        }\n      }, {\n        key: \"touchSelect\",\n        value: function touchSelect(t) {\n          return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);\n        }\n      }, {\n        key: \"zoomOption\",\n        value: function zoomOption(t) {\n          var e = this.chart,\n            i = e.inverted,\n            s = e.zooming.type || \"\",\n            r,\n            o;\n          /touch/.test(t.type) && (s = y(e.zooming.pinchType, s)), this.zoomX = r = /x/.test(s), this.zoomY = o = /y/.test(s), this.zoomHor = r && !i || o && i, this.zoomVert = o && !i || r && i, this.hasZoom = r || o;\n        }\n      }]);\n    }();\n    return (s = S || (S = {})).compose = function (t) {\n      b(n, \"Core.Pointer\") && h(t, \"beforeRender\", function () {\n        this.pointer = new s(this, this.options);\n      });\n    }, S;\n  }), i(e, \"Core/Legend/LegendSymbol.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.extend,\n      s = t.merge,\n      r = t.pick;\n    return function (t) {\n      function e(t, e, o) {\n        var n = this.legendItem = this.legendItem || {},\n          a = this.chart,\n          h = this.options,\n          _t$baseline = t.baseline,\n          l = _t$baseline === void 0 ? 0 : _t$baseline,\n          d = t.symbolWidth,\n          c = t.symbolHeight,\n          p = this.symbol || \"circle\",\n          u = c / 2,\n          g = a.renderer,\n          f = n.group,\n          m = l - Math.round(c * (o ? .4 : .3)),\n          x = {},\n          y,\n          b = h.marker,\n          v = 0;\n        if (a.styledMode || (x[\"stroke-width\"] = Math.min(h.lineWidth || 0, 24), h.dashStyle ? x.dashstyle = h.dashStyle : \"square\" === h.linecap || (x[\"stroke-linecap\"] = \"round\")), n.line = g.path().addClass(\"highcharts-graph\").attr(x).add(f), o && (n.area = g.path().addClass(\"highcharts-area\").add(f)), x[\"stroke-linecap\"] && (v = Math.min(n.line.strokeWidth(), d) / 2), d) {\n          var _n$area;\n          var _t53 = [[\"M\", v, m], [\"L\", d - v, m]];\n          n.line.attr({\n            d: _t53\n          }), (_n$area = n.area) === null || _n$area === void 0 ? void 0 : _n$area.attr({\n            d: [].concat(_t53, [[\"L\", d - v, l], [\"L\", v, l]])\n          });\n        }\n        if (b && !1 !== b.enabled && d) {\n          var _t54 = Math.min(r(b.radius, u), u);\n          0 === p.indexOf(\"url\") && (b = s(b, {\n            width: c,\n            height: c\n          }), _t54 = 0), n.symbol = y = g.symbol(p, d / 2 - _t54, m - _t54, 2 * _t54, 2 * _t54, i({\n            context: \"legend\"\n          }, b)).addClass(\"highcharts-point\").add(f), y.isMarker = !0;\n        }\n      }\n      t.areaMarker = function (t, i) {\n        e.call(this, t, i, !0);\n      }, t.lineMarker = e, t.rectangle = function (t, e) {\n        var i = e.legendItem || {},\n          s = t.options,\n          o = t.symbolHeight,\n          n = s.squareSymbol,\n          a = n ? o : t.symbolWidth;\n        i.symbol = this.chart.renderer.rect(n ? (t.symbolWidth - o) / 2 : 0, t.baseline - o + 1, a, o, r(t.options.symbolRadius, o / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(i.group);\n      };\n    }(e || (e = {})), e;\n  }), i(e, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1e3\n      },\n      enableMouseTracking: !0,\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function formatter() {\n          var t = this.series.chart.numberFormatter;\n          return \"number\" != typeof this.y ? \"\" : t(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1e3,\n      findNearestPointBy: \"x\"\n    };\n  }), i(e, \"Core/Series/SeriesRegistry.js\", [e[\"Core/Globals.js\"], e[\"Core/Defaults.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r;\n    var o = e.defaultOptions,\n      n = s.extend,\n      a = s.extendClass,\n      h = s.merge;\n    return function (e) {\n      function s(t, s) {\n        var r = o.plotOptions || {},\n          n = s.defaultOptions,\n          a = s.prototype;\n        return a.type = t, a.pointClass || (a.pointClass = i), !e.seriesTypes[t] && (n && (r[t] = n), e.seriesTypes[t] = s, !0);\n      }\n      e.seriesTypes = t.seriesTypes, e.registerSeriesType = s, e.seriesType = function (t, r, l, d, c) {\n        var p = o.plotOptions || {};\n        if (r = r || \"\", p[t] = h(p[r], l), delete e.seriesTypes[t], s(t, a(e.seriesTypes[r] || function () {}, d)), e.seriesTypes[t].prototype.type = t, c) {\n          var _s31 = /*#__PURE__*/function (_i29) {\n            function _s31() {\n              _classCallCheck(this, _s31);\n              return _callSuper(this, _s31, arguments);\n            }\n            _inherits(_s31, _i29);\n            return _createClass(_s31);\n          }(i);\n          n(_s31.prototype, c), e.seriesTypes[t].prototype.pointClass = _s31;\n        }\n        return e.seriesTypes[t];\n      };\n    }(r || (r = {})), r;\n  }), i(e, \"Core/Series/Series.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Legend/LegendSymbol.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a, h, l) {\n    var d = t.animObject,\n      c = t.setAnimation,\n      p = e.defaultOptions,\n      u = i.registerEventOptions,\n      g = s.svg,\n      f = s.win,\n      m = a.seriesTypes,\n      x = l.arrayMax,\n      y = l.arrayMin,\n      b = l.clamp,\n      v = l.correctFloat,\n      S = l.crisp,\n      C = l.defined,\n      k = l.destroyObjectProperties,\n      M = l.diffObjects,\n      w = l.erase,\n      A = l.error,\n      T = l.extend,\n      P = l.find,\n      L = l.fireEvent,\n      O = l.getClosestDistance,\n      D = l.getNestedProperty,\n      E = l.insertItem,\n      I = l.isArray,\n      j = l.isNumber,\n      B = l.isString,\n      R = l.merge,\n      z = l.objectEach,\n      N = l.pick,\n      W = l.removeEvent,\n      G = l.splat,\n      H = l.syncTimeout;\n    var X = /*#__PURE__*/function () {\n      function X() {\n        _classCallCheck(this, X);\n        this.zoneAxis = \"y\";\n      }\n      return _createClass(X, [{\n        key: \"init\",\n        value: function init(t, e) {\n          var i;\n          L(this, \"init\", {\n            options: e\n          });\n          var s = this,\n            r = t.series;\n          this.eventsToUnbind = [], s.chart = t, s.options = s.setOptions(e);\n          var o = s.options,\n            n = !1 !== o.visible;\n          s.linkedSeries = [], s.bindAxes(), T(s, {\n            name: o.name,\n            state: \"\",\n            visible: n,\n            selected: !0 === o.selected\n          }), u(this, o);\n          var a = o.events;\n          (a && a.click || o.point && o.point.events && o.point.events.click || o.allowPointSelect) && (t.runTrackerClick = !0), s.getColor(), s.getSymbol(), s.parallelArrays.forEach(function (t) {\n            s[t + \"Data\"] || (s[t + \"Data\"] = []);\n          }), s.isCartesian && (t.hasCartesianSeries = !0), r.length && (i = r[r.length - 1]), s._i = N(i && i._i, -1) + 1, s.opacity = s.options.opacity, t.orderItems(\"series\", E(this, r)), o.dataSorting && o.dataSorting.enabled ? s.setDataSortingOptions() : s.points || s.data || s.setData(o.data, !1), L(this, \"afterInit\");\n        }\n      }, {\n        key: \"is\",\n        value: function is(t) {\n          return m[t] && this instanceof m[t];\n        }\n      }, {\n        key: \"bindAxes\",\n        value: function bindAxes() {\n          var t;\n          var e = this,\n            i = e.options,\n            s = e.chart;\n          L(this, \"bindAxes\", null, function () {\n            (e.axisTypes || []).forEach(function (r) {\n              (s[r] || []).forEach(function (s) {\n                t = s.options, (N(i[r], 0) === s.index || void 0 !== i[r] && i[r] === t.id) && (E(e, s.series), e[r] = s, s.isDirty = !0);\n              }), e[r] || e.optionalAxis === r || A(18, !0, s);\n            });\n          }), L(this, \"afterBindAxes\");\n        }\n      }, {\n        key: \"updateParallelArrays\",\n        value: function updateParallelArrays(t, e, i) {\n          var s = t.series,\n            r = j(e) ? function (i) {\n              var r = \"y\" === i && s.toYData ? s.toYData(t) : t[i];\n              s[i + \"Data\"][e] = r;\n            } : function (t) {\n              Array.prototype[e].apply(s[t + \"Data\"], i);\n            };\n          s.parallelArrays.forEach(r);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && this.yData.length > 0;\n        }\n      }, {\n        key: \"hasMarkerChanged\",\n        value: function hasMarkerChanged(t, e) {\n          var i = t.marker,\n            s = e.marker || {};\n          return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);\n        }\n      }, {\n        key: \"autoIncrement\",\n        value: function autoIncrement(t) {\n          var e = this.options,\n            i = e.pointIntervalUnit,\n            s = e.relativeXValue,\n            r = this.chart.time,\n            o = this.xIncrement,\n            n,\n            a;\n          return (o = N(o, e.pointStart, 0), this.pointInterval = a = N(this.pointInterval, e.pointInterval, 1), s && j(t) && (a *= t), i && (n = new r.Date(o), \"day\" === i ? r.set(\"Date\", n, r.get(\"Date\", n) + a) : \"month\" === i ? r.set(\"Month\", n, r.get(\"Month\", n) + a) : \"year\" === i && r.set(\"FullYear\", n, r.get(\"FullYear\", n) + a), a = n.getTime() - o), s && j(t)) ? o + a : (this.xIncrement = o + a, o);\n        }\n      }, {\n        key: \"setDataSortingOptions\",\n        value: function setDataSortingOptions() {\n          var t = this.options;\n          T(this, {\n            requireSorting: !1,\n            sorted: !1,\n            enabledDataSorting: !0,\n            allowDG: !1\n          }), C(t.pointRange) || (t.pointRange = 1);\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(t) {\n          var _p$plotOptions$series, _l$series;\n          var e;\n          var i = this.chart,\n            s = i.options.plotOptions,\n            r = i.userOptions || {},\n            o = R(t),\n            n = i.styledMode,\n            a = {\n              plotOptions: s,\n              userOptions: o\n            };\n          L(this, \"setOptions\", a);\n          var h = a.plotOptions[this.type],\n            l = r.plotOptions || {},\n            d = l.series || {},\n            c = p.plotOptions[this.type] || {},\n            u = l[this.type] || {};\n          this.userOptions = a.userOptions;\n          var g = R(h, s.series, u, o);\n          this.tooltipOptions = R(p.tooltip, (_p$plotOptions$series = p.plotOptions.series) === null || _p$plotOptions$series === void 0 ? void 0 : _p$plotOptions$series.tooltip, c === null || c === void 0 ? void 0 : c.tooltip, i.userOptions.tooltip, (_l$series = l.series) === null || _l$series === void 0 ? void 0 : _l$series.tooltip, u.tooltip, o.tooltip), this.stickyTracking = N(o.stickyTracking, u.stickyTracking, d.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || g.stickyTracking), null === h.marker && delete g.marker, this.zoneAxis = g.zoneAxis || \"y\";\n          var f = this.zones = (g.zones || []).map(function (t) {\n            return _objectSpread({}, t);\n          });\n          return (g.negativeColor || g.negativeFillColor) && !g.zones && (e = {\n            value: g[this.zoneAxis + \"Threshold\"] || g.threshold || 0,\n            className: \"highcharts-negative\"\n          }, n || (e.color = g.negativeColor, e.fillColor = g.negativeFillColor), f.push(e)), f.length && C(f[f.length - 1].value) && f.push(n ? {} : {\n            color: this.color,\n            fillColor: this.fillColor\n          }), L(this, \"afterSetOptions\", {\n            options: g\n          }), g;\n        }\n      }, {\n        key: \"getName\",\n        value: function getName() {\n          return N(this.options.name, \"Series \" + (this.index + 1));\n        }\n      }, {\n        key: \"getCyclic\",\n        value: function getCyclic(t, e, i) {\n          var s, r;\n          var o = this.chart,\n            n = \"\".concat(t, \"Index\"),\n            a = \"\".concat(t, \"Counter\"),\n            h = (i === null || i === void 0 ? void 0 : i.length) || o.options.chart.colorCount;\n          !e && (C(r = N(\"color\" === t ? this.options.colorIndex : void 0, this[n])) ? s = r : (o.series.length || (o[a] = 0), s = o[a] % h, o[a] += 1), i && (e = i[s])), void 0 !== s && (this[n] = s), this[t] = e;\n        }\n      }, {\n        key: \"getColor\",\n        value: function getColor() {\n          this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || p.plotOptions[this.type].color, this.chart.options.colors);\n        }\n      }, {\n        key: \"getPointsCollection\",\n        value: function getPointsCollection() {\n          return (this.hasGroupedData ? this.points : this.data) || [];\n        }\n      }, {\n        key: \"getSymbol\",\n        value: function getSymbol() {\n          var t = this.options.marker;\n          this.getCyclic(\"symbol\", t.symbol, this.chart.options.symbols);\n        }\n      }, {\n        key: \"findPointIndex\",\n        value: function findPointIndex(t, e) {\n          var i, s, r;\n          var n = t.id,\n            a = t.x,\n            h = this.points,\n            l = this.options.dataSorting;\n          if (n) {\n            var _t55 = this.chart.get(n);\n            _t55 instanceof o && (i = _t55);\n          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {\n            var _e35 = function _e35(e) {\n              return !e.touched && e.index === t.index;\n            };\n            if (l && l.matchByName ? _e35 = function _e35(e) {\n              return !e.touched && e.name === t.name;\n            } : this.options.relativeXValue && (_e35 = function _e35(e) {\n              return !e.touched && e.options.x === t.x;\n            }), !(i = P(h, _e35))) return;\n          }\n          return i && void 0 !== (r = i && i.index) && (s = !0), void 0 === r && j(a) && (r = this.xData.indexOf(a, e)), -1 !== r && void 0 !== r && this.cropped && (r = r >= this.cropStart ? r - this.cropStart : r), !s && j(r) && h[r] && h[r].touched && (r = void 0), r;\n        }\n      }, {\n        key: \"updateData\",\n        value: function updateData(t, e) {\n          var i = this.options,\n            s = i.dataSorting,\n            r = this.points,\n            o = [],\n            n = this.requireSorting,\n            a = t.length === r.length,\n            h,\n            l,\n            d,\n            c,\n            p = !0;\n          if (this.xIncrement = null, t.forEach(function (t, e) {\n            var l;\n            var d = C(t) && this.pointClass.prototype.optionsToObject.call({\n                series: this\n              }, t) || {},\n              p = d.x;\n            d.id || j(p) ? (-1 === (l = this.findPointIndex(d, c)) || void 0 === l ? o.push(t) : r[l] && t !== i.data[l] ? (r[l].update(t, !1, null, !1), r[l].touched = !0, n && (c = l + 1)) : r[l] && (r[l].touched = !0), (!a || e !== l || s && s.enabled || this.hasDerivedData) && (h = !0)) : o.push(t);\n          }, this), h) for (l = r.length; l--;) (d = r[l]) && !d.touched && d.remove && d.remove(!1, e);else !a || s && s.enabled ? p = !1 : (t.forEach(function (t, e) {\n            t === r[e].y || r[e].destroyed || r[e].update(t, !1, null, !1);\n          }), o.length = 0);\n          return r.forEach(function (t) {\n            t && (t.touched = !1);\n          }), !!p && (o.forEach(function (t) {\n            this.addPoint(t, !1, null, null, !1);\n          }, this), null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement()), !0);\n        }\n      }, {\n        key: \"setData\",\n        value: function setData(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          var i = arguments.length > 2 ? arguments[2] : undefined;\n          var s = arguments.length > 3 ? arguments[3] : undefined;\n          var r = this,\n            o = r.points,\n            n = o && o.length || 0,\n            a = r.options,\n            h = r.chart,\n            l = a.dataSorting,\n            d = r.xAxis,\n            c = a.turboThreshold,\n            p = this.xData,\n            u = this.yData,\n            g = r.pointArrayMap,\n            f = g && g.length,\n            m = a.keys,\n            x,\n            y,\n            b,\n            v = 0,\n            S = 1,\n            C;\n          h.options.chart.allowMutatingData || (a.data && delete r.options.data, r.userOptions.data && delete r.userOptions.data, C = R(!0, t));\n          var k = (t = C || t || []).length;\n          if (l && l.enabled && (t = this.sortData(t)), h.options.chart.allowMutatingData && !1 !== s && k && n && !r.cropped && !r.hasGroupedData && r.visible && !r.boosted && (b = this.updateData(t, i)), !b) {\n            r.xIncrement = null, r.colorCounter = 0, this.parallelArrays.forEach(function (t) {\n              r[t + \"Data\"].length = 0;\n            });\n            var _e36 = c && k > c;\n            if (_e36) {\n              var _i30 = r.getFirstValidPoint(t),\n                _s32 = r.getFirstValidPoint(t, k - 1, -1),\n                _o21 = function _o21(t) {\n                  return !!(I(t) && (m || j(t[0])));\n                };\n              if (j(_i30) && j(_s32)) for (x = 0; x < k; x++) p[x] = this.autoIncrement(), u[x] = t[x];else if (_o21(_i30) && _o21(_s32)) {\n                if (f) {\n                  if (_i30.length === f) for (x = 0; x < k; x++) p[x] = this.autoIncrement(), u[x] = t[x];else for (x = 0; x < k; x++) y = t[x], p[x] = y[0], u[x] = y.slice(1, f + 1);\n                } else if (m && (v = m.indexOf(\"x\"), S = m.indexOf(\"y\"), v = v >= 0 ? v : 0, S = S >= 0 ? S : 1), 1 === _i30.length && (S = 0), v === S) for (x = 0; x < k; x++) p[x] = this.autoIncrement(), u[x] = t[x][S];else for (x = 0; x < k; x++) y = t[x], p[x] = y[v], u[x] = y[S];\n              } else _e36 = !1;\n            }\n            if (!_e36) for (x = 0; x < k; x++) y = {\n              series: r\n            }, r.pointClass.prototype.applyOptions.apply(y, [t[x]]), r.updateParallelArrays(y, x);\n            for (u && B(u[0]) && A(14, !0, h), r.data = [], r.options.data = r.userOptions.data = t, x = n; x--;) {\n              var _o$x;\n              (_o$x = o[x]) === null || _o$x === void 0 || _o$x.destroy();\n            }\n            d && (d.minRange = d.userMinRange), r.isDirty = h.isDirtyBox = !0, r.isDirtyData = !!o, i = !1;\n          }\n          \"point\" === a.legendType && (this.processData(), this.generatePoints()), e && h.redraw(i);\n        }\n      }, {\n        key: \"sortData\",\n        value: function sortData(t) {\n          var e = this,\n            i = e.options.dataSorting.sortKey || \"y\",\n            s = function s(t, e) {\n              return C(e) && t.pointClass.prototype.optionsToObject.call({\n                series: t\n              }, e) || {};\n            };\n          return t.forEach(function (i, r) {\n            t[r] = s(e, i), t[r].index = r;\n          }, this), t.concat().sort(function (t, e) {\n            var s = D(i, t),\n              r = D(i, e);\n            return r < s ? -1 : r > s ? 1 : 0;\n          }).forEach(function (t, e) {\n            t.x = e;\n          }, this), e.linkedSeries && e.linkedSeries.forEach(function (e) {\n            var i = e.options,\n              r = i.data;\n            i.dataSorting && i.dataSorting.enabled || !r || (r.forEach(function (i, o) {\n              r[o] = s(e, i), t[o] && (r[o].x = t[o].x, r[o].index = o);\n            }), e.setData(r, !1));\n          }), t;\n        }\n      }, {\n        key: \"getProcessedData\",\n        value: function getProcessedData(t) {\n          var e = this,\n            i = e.xAxis,\n            s = e.options.cropThreshold,\n            r = i === null || i === void 0 ? void 0 : i.logarithmic,\n            o = e.isCartesian,\n            n,\n            a,\n            h = 0,\n            l,\n            d,\n            c,\n            p = e.xData,\n            u = e.yData,\n            g = !1,\n            f = p.length;\n          i && (d = (l = i.getExtremes()).min, c = l.max, g = !!(i.categories && !i.names.length)), o && e.sorted && !t && (!s || f > s || e.forceCrop) && (p[f - 1] < d || p[0] > c ? (p = [], u = []) : e.yData && (p[0] < d || p[f - 1] > c) && (p = (n = this.cropData(e.xData, e.yData, d, c)).xData, u = n.yData, h = n.start, a = !0));\n          var m = O([r ? p.map(r.log2lin) : p], function () {\n            return e.requireSorting && !g && A(15, !1, e.chart);\n          });\n          return {\n            xData: p,\n            yData: u,\n            cropped: a,\n            cropStart: h,\n            closestPointRange: m\n          };\n        }\n      }, {\n        key: \"processData\",\n        value: function processData(t) {\n          var e = this.xAxis;\n          if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;\n          var i = this.getProcessedData();\n          this.cropped = i.cropped, this.cropStart = i.cropStart, this.processedXData = i.xData, this.processedYData = i.yData, this.closestPointRange = this.basePointRange = i.closestPointRange, L(this, \"afterProcessData\");\n        }\n      }, {\n        key: \"cropData\",\n        value: function cropData(t, e, i, s) {\n          var r = t.length,\n            o,\n            n,\n            a = 0,\n            h = r;\n          for (o = 0; o < r; o++) if (t[o] >= i) {\n            a = Math.max(0, o - 1);\n            break;\n          }\n          for (n = o; n < r; n++) if (t[n] > s) {\n            h = n + 1;\n            break;\n          }\n          return {\n            xData: t.slice(a, h),\n            yData: e.slice(a, h),\n            start: a,\n            end: h\n          };\n        }\n      }, {\n        key: \"generatePoints\",\n        value: function generatePoints() {\n          var t = this.options,\n            e = this.processedData || t.data,\n            i = this.processedXData,\n            s = this.processedYData,\n            r = this.pointClass,\n            o = i.length,\n            n = this.cropStart || 0,\n            a = this.hasGroupedData,\n            h = t.keys,\n            l = [],\n            d = t.dataGrouping && t.dataGrouping.groupAll ? n : 0,\n            c,\n            p,\n            u,\n            g,\n            f = this.data;\n          if (!f && !a) {\n            var _t56 = [];\n            _t56.length = e.length, f = this.data = _t56;\n          }\n          for (h && a && (this.options.keys = !1), g = 0; g < o; g++) p = n + g, a ? ((u = new r(this, [i[g]].concat(G(s[g])))).dataGroup = this.groupMap[d + g], u.dataGroup.options && (u.options = u.dataGroup.options, T(u, u.dataGroup.options), delete u.dataLabels)) : (u = f[p]) || void 0 === e[p] || (f[p] = u = new r(this, e[p], i[g])), u && (u.index = a ? d + g : p, l[g] = u);\n          if (this.options.keys = h, f && (o !== (c = f.length) || a)) for (g = 0; g < c; g++) g !== n || a || (g += o), f[g] && (f[g].destroyElements(), f[g].plotX = void 0);\n          this.data = f, this.points = l, L(this, \"afterGeneratePoints\");\n        }\n      }, {\n        key: \"getXExtremes\",\n        value: function getXExtremes(t) {\n          return {\n            min: y(t),\n            max: x(t)\n          };\n        }\n      }, {\n        key: \"getExtremes\",\n        value: function getExtremes(t, e) {\n          var i = this.xAxis,\n            s = this.yAxis,\n            r = [],\n            o = this.requireSorting && !this.is(\"column\") ? 1 : 0,\n            n = !!s && s.positiveValuesOnly,\n            a = e || this.getExtremesFromAll || this.options.getExtremesFromAll,\n            h = this.processedXData,\n            l = this.processedYData,\n            d,\n            c,\n            p,\n            u,\n            g,\n            f,\n            m,\n            b = 0,\n            v = 0,\n            S = 0;\n          if (this.cropped && a) {\n            var _t57 = this.getProcessedData(!0);\n            h = _t57.xData, l = _t57.yData;\n          }\n          var C = (t = t || this.stackedYData || l || []).length,\n            k = h || this.xData;\n          for (i && (b = (d = i.getExtremes()).min, v = d.max), f = 0; f < C; f++) if (u = k[f], c = (j(g = t[f]) || I(g)) && ((j(g) ? g > 0 : g.length) || !n), p = e || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !i || (k[f + o] || u) >= b && (k[f - o] || u) <= v, c && p) {\n            if (m = g.length) for (; m--;) j(g[m]) && (r[S++] = g[m]);else r[S++] = g;\n          }\n          var M = {\n            activeYData: r,\n            dataMin: y(r),\n            dataMax: x(r)\n          };\n          return L(this, \"afterGetExtremes\", {\n            dataExtremes: M\n          }), M;\n        }\n      }, {\n        key: \"applyExtremes\",\n        value: function applyExtremes() {\n          var t = this.getExtremes();\n          return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;\n        }\n      }, {\n        key: \"getFirstValidPoint\",\n        value: function getFirstValidPoint(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n          var s = t.length,\n            r = e;\n          for (; r >= 0 && r < s;) {\n            if (C(t[r])) return t[r];\n            r += i;\n          }\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          this.processedXData || this.processData(), this.generatePoints();\n          var t = this.options,\n            e = t.stacking,\n            i = this.xAxis,\n            s = i.categories,\n            r = this.enabledDataSorting,\n            o = this.yAxis,\n            n = this.points,\n            a = n.length,\n            h = this.pointPlacementToXValue(),\n            l = !!h,\n            d = t.threshold,\n            c = t.startFromThreshold ? d : 0,\n            p,\n            u,\n            g,\n            f,\n            m = Number.MAX_VALUE;\n          function x(t) {\n            return b(t, -1e5, 1e5);\n          }\n          for (p = 0; p < a; p++) {\n            var _o$stacking;\n            var _t58 = void 0;\n            var _a13 = n[p],\n              _y = _a13.x,\n              _b = void 0,\n              _S3 = void 0,\n              _k2 = _a13.y,\n              _M = _a13.low,\n              _w = e && ((_o$stacking = o.stacking) === null || _o$stacking === void 0 ? void 0 : _o$stacking.stacks[(this.negStacks && _k2 < (c ? 0 : d) ? \"-\" : \"\") + this.stackKey]);\n            u = i.translate(_y, !1, !1, !1, !0, h), _a13.plotX = j(u) ? v(x(u)) : void 0, e && this.visible && _w && _w[_y] && (f = this.getStackIndicator(f, _y, this.index), !_a13.isNull && f.key && (_S3 = (_b = _w[_y]).points[f.key]), _b && I(_S3) && (_M = _S3[0], _k2 = _S3[1], _M === c && f.key === _w[_y].base && (_M = N(j(d) ? d : o.min)), o.positiveValuesOnly && C(_M) && _M <= 0 && (_M = void 0), _a13.total = _a13.stackTotal = N(_b.total), _a13.percentage = C(_a13.y) && _b.total ? _a13.y / _b.total * 100 : void 0, _a13.stackY = _k2, this.irregularWidths || _b.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), _a13.yBottom = C(_M) ? x(o.translate(_M, !1, !0, !1, !0)) : void 0, this.dataModify && (_k2 = this.dataModify.modifyValue(_k2, p)), j(_k2) && void 0 !== _a13.plotX && (_t58 = j(_t58 = o.translate(_k2, !1, !0, !1, !0)) ? x(_t58) : void 0), _a13.plotY = _t58, _a13.isInside = this.isPointInside(_a13), _a13.clientX = l ? v(i.translate(_y, !1, !1, !1, !0, h)) : u, _a13.negative = (_a13.y || 0) < (d || 0), _a13.category = N(s && s[_a13.x], _a13.x), _a13.isNull || !1 === _a13.visible || (void 0 !== g && (m = Math.min(m, Math.abs(u - g))), g = u), _a13.zone = this.zones.length ? _a13.getZone() : void 0, !_a13.graphic && this.group && r && (_a13.isNew = !0);\n          }\n          this.closestPointRangePx = m, L(this, \"afterTranslate\");\n        }\n      }, {\n        key: \"getValidPoints\",\n        value: function getValidPoints(t, e, i) {\n          var s = this.chart;\n          return (t || this.points || []).filter(function (t) {\n            var r = t.plotX,\n              o = t.plotY;\n            return !!((i || !t.isNull && j(o)) && (!e || s.isInsidePlot(r, o, {\n              inverted: s.inverted\n            }))) && !1 !== t.visible;\n          });\n        }\n      }, {\n        key: \"getClipBox\",\n        value: function getClipBox() {\n          var _ref7;\n          var t = this.chart,\n            e = this.xAxis,\n            i = this.yAxis,\n            _R = R(t.clipBox),\n            s = _R.x,\n            r = _R.y,\n            o = _R.width,\n            n = _R.height;\n          return e && e.len !== t.plotSizeX && (o = e.len), i && i.len !== t.plotSizeY && (n = i.len), t.inverted && !this.invertible && (_ref7 = [n, o], o = _ref7[0], n = _ref7[1], _ref7), {\n            x: s,\n            y: r,\n            width: o,\n            height: n\n          };\n        }\n      }, {\n        key: \"getSharedClipKey\",\n        value: function getSharedClipKey() {\n          return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0), this.sharedClipKey;\n        }\n      }, {\n        key: \"setClip\",\n        value: function setClip() {\n          var t = this.chart,\n            e = this.group,\n            i = this.markerGroup,\n            s = t.sharedClips,\n            r = t.renderer,\n            o = this.getClipBox(),\n            n = this.getSharedClipKey(),\n            a = s[n];\n          a ? a.animate(o) : s[n] = a = r.clipRect(o), e && e.clip(!1 === this.options.clip ? void 0 : a), i && i.clip();\n        }\n      }, {\n        key: \"animate\",\n        value: function animate(t) {\n          var e = this.chart,\n            i = this.group,\n            s = this.markerGroup,\n            r = e.inverted,\n            o = d(this.options.animation),\n            n = [this.getSharedClipKey(), o.duration, o.easing, o.defer].join(\",\"),\n            a = e.sharedClips[n],\n            h = e.sharedClips[n + \"m\"];\n          if (t && i) {\n            var _t59 = this.getClipBox();\n            if (a) a.attr(\"height\", _t59.height);else {\n              _t59.width = 0, r && (_t59.x = e.plotHeight), a = e.renderer.clipRect(_t59), e.sharedClips[n] = a;\n              var _i31 = {\n                x: -99,\n                y: -99,\n                width: r ? e.plotWidth + 199 : 99,\n                height: r ? 99 : e.plotHeight + 199\n              };\n              h = e.renderer.clipRect(_i31), e.sharedClips[n + \"m\"] = h;\n            }\n            i.clip(a), s === null || s === void 0 ? void 0 : s.clip(h);\n          } else if (a && !a.hasClass(\"highcharts-animating\")) {\n            var _t60 = this.getClipBox(),\n              _i32 = o.step;\n            (s !== null && s !== void 0 && s.element.childNodes.length || e.series.length > 1) && (o.step = function (t, e) {\n              var _h7;\n              _i32 && _i32.apply(e, arguments), \"width\" === e.prop && ((_h7 = h) === null || _h7 === void 0 ? void 0 : _h7.element) && h.attr(r ? \"height\" : \"width\", t + 99);\n            }), a.addClass(\"highcharts-animating\").animate(_t60, o);\n          }\n        }\n      }, {\n        key: \"afterAnimate\",\n        value: function afterAnimate() {\n          var _this14 = this;\n          this.setClip(), z(this.chart.sharedClips, function (t, e, i) {\n            t && !_this14.chart.container.querySelector(\"[clip-path=\\\"url(#\".concat(t.id, \")\\\"]\")) && (t.destroy(), delete i[e]);\n          }), this.finishedAnimating = !0, L(this, \"afterAnimate\");\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var e, i, s, r, o, n, a;\n          var h = this.chart,\n            l = h.styledMode,\n            d = this.colorAxis,\n            c = this.options,\n            p = c.marker,\n            u = this[this.specialGroup || \"markerGroup\"],\n            g = this.xAxis,\n            f = N(p.enabled, !g || !!g.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);\n          if (!1 !== p.enabled || this._hasPointMarkers) for (e = 0; e < t.length; e++) if (r = (s = (i = t[e]).graphic) ? \"animate\" : \"attr\", o = i.marker || {}, n = !!i.marker, (f && void 0 === o.enabled || o.enabled) && !i.isNull && !1 !== i.visible) {\n            var _t61 = N(o.symbol, this.symbol, \"rect\");\n            a = this.markerAttribs(i, i.selected && \"select\"), this.enabledDataSorting && (i.startXPos = g.reversed ? -(a.width || 0) : g.width);\n            var _e37 = !1 !== i.isInside;\n            if (!s && _e37 && ((a.width || 0) > 0 || i.hasImage) && (i.graphic = s = h.renderer.symbol(_t61, a.x, a.y, a.width, a.height, n ? o : p).add(u), this.enabledDataSorting && h.hasRendered && (s.attr({\n              x: i.startXPos\n            }), r = \"animate\")), s && \"animate\" === r && s[_e37 ? \"show\" : \"hide\"](_e37).animate(a), s) {\n              var _t62 = this.pointAttribs(i, l || !i.selected ? void 0 : \"select\");\n              l ? d && s.css({\n                fill: _t62.fill\n              }) : s[r](_t62);\n            }\n            s && s.addClass(i.getClassName(), !0);\n          } else s && (i.graphic = s.destroy());\n        }\n      }, {\n        key: \"markerAttribs\",\n        value: function markerAttribs(t, e) {\n          var i = this.options,\n            s = i.marker,\n            r = t.marker || {},\n            o = r.symbol || s.symbol,\n            n = {},\n            a,\n            h,\n            l = N(r.radius, s && s.radius);\n          e && (a = s.states[e], l = N((h = r.states && r.states[e]) && h.radius, a && a.radius, l && l + (a && a.radiusPlus || 0))), t.hasImage = o && 0 === o.indexOf(\"url\"), t.hasImage && (l = 0);\n          var d = t.pos();\n          return j(l) && d && (i.crisp && (d[0] = S(d[0], t.hasImage ? 0 : \"rect\" === o ? (s === null || s === void 0 ? void 0 : s.lineWidth) || 0 : 1)), n.x = d[0] - l, n.y = d[1] - l), l && (n.width = n.height = 2 * l), n;\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(t, e) {\n          var i = this.options.marker,\n            s = t && t.options,\n            r = s && s.marker || {},\n            o = s && s.color,\n            n = t && t.color,\n            a = t && t.zone && t.zone.color,\n            h,\n            l,\n            d = this.color,\n            c,\n            p,\n            u = N(r.lineWidth, i.lineWidth),\n            g = 1;\n          return d = o || a || n || d, c = r.fillColor || i.fillColor || d, p = r.lineColor || i.lineColor || d, e = e || \"normal\", h = i.states[e] || {}, u = N((l = r.states && r.states[e] || {}).lineWidth, h.lineWidth, u + N(l.lineWidthPlus, h.lineWidthPlus, 0)), c = l.fillColor || h.fillColor || c, {\n            stroke: p = l.lineColor || h.lineColor || p,\n            \"stroke-width\": u,\n            fill: c,\n            opacity: g = N(l.opacity, h.opacity, g)\n          };\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy(t) {\n          var e, i, s;\n          var r = this,\n            o = r.chart,\n            n = /AppleWebKit\\/533/.test(f.navigator.userAgent),\n            a = r.data || [];\n          for (L(r, \"destroy\", {\n            keepEventsForUpdate: t\n          }), this.removeEvents(t), (r.axisTypes || []).forEach(function (t) {\n            (s = r[t]) && s.series && (w(s.series, r), s.isDirty = s.forceRedraw = !0);\n          }), r.legendItem && r.chart.legend.destroyItem(r), e = a.length; e--;) (i = a[e]) && i.destroy && i.destroy();\n          var _iterator6 = _createForOfIteratorHelper(r.zones),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _t63 = _step6.value;\n              k(_t63, void 0, !0);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          l.clearTimeout(r.animationTimeout), z(r, function (t, e) {\n            t instanceof h && !t.survive && t[n && \"group\" === e ? \"hide\" : \"destroy\"]();\n          }), o.hoverSeries === r && (o.hoverSeries = void 0), w(o.series, r), o.orderItems(\"series\"), z(r, function (e, i) {\n            t && \"hcEvents\" === i || delete r[i];\n          });\n        }\n      }, {\n        key: \"applyZones\",\n        value: function applyZones() {\n          var t = this.area,\n            e = this.chart,\n            i = this.graph,\n            s = this.zones,\n            r = this.points,\n            o = this.xAxis,\n            n = this.yAxis,\n            a = this.zoneAxis,\n            h = e.inverted,\n            l = e.renderer,\n            d = this[\"\".concat(a, \"Axis\")],\n            _ref8 = d || {},\n            c = _ref8.isXAxis,\n            _ref8$len = _ref8.len,\n            p = _ref8$len === void 0 ? 0 : _ref8$len,\n            u = ((i === null || i === void 0 ? void 0 : i.strokeWidth()) || 0) / 2 + 1,\n            g = function g(t) {\n              var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n              var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n              h && (i = p - i);\n              var _t$translated = t.translated,\n                s = _t$translated === void 0 ? 0 : _t$translated,\n                r = t.lineClip,\n                o = i - s;\n              r === null || r === void 0 || r.push([\"L\", e, Math.abs(o) < u ? i - u * (o <= 0 ? -1 : 1) : s]);\n            };\n          if (s.length && (i || t) && d && j(d.min)) {\n            var _e38 = d.getExtremes().max,\n              _u2 = function _u2(t) {\n                t.forEach(function (e, i) {\n                  (\"M\" === e[0] || \"L\" === e[0]) && (t[i] = [e[0], c ? p - e[1] : e[1], c ? e[2] : p - e[2]]);\n                });\n              };\n            if (s.forEach(function (t) {\n              t.lineClip = [], t.translated = b(d.toPixels(N(t.value, _e38), !0) || 0, 0, p);\n            }), i && !this.showLine && i.hide(), t && t.hide(), \"y\" === a && r.length < o.len) {\n              var _iterator7 = _createForOfIteratorHelper(r),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _t64 = _step7.value;\n                  var _e39 = _t64.plotX,\n                    _i33 = _t64.plotY,\n                    _r15 = _t64.zone,\n                    _o22 = _r15 && s[s.indexOf(_r15) - 1];\n                  _r15 && g(_r15, _e39, _i33), _o22 && g(_o22, _e39, _i33);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n            var _f = [],\n              _m3 = d.toPixels(d.getExtremes().min, !0);\n            s.forEach(function (e) {\n              var _d6, _e$graph, _e$area;\n              var s = e.lineClip || [],\n                r = Math.round(e.translated || 0);\n              o.reversed && s.reverse();\n              var a = e.clip,\n                d = e.simpleClip,\n                p = 0,\n                g = 0,\n                x = o.len,\n                y = n.len;\n              c ? (p = r, x = _m3) : (g = r, y = _m3);\n              var b = [[\"M\", p, g], [\"L\", x, g], [\"L\", x, y], [\"L\", p, y], [\"Z\"]],\n                v = [b[0]].concat(_toConsumableArray(s), [b[1], b[2]], _toConsumableArray(_f), [b[3], b[4]]);\n              _f = s.reverse(), _m3 = r, h && (_u2(v), t && _u2(b)), a ? (a.animate({\n                d: v\n              }), (_d6 = d) === null || _d6 === void 0 ? void 0 : _d6.animate({\n                d: b\n              })) : (a = e.clip = l.path(v), t && (d = e.simpleClip = l.path(b))), i && (_e$graph = e.graph) !== null && _e$graph !== void 0 && _e$graph.clip(a), t && ((_e$area = e.area) === null || _e$area === void 0 ? void 0 : _e$area.clip(d));\n            });\n          } else this.visible && (i && i.show(), t && t.show());\n        }\n      }, {\n        key: \"plotGroup\",\n        value: function plotGroup(t, e, i, s, r) {\n          var o = this[t],\n            n = !o,\n            a = {\n              visibility: i,\n              zIndex: s || .1\n            };\n          return C(this.opacity) && !this.chart.styledMode && \"inactive\" !== this.state && (a.opacity = this.opacity), o || (this[t] = o = this.chart.renderer.g().add(r)), o.addClass(\"highcharts-\" + e + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (C(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (o.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0), o.attr(a)[n ? \"attr\" : \"animate\"](this.getPlotBox(e)), o;\n        }\n      }, {\n        key: \"getPlotBox\",\n        value: function getPlotBox(t) {\n          var e = this.xAxis,\n            i = this.yAxis,\n            s = this.chart,\n            r = s.inverted && !s.polar && e && this.invertible && \"series\" === t;\n          return s.inverted && (e = i, i = this.xAxis), {\n            translateX: e ? e.left : s.plotLeft,\n            translateY: i ? i.top : s.plotTop,\n            rotation: r ? 90 : 0,\n            rotationOriginX: r ? (e.len - i.len) / 2 : 0,\n            rotationOriginY: r ? (e.len + i.len) / 2 : 0,\n            scaleX: r ? -1 : 1,\n            scaleY: 1\n          };\n        }\n      }, {\n        key: \"removeEvents\",\n        value: function removeEvents(t) {\n          var e = this.eventsToUnbind;\n          t || W(this), e.length && (e.forEach(function (t) {\n            t();\n          }), e.length = 0);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _t$animate, _t$drawDataLabels, _t$redrawPoints, _t$drawTracker, _t$animate2;\n          var t = this,\n            e = t.chart,\n            i = t.options,\n            s = t.hasRendered,\n            r = d(i.animation),\n            o = t.visible ? \"inherit\" : \"hidden\",\n            n = i.zIndex,\n            a = e.seriesGroup,\n            h = t.finishedAnimating ? 0 : r.duration;\n          L(this, \"render\"), t.plotGroup(\"group\", \"series\", o, n, a), t.markerGroup = t.plotGroup(\"markerGroup\", \"markers\", o, n, a), !1 !== i.clip && t.setClip(), h && (_t$animate = t.animate) !== null && _t$animate !== void 0 && _t$animate.call(t, !0), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), (_t$drawDataLabels = t.drawDataLabels) !== null && _t$drawDataLabels !== void 0 && _t$drawDataLabels.call(t), (_t$redrawPoints = t.redrawPoints) !== null && _t$redrawPoints !== void 0 && _t$redrawPoints.call(t), i.enableMouseTracking && (_t$drawTracker = t.drawTracker) !== null && _t$drawTracker !== void 0 && _t$drawTracker.call(t), h && (_t$animate2 = t.animate) !== null && _t$animate2 !== void 0 && _t$animate2.call(t), s || (h && r.defer && (h += r.defer), t.animationTimeout = H(function () {\n            t.afterAnimate();\n          }, h || 0)), t.isDirty = !1, t.hasRendered = !0, L(t, \"afterRender\");\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw() {\n          var t = this.isDirty || this.isDirtyData;\n          this.translate(), this.render(), t && delete this.kdTree;\n        }\n      }, {\n        key: \"reserveSpace\",\n        value: function reserveSpace() {\n          return this.visible || !this.chart.options.chart.ignoreHiddenSeries;\n        }\n      }, {\n        key: \"searchPoint\",\n        value: function searchPoint(t, e) {\n          var i = this.xAxis,\n            s = this.yAxis,\n            r = this.chart.inverted;\n          return this.searchKDTree({\n            clientX: r ? i.len - t.chartY + i.pos : t.chartX - i.pos,\n            plotY: r ? s.len - t.chartX + s.pos : t.chartY - s.pos\n          }, e, t);\n        }\n      }, {\n        key: \"buildKDTree\",\n        value: function buildKDTree(t) {\n          this.buildingKdTree = !0;\n          var e = this,\n            i = e.options.findNearestPointBy.indexOf(\"y\") > -1 ? 2 : 1;\n          delete e.kdTree, H(function () {\n            e.kdTree = function t(i, s, r) {\n              var o, n;\n              var a = i === null || i === void 0 ? void 0 : i.length;\n              if (a) return o = e.kdAxisArray[s % r], i.sort(function (t, e) {\n                return (t[o] || 0) - (e[o] || 0);\n              }), {\n                point: i[n = Math.floor(a / 2)],\n                left: t(i.slice(0, n), s + 1, r),\n                right: t(i.slice(n + 1), s + 1, r)\n              };\n            }(e.getValidPoints(void 0, !e.directTouch), i, i), e.buildingKdTree = !1;\n          }, e.options.kdNow || (t === null || t === void 0 ? void 0 : t.type) === \"touchstart\" ? 0 : 1);\n        }\n      }, {\n        key: \"searchKDTree\",\n        value: function searchKDTree(t, e, i) {\n          var s = this,\n            _this$kdAxisArray = _slicedToArray(this.kdAxisArray, 2),\n            r = _this$kdAxisArray[0],\n            o = _this$kdAxisArray[1],\n            n = e ? \"distX\" : \"dist\",\n            a = (s.options.findNearestPointBy || \"\").indexOf(\"y\") > -1 ? 2 : 1,\n            h = !!s.isBubble;\n          if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, a, l, _d$marker) {\n            var d = i.point,\n              c = s.kdAxisArray[a % l],\n              p,\n              u,\n              g = d;\n            !function (t, e, _e$marker) {\n              var i = t[r],\n                s = e[r],\n                n = C(i) && C(s) ? i - s : null,\n                a = t[o],\n                l = e[o],\n                d = C(a) && C(l) ? a - l : 0,\n                c = h && ((_e$marker = e.marker) === null || _e$marker === void 0 ? void 0 : _e$marker.radius) || 0;\n              e.dist = Math.sqrt((n && n * n || 0) + d * d) - c, e.distX = C(n) ? Math.abs(n) - c : Number.MAX_VALUE;\n            }(e, d);\n            var f = (e[c] || 0) - (d[c] || 0) + (h && ((_d$marker = d.marker) === null || _d$marker === void 0 ? void 0 : _d$marker.radius) || 0),\n              m = f < 0 ? \"left\" : \"right\",\n              x = f < 0 ? \"right\" : \"left\";\n            return i[m] && (g = (p = t(e, i[m], a + 1, l))[n] < g[n] ? p : d), i[x] && Math.sqrt(f * f) < g[n] && (g = (u = t(e, i[x], a + 1, l))[n] < g[n] ? u : g), g;\n          }(t, this.kdTree, a, a);\n        }\n      }, {\n        key: \"pointPlacementToXValue\",\n        value: function pointPlacementToXValue() {\n          var t = this.options,\n            e = this.xAxis,\n            i = t.pointPlacement;\n          return \"between\" === i && (i = e.reversed ? -.5 : .5), j(i) ? i * (t.pointRange || e.pointRange) : 0;\n        }\n      }, {\n        key: \"isPointInside\",\n        value: function isPointInside(t) {\n          var e = this.chart,\n            i = this.xAxis,\n            s = this.yAxis,\n            _t$plotX2 = t.plotX,\n            r = _t$plotX2 === void 0 ? -1 : _t$plotX2,\n            _t$plotY2 = t.plotY,\n            o = _t$plotY2 === void 0 ? -1 : _t$plotY2;\n          return o >= 0 && o <= (s ? s.len : e.plotHeight) && r >= 0 && r <= (i ? i.len : e.plotWidth);\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          var _r$options$tooltip;\n          var t = this,\n            e = t.options,\n            i = e.trackByArea,\n            s = [].concat((i ? t.areaPath : t.graphPath) || []),\n            r = t.chart,\n            o = r.pointer,\n            n = r.renderer,\n            a = ((_r$options$tooltip = r.options.tooltip) === null || _r$options$tooltip === void 0 ? void 0 : _r$options$tooltip.snap) || 0,\n            h = function h() {\n              e.enableMouseTracking && r.hoverSeries !== t && t.onMouseOver();\n            },\n            l = \"rgba(192,192,192,\" + (g ? 1e-4 : .002) + \")\",\n            d = t.tracker;\n          d ? d.attr({\n            d: s\n          }) : t.graph && (t.tracker = d = n.path(s).attr({\n            visibility: t.visible ? \"inherit\" : \"hidden\",\n            zIndex: 2\n          }).addClass(i ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(t.group), r.styledMode || d.attr({\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            stroke: l,\n            fill: i ? l : \"none\",\n            \"stroke-width\": t.graph.strokeWidth() + (i ? 0 : 2 * a)\n          }), [t.tracker, t.markerGroup, t.dataLabelsGroup].forEach(function (t) {\n            t && (t.addClass(\"highcharts-tracker\").on(\"mouseover\", h).on(\"mouseout\", function (t) {\n              o === null || o === void 0 || o.onTrackerMouseOut(t);\n            }), e.cursor && !r.styledMode && t.css({\n              cursor: e.cursor\n            }), t.on(\"touchstart\", h));\n          })), L(this, \"afterDrawTracker\");\n        }\n      }, {\n        key: \"addPoint\",\n        value: function addPoint(t, e, i, s, r) {\n          var o, n;\n          var a = this.options,\n            h = this.data,\n            l = this.chart,\n            d = this.xAxis,\n            c = d && d.hasNames && d.names,\n            p = a.data,\n            u = this.xData;\n          e = N(e, !0);\n          var g = {\n            series: this\n          };\n          this.pointClass.prototype.applyOptions.apply(g, [t]);\n          var f = g.x;\n          if (n = u.length, this.requireSorting && f < u[n - 1]) for (o = !0; n && u[n - 1] > f;) n--;\n          this.updateParallelArrays(g, \"splice\", [n, 0, 0]), this.updateParallelArrays(g, n), c && g.name && (c[f] = g.name), p.splice(n, 0, t), (o || this.processedData) && (this.data.splice(n, 0, null), this.processData()), \"point\" === a.legendType && this.generatePoints(), i && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(g, \"shift\"), p.shift())), !1 !== r && L(this, \"addPoint\", {\n            point: g\n          }), this.isDirty = !0, this.isDirtyData = !0, e && l.redraw(s);\n        }\n      }, {\n        key: \"removePoint\",\n        value: function removePoint(t, e, i) {\n          var s = this,\n            r = s.data,\n            o = r[t],\n            n = s.points,\n            a = s.chart,\n            h = function h() {\n              n && n.length === r.length && n.splice(t, 1), r.splice(t, 1), s.options.data.splice(t, 1), s.updateParallelArrays(o || {\n                series: s\n              }, \"splice\", [t, 1]), o && o.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && a.redraw();\n            };\n          c(i, a), e = N(e, !0), o ? o.firePointEvent(\"remove\", null, h) : h();\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(t, e, i, s) {\n          var r = this,\n            o = r.chart;\n          function n() {\n            r.destroy(s), o.isDirtyLegend = o.isDirtyBox = !0, o.linkSeries(s), N(t, !0) && o.redraw(e);\n          }\n          !1 !== i ? L(r, \"remove\", null, n) : n();\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e) {\n          var _ref9, _n$series$pointStart, _n$series, _i$xData;\n          L(this, \"update\", {\n            options: t = M(t, this.userOptions)\n          });\n          var i = this,\n            s = i.chart,\n            r = i.userOptions,\n            o = i.initialType || i.type,\n            n = s.options.plotOptions,\n            a = m[o].prototype,\n            h = i.finishedAnimating && {\n              animation: !1\n            },\n            l = {},\n            d,\n            c,\n            p = [\"colorIndex\", \"eventOptions\", \"navigatorSeries\", \"symbolIndex\", \"baseSeries\"],\n            u = t.type || r.type || s.options.chart.type,\n            g = !(this.hasDerivedData || u && u !== this.type || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || [\"dataGrouping\", \"pointStart\", \"pointInterval\", \"pointIntervalUnit\", \"keys\"].some(function (t) {\n              return i.hasOptionChanged(t);\n            }));\n          u = u || o, g && (p.push(\"data\", \"isDirtyData\", \"isDirtyCanvas\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"hasDataLabels\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\", \"transformGroups\"), !1 !== t.visible && p.push(\"area\", \"graph\"), i.parallelArrays.forEach(function (t) {\n            p.push(t + \"Data\");\n          }), t.data && (t.dataSorting && T(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))), t = R(r, {\n            index: void 0 === r.index ? i.index : r.index,\n            pointStart: (_ref9 = (_n$series$pointStart = n === null || n === void 0 || (_n$series = n.series) === null || _n$series === void 0 ? void 0 : _n$series.pointStart) !== null && _n$series$pointStart !== void 0 ? _n$series$pointStart : r.pointStart) !== null && _ref9 !== void 0 ? _ref9 : (_i$xData = i.xData) === null || _i$xData === void 0 ? void 0 : _i$xData[0]\n          }, !g && {\n            data: i.options.data\n          }, t, h), g && t.data && (t.data = i.options.data), (p = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(p)).forEach(function (t) {\n            p[t] = i[t], delete i[t];\n          });\n          var f = !1;\n          if (m[u]) {\n            if (f = u !== i.type, i.remove(!1, !1, !1, !0), f) {\n              if (s.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i, m[u].prototype);else {\n                var _t65 = Object.hasOwnProperty.call(i, \"hcEvents\") && i.hcEvents;\n                for (c in a) i[c] = void 0;\n                T(i, m[u].prototype), _t65 ? i.hcEvents = _t65 : delete i.hcEvents;\n              }\n            }\n          } else A(17, !0, s, {\n            missingModuleFor: u\n          });\n          if (p.forEach(function (t) {\n            i[t] = p[t];\n          }), i.init(s, t), g && this.points) {\n            var _i$hasDataLabels;\n            var _iterator8 = _createForOfIteratorHelper((!1 === (d = i.options).visible ? (l.graphic = 1, l.dataLabel = 1) : (this.hasMarkerChanged(d, r) && (l.graphic = 1), ((_i$hasDataLabels = i.hasDataLabels) === null || _i$hasDataLabels === void 0 ? void 0 : _i$hasDataLabels.call(i)) || (l.dataLabel = 1)), this.points)),\n              _step8;\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var _t66 = _step8.value;\n                _t66 && _t66.series && (_t66.resolveColor(), Object.keys(l).length && _t66.destroyElements(l), !1 === d.showInLegend && _t66.legendItem && s.legend.destroyItem(_t66));\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n          i.initialType = o, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), L(this, \"afterUpdate\"), N(e, !0) && s.redraw(!!g && void 0);\n        }\n      }, {\n        key: \"setName\",\n        value: function setName(t) {\n          this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;\n        }\n      }, {\n        key: \"hasOptionChanged\",\n        value: function hasOptionChanged(t) {\n          var _s$this$type, _s$series;\n          var e = this.chart,\n            i = this.options[t],\n            s = e.options.plotOptions,\n            r = this.userOptions[t],\n            o = N(s === null || s === void 0 || (_s$this$type = s[this.type]) === null || _s$this$type === void 0 ? void 0 : _s$this$type[t], s === null || s === void 0 || (_s$series = s.series) === null || _s$series === void 0 ? void 0 : _s$series[t]);\n          return r && !C(o) ? i !== r : i !== N(o, i);\n        }\n      }, {\n        key: \"onMouseOver\",\n        value: function onMouseOver() {\n          var t = this.chart,\n            e = t.hoverSeries,\n            i = t.pointer;\n          i !== null && i !== void 0 && i.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && L(this, \"mouseOver\"), this.setState(\"hover\"), t.hoverSeries = this;\n        }\n      }, {\n        key: \"onMouseOut\",\n        value: function onMouseOut() {\n          var t = this.options,\n            e = this.chart,\n            i = e.tooltip,\n            s = e.hoverPoint;\n          e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && L(this, \"mouseOut\"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function (t) {\n            t.setState(\"\", !0);\n          });\n        }\n      }, {\n        key: \"setState\",\n        value: function setState(t, e) {\n          var i = this,\n            s = i.options,\n            r = i.graph,\n            o = s.inactiveOtherPoints,\n            n = s.states,\n            a = N(n[t || \"normal\"] && n[t || \"normal\"].animation, i.chart.options.chart.animation),\n            h = s.lineWidth,\n            l = s.opacity;\n          if (t = t || \"\", i.state !== t && ([i.group, i.markerGroup, i.dataLabelsGroup].forEach(function (e) {\n            e && (i.state && e.removeClass(\"highcharts-series-\" + i.state), t && e.addClass(\"highcharts-series-\" + t));\n          }), i.state = t, !i.chart.styledMode)) {\n            if (n[t] && !1 === n[t].enabled) return;\n            if (t && (h = n[t].lineWidth || h + (n[t].lineWidthPlus || 0), l = N(n[t].opacity, l)), r && !r.dashstyle && j(h)) for (var _i34 = 0, _arr = [r].concat(_toConsumableArray(this.zones.map(function (t) {\n                return t.graph;\n              }))); _i34 < _arr.length; _i34++) {\n              var _t67 = _arr[_i34];\n              _t67 === null || _t67 === void 0 || _t67.animate({\n                \"stroke-width\": h\n              }, a);\n            }\n            o || [i.group, i.markerGroup, i.dataLabelsGroup, i.labelBySeries].forEach(function (t) {\n              t && t.animate({\n                opacity: l\n              }, a);\n            });\n          }\n          e && o && i.points && i.setAllPointsToState(t || void 0);\n        }\n      }, {\n        key: \"setAllPointsToState\",\n        value: function setAllPointsToState(t) {\n          this.points.forEach(function (e) {\n            e.setState && e.setState(t);\n          });\n        }\n      }, {\n        key: \"setVisible\",\n        value: function setVisible(t, e) {\n          var _s$hoverPoint;\n          var i = this,\n            s = i.chart,\n            r = s.options.chart.ignoreHiddenSeries,\n            o = i.visible;\n          i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !o : t;\n          var n = t ? \"show\" : \"hide\";\n          [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (t) {\n            var _i$t;\n            (_i$t = i[t]) === null || _i$t === void 0 || _i$t[n]();\n          }), (s.hoverSeries === i || ((_s$hoverPoint = s.hoverPoint) === null || _s$hoverPoint === void 0 ? void 0 : _s$hoverPoint.series) === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach(function (t) {\n            t.options.stacking && t.visible && (t.isDirty = !0);\n          }), i.linkedSeries.forEach(function (e) {\n            e.setVisible(t, !1);\n          }), r && (s.isDirtyBox = !0), L(i, n), !1 !== e && s.redraw();\n        }\n      }, {\n        key: \"show\",\n        value: function show() {\n          this.setVisible(!0);\n        }\n      }, {\n        key: \"hide\",\n        value: function hide() {\n          this.setVisible(!1);\n        }\n      }, {\n        key: \"select\",\n        value: function select(t) {\n          this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), L(this, t ? \"select\" : \"unselect\");\n        }\n      }, {\n        key: \"shouldShowTooltip\",\n        value: function shouldShowTooltip(t, e) {\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);\n        }\n      }, {\n        key: \"drawLegendSymbol\",\n        value: function drawLegendSymbol(t, e) {\n          var _r16;\n          (_r16 = r[this.options.legendSymbol || \"rectangle\"]) === null || _r16 === void 0 || _r16.call(this, t, e);\n        }\n      }]);\n    }();\n    return X.defaultOptions = n, X.types = a.seriesTypes, X.registerType = a.registerSeriesType, T(X.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      directTouch: !1,\n      invertible: !0,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: o,\n      requireSorting: !0,\n      sorted: !0\n    }), a.series = X, X;\n  }), i(e, \"Core/Legend/Legend.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Templating.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a) {\n    var h;\n    var l = t.animObject,\n      d = t.setAnimation,\n      c = e.registerEventOptions,\n      p = i.composed,\n      u = i.marginNames,\n      g = o.distribute,\n      f = n.format,\n      m = a.addEvent,\n      x = a.createElement,\n      y = a.css,\n      b = a.defined,\n      v = a.discardElement,\n      S = a.find,\n      C = a.fireEvent,\n      k = a.isNumber,\n      M = a.merge,\n      w = a.pick,\n      A = a.pushUnique,\n      T = a.relativeLength,\n      P = a.stableSort,\n      L = a.syncTimeout;\n    var O = /*#__PURE__*/function () {\n      function O(t, e) {\n        var _this15 = this;\n        _classCallCheck(this, O);\n        this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), c(this, e), m(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        })), m(this.chart, \"render\", function () {\n          _this15.options.enabled && _this15.proximate && (_this15.proximatePositions(), _this15.positionItems());\n        });\n      }\n      return _createClass(O, [{\n        key: \"setOptions\",\n        value: function setOptions(t) {\n          var e = w(t.padding, 8);\n          this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = M(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = w(t.symbolWidth, 16), this.pages = [], this.proximate = \"proximate\" === t.layout && !this.chart.inverted, this.baseline = void 0;\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e) {\n          var i = this.chart;\n          this.setOptions(M(!0, this.options, t)), \"events\" in this.options && c(this, this.options), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, w(e, !0) && i.redraw(), C(this, \"afterUpdate\", {\n            redraw: e\n          });\n        }\n      }, {\n        key: \"colorizeItem\",\n        value: function colorizeItem(t, e) {\n          var _ref10 = t.legendItem || {},\n            i = _ref10.area,\n            s = _ref10.group,\n            r = _ref10.label,\n            o = _ref10.line,\n            n = _ref10.symbol;\n          if (s !== null && s !== void 0 && s[e ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\"), !this.chart.styledMode) {\n            var _this$itemHiddenStyle = this.itemHiddenStyle,\n              _s33 = _this$itemHiddenStyle === void 0 ? {} : _this$itemHiddenStyle,\n              _a14 = _s33.color,\n              _t$options = t.options,\n              _h8 = _t$options.fillColor,\n              _l6 = _t$options.fillOpacity,\n              _d7 = _t$options.lineColor,\n              _c7 = _t$options.marker,\n              _p6 = function _p6(t) {\n                return !e && (t.fill && (t.fill = _a14), t.stroke && (t.stroke = _a14)), t;\n              };\n            r !== null && r !== void 0 && r.css(M(e ? this.itemStyle : _s33)), o !== null && o !== void 0 && o.attr(_p6({\n              stroke: _d7 || t.color\n            })), n && n.attr(_p6(_c7 && n.isMarker ? t.pointAttribs() : {\n              fill: t.color\n            })), i === null || i === void 0 ? void 0 : i.attr(_p6({\n              fill: _h8 || t.color,\n              \"fill-opacity\": _h8 ? 1 : _l6 !== null && _l6 !== void 0 ? _l6 : .75\n            }));\n          }\n          C(this, \"afterColorizeItem\", {\n            item: t,\n            visible: e\n          });\n        }\n      }, {\n        key: \"positionItems\",\n        value: function positionItems() {\n          this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();\n        }\n      }, {\n        key: \"positionItem\",\n        value: function positionItem(t) {\n          var _this16 = this;\n          var _ref11 = t.legendItem || {},\n            e = _ref11.group,\n            _ref11$x = _ref11.x,\n            i = _ref11$x === void 0 ? 0 : _ref11$x,\n            _ref11$y = _ref11.y,\n            s = _ref11$y === void 0 ? 0 : _ref11$y,\n            r = this.options,\n            o = r.symbolPadding,\n            n = !r.rtl,\n            a = t.checkbox;\n          if (e && e.element) {\n            var _r17 = {\n              translateX: n ? i : this.legendWidth - i - 2 * o - 4,\n              translateY: s\n            };\n            e[b(e.translateY) ? \"animate\" : \"attr\"](_r17, void 0, function () {\n              C(_this16, \"afterPositionItem\", {\n                item: t\n              });\n            });\n          }\n          a && (a.x = i, a.y = s);\n        }\n      }, {\n        key: \"destroyItem\",\n        value: function destroyItem(t) {\n          var e = t.checkbox,\n            i = t.legendItem || {};\n          for (var _i35 = 0, _arr2 = [\"group\", \"label\", \"line\", \"symbol\"]; _i35 < _arr2.length; _i35++) {\n            var _t68 = _arr2[_i35];\n            i[_t68] && (i[_t68] = i[_t68].destroy());\n          }\n          e && v(e), t.legendItem = void 0;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var _iterator9 = _createForOfIteratorHelper(this.getAllItems()),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var _t70 = _step9.value;\n              this.destroyItem(_t70);\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n          for (var _i36 = 0, _arr3 = [\"clipRect\", \"up\", \"down\", \"pager\", \"nav\", \"box\", \"title\", \"group\"]; _i36 < _arr3.length; _i36++) {\n            var _t69 = _arr3[_i36];\n            this[_t69] && (this[_t69] = this[_t69].destroy());\n          }\n          this.display = null;\n        }\n      }, {\n        key: \"positionCheckboxes\",\n        value: function positionCheckboxes() {\n          var t;\n          var e = this.group && this.group.alignAttr,\n            i = this.clipHeight || this.legendHeight,\n            s = this.titleHeight;\n          e && (t = e.translateY, this.allItems.forEach(function (r) {\n            var o;\n            var n = r.checkbox;\n            n && (o = t + s + n.y + (this.scrollOffset || 0) + 3, y(n, {\n              left: e.translateX + r.checkboxOffset + n.x - 20 + \"px\",\n              top: o + \"px\",\n              display: this.proximate || o > t - 6 && o < t + i - 6 ? \"\" : \"none\"\n            }));\n          }, this));\n        }\n      }, {\n        key: \"renderTitle\",\n        value: function renderTitle() {\n          var t = this.options,\n            e = this.padding,\n            i = t.title,\n            s,\n            r = 0;\n          i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, \"legend-title\").attr({\n            zIndex: 1\n          }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({\n            width: this.maxLegendWidth + \"px\"\n          }), r = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({\n            translateY: r\n          })), this.titleHeight = r;\n        }\n      }, {\n        key: \"setText\",\n        value: function setText(t) {\n          var e = this.options;\n          t.legendItem.label.attr({\n            text: e.labelFormat ? f(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)\n          });\n        }\n      }, {\n        key: \"renderItem\",\n        value: function renderItem(t) {\n          var e = t.legendItem = t.legendItem || {},\n            i = this.chart,\n            s = i.renderer,\n            r = this.options,\n            o = \"horizontal\" === r.layout,\n            n = this.symbolWidth,\n            a = r.symbolPadding || 0,\n            h = this.itemStyle,\n            l = this.itemHiddenStyle,\n            d = o ? w(r.itemDistance, 20) : 0,\n            c = !r.rtl,\n            p = !t.series,\n            u = !p && t.series.drawLegendSymbol ? t.series : t,\n            g = u.options,\n            f = !!this.createCheckboxForItem && g && g.showCheckbox,\n            m = r.useHTML,\n            x = t.options.className,\n            y = e.label,\n            b = n + a + d + (f ? 20 : 0);\n          !y && (e.group = s.g(\"legend-item\").addClass(\"highcharts-\" + u.type + \"-series highcharts-color-\" + t.colorIndex + (x ? \" \" + x : \"\") + (p ? \" highcharts-series-\" + t.index : \"\")).attr({\n            zIndex: 1\n          }).add(this.scrollGroup), e.label = y = s.text(\"\", c ? n + a : -a, this.baseline || 0, m), i.styledMode || y.css(M(t.visible ? h : l)), y.attr({\n            align: c ? \"left\" : \"right\",\n            zIndex: 2\n          }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr(\"y\", this.baseline), this.symbolHeight = w(r.symbolHeight, this.fontMetrics.f), r.squareSymbol && (this.symbolWidth = w(r.symbolWidth, Math.max(this.symbolHeight, 16)), b = this.symbolWidth + a + d + (f ? 20 : 0), c && y.attr(\"x\", this.symbolWidth + a))), u.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !h.width) && y.css({\n            width: (r.itemWidth || this.widthOption || i.spacingBox.width) - b + \"px\"\n          }), this.setText(t);\n          var v = y.getBBox(),\n            S = this.fontMetrics && this.fontMetrics.h || 0;\n          t.itemWidth = t.checkboxOffset = r.itemWidth || e.labelWidth || v.width + b, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * S ? v.height : S));\n        }\n      }, {\n        key: \"layoutItem\",\n        value: function layoutItem(t) {\n          var e = this.options,\n            i = this.padding,\n            s = \"horizontal\" === e.layout,\n            r = t.itemHeight,\n            o = this.itemMarginBottom,\n            n = this.itemMarginTop,\n            a = s ? w(e.itemDistance, 20) : 0,\n            h = this.maxLegendWidth,\n            l = e.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : t.itemWidth,\n            d = t.legendItem || {};\n          s && this.itemX - i + l > h && (this.itemX = i, this.lastLineHeight && (this.itemY += n + this.lastLineHeight + o), this.lastLineHeight = 0), this.lastItemY = n + this.itemY + o, this.lastLineHeight = Math.max(r, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += l : (this.itemY += n + r + o, this.lastLineHeight = r), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : a) : l) + i, this.offsetWidth);\n        }\n      }, {\n        key: \"getAllItems\",\n        value: function getAllItems() {\n          var t = [];\n          return this.chart.series.forEach(function (e) {\n            var i = e && e.options;\n            e && w(i.showInLegend, !b(i.linkedTo) && void 0, !0) && (t = t.concat((e.legendItem || {}).labels || (\"point\" === i.legendType ? e.data : e)));\n          }), C(this, \"afterGetAllItems\", {\n            allItems: t\n          }), t;\n        }\n      }, {\n        key: \"getAlignment\",\n        value: function getAlignment() {\n          var t = this.options;\n          return this.proximate ? t.align.charAt(0) + \"tv\" : t.floating ? \"\" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);\n        }\n      }, {\n        key: \"adjustMargins\",\n        value: function adjustMargins(t, e) {\n          var i = this.chart,\n            s = this.options,\n            r = this.getAlignment();\n          r && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (o, n) {\n            o.test(r) && !b(t[n]) && (i[u[n]] = Math.max(i[u[n]], i.legend[(n + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][n] * s[n % 2 ? \"x\" : \"y\"] + w(s.margin, 12) + e[n] + (i.titleOffset[n] || 0)));\n          });\n        }\n      }, {\n        key: \"proximatePositions\",\n        value: function proximatePositions() {\n          var t;\n          var e = this.chart,\n            i = [],\n            s = \"left\" === this.options.align;\n          var _iterator10 = _createForOfIteratorHelper((this.allItems.forEach(function (t) {\n              var r,\n                o,\n                n = s,\n                a,\n                h;\n              t.yAxis && (t.xAxis.options.reversed && (n = !n), t.points && (r = S(n ? t.points : t.points.slice(0).reverse(), function (t) {\n                return k(t.plotY);\n              })), o = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, h = t.yAxis.top - e.plotTop, a = t.visible ? (r ? r.plotY : t.yAxis.height) + (h - .3 * o) : h + t.yAxis.height, i.push({\n                target: a,\n                size: o,\n                item: t\n              }));\n            }, this), g(i, e.plotHeight))),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _r18 = _step10.value;\n              t = _r18.item.legendItem || {}, k(_r18.pos) && (t.y = e.plotTop - e.spacing[0] + _r18.pos);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var t = this.chart,\n            e = t.renderer,\n            i = this.options,\n            s = this.padding,\n            r = this.getAllItems(),\n            o,\n            n,\n            a,\n            h = this.group,\n            l,\n            d = this.box;\n          this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = T(i.width, t.spacingBox.width - s), l = t.spacingBox.width - 2 * s - i.x, [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l /= 2), this.maxLegendWidth = this.widthOption || l, h || (this.group = h = e.g(\"legend\").addClass(i.className || \"\").attr({\n            zIndex: 7\n          }).add(), this.contentGroup = e.g().attr({\n            zIndex: 1\n          }).add(h), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), P(r, function (t, e) {\n            return (t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0);\n          }), i.reversed && r.reverse(), this.allItems = r, this.display = o = !!r.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, r.forEach(this.renderItem, this), r.forEach(this.layoutItem, this), n = (this.widthOption || this.offsetWidth) + s, a = this.lastItemY + this.lastLineHeight + this.titleHeight, a = this.handleOverflow(a) + s, d || (this.box = d = e.rect().addClass(\"highcharts-legend-box\").attr({\n            r: i.borderRadius\n          }).add(h)), t.styledMode || d.attr({\n            stroke: i.borderColor,\n            \"stroke-width\": i.borderWidth || 0,\n            fill: i.backgroundColor || \"none\"\n          }).shadow(i.shadow), n > 0 && a > 0 && d[d.placed ? \"animate\" : \"attr\"](d.crisp.call({}, {\n            x: 0,\n            y: 0,\n            width: n,\n            height: a\n          }, d.strokeWidth())), h[o ? \"show\" : \"hide\"](), t.styledMode && \"none\" === h.getStyle(\"display\") && (n = a = 0), this.legendWidth = n, this.legendHeight = a, o && this.align(), this.proximate || this.positionItems(), C(this, \"afterRender\");\n        }\n      }, {\n        key: \"align\",\n        value: function align() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.chart.spacingBox;\n          var e = this.chart,\n            i = this.options,\n            s = t.y;\n          /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = M(t, {\n            y: s\n          })), e.hasRendered || (this.group.placed = !1), this.group.align(M(i, {\n            width: this.legendWidth,\n            height: this.legendHeight,\n            verticalAlign: this.proximate ? \"top\" : i.verticalAlign\n          }), !0, t);\n        }\n      }, {\n        key: \"handleOverflow\",\n        value: function handleOverflow(t) {\n          var e = this,\n            i = this.chart,\n            s = i.renderer,\n            r = this.options,\n            o = r.y,\n            n = \"top\" === r.verticalAlign,\n            a = this.padding,\n            h = r.maxHeight,\n            l = r.navigation,\n            d = w(l.animation, !0),\n            c = l.arrowSize || 12,\n            p = this.pages,\n            u = this.allItems,\n            g = function g(t) {\n              \"number\" == typeof t ? S.attr({\n                height: t\n              }) : S && (e.clipRect = S.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? \"rect(\" + a + \"px,9999px,\" + (a + t) + \"px,0)\" : \"auto\");\n            },\n            f = function f(t) {\n              return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(v), i.styledMode || e[t].attr(\"fill\", \"rgba(0,0,0,0.0001)\"), e[t];\n            },\n            m,\n            x,\n            y,\n            b = i.spacingBox.height + (n ? -o : o) - a,\n            v = this.nav,\n            S = this.clipRect;\n          return \"horizontal\" !== r.layout || \"middle\" === r.verticalAlign || r.floating || (b /= 2), h && (b = Math.min(b, h)), p.length = 0, t && b > 0 && t > b && !1 !== l.enabled ? (this.clipHeight = m = Math.max(b - 20 - this.titleHeight - a, 0), this.currentPage = w(this.currentPage, 1), this.fullHeight = t, u.forEach(function (t, e) {\n            var i = (y = t.legendItem || {}).y || 0,\n              s = Math.round(y.label.getBBox().height),\n              r = p.length;\n            (!r || i - p[r - 1] > m && (x || i) !== p[r - 1]) && (p.push(x || i), r++), y.pageIx = r - 1, x && ((u[e - 1].legendItem || {}).pageIx = r - 1), e === u.length - 1 && i + s - p[r - 1] > m && i > p[r - 1] && (p.push(i), y.pageIx = r), i !== x && (x = i);\n          }), S || (S = e.clipRect = s.clipRect(0, a - 2, 9999, 0), e.contentGroup.clip(S)), g(m), v || (this.nav = v = s.g().attr({\n            zIndex: 1\n          }).add(this.group), this.up = s.symbol(\"triangle\", 0, 0, c, c).add(v), f(\"upTracker\").on(\"click\", function () {\n            e.scroll(-1, d);\n          }), this.pager = s.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !i.styledMode && l.style && this.pager.css(l.style), this.pager.add(v), this.down = s.symbol(\"triangle-down\", 0, 0, c, c).add(v), f(\"downTracker\").on(\"click\", function () {\n            e.scroll(1, d);\n          })), e.scroll(0), t = b) : v && (g(), this.nav = v.destroy(), this.scrollGroup.attr({\n            translateY: 1\n          }), this.clipHeight = 0), t;\n        }\n      }, {\n        key: \"scroll\",\n        value: function scroll(t, e) {\n          var _this17 = this;\n          var i = this.chart,\n            s = this.pages,\n            r = s.length,\n            o = this.clipHeight,\n            n = this.options.navigation,\n            a = this.pager,\n            h = this.padding,\n            c = this.currentPage + t;\n          c > r && (c = r), c > 0 && (void 0 !== e && d(e, i), this.nav.attr({\n            translateX: h,\n            translateY: o + this.padding + 7 + this.titleHeight,\n            visibility: \"inherit\"\n          }), [this.up, this.upTracker].forEach(function (t) {\n            t.attr({\n              \"class\": 1 === c ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n            });\n          }), a.attr({\n            text: c + \"/\" + r\n          }), [this.down, this.downTracker].forEach(function (t) {\n            t.attr({\n              x: 18 + this.pager.getBBox().width,\n              \"class\": c === r ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n            });\n          }, this), i.styledMode || (this.up.attr({\n            fill: 1 === c ? n.inactiveColor : n.activeColor\n          }), this.upTracker.css({\n            cursor: 1 === c ? \"default\" : \"pointer\"\n          }), this.down.attr({\n            fill: c === r ? n.inactiveColor : n.activeColor\n          }), this.downTracker.css({\n            cursor: c === r ? \"default\" : \"pointer\"\n          })), this.scrollOffset = -s[c - 1] + this.initialItemY, this.scrollGroup.animate({\n            translateY: this.scrollOffset\n          }), this.currentPage = c, this.positionCheckboxes(), L(function () {\n            C(_this17, \"afterScroll\", {\n              currentPage: c\n            });\n          }, l(w(e, i.renderer.globalAnimation, !0)).duration));\n        }\n      }, {\n        key: \"setItemEvents\",\n        value: function setItemEvents(t, e, i) {\n          var o = this,\n            n = t.legendItem || {},\n            a = o.chart.renderer.boxWrapper,\n            h = t instanceof r,\n            l = t instanceof s,\n            d = \"highcharts-legend-\" + (h ? \"point\" : \"series\") + \"-active\",\n            c = o.chart.styledMode,\n            p = i ? [e, n.symbol] : [n.group],\n            u = function u(e) {\n              o.allItems.forEach(function (i) {\n                t !== i && [i].concat(i.linkedSeries || []).forEach(function (t) {\n                  t.setState(e, !h);\n                });\n              });\n            };\n          for (var _i37 = 0, _p7 = p; _i37 < _p7.length; _i37++) {\n            var _i38 = _p7[_i37];\n            _i38 && _i38.on(\"mouseover\", function () {\n              t.visible && u(\"inactive\"), t.setState(\"hover\"), t.visible && a.addClass(d), c || e.css(o.options.itemHoverStyle);\n            }).on(\"mouseout\", function () {\n              o.chart.styledMode || e.css(M(t.visible ? o.itemStyle : o.itemHiddenStyle)), u(\"\"), a.removeClass(d), t.setState();\n            }).on(\"click\", function (e) {\n              var i = function i() {\n                t.setVisible && t.setVisible(), u(t.visible ? \"inactive\" : \"\");\n              };\n              a.removeClass(d), C(o, \"itemClick\", {\n                browserEvent: e,\n                legendItem: t\n              }, i), h ? t.firePointEvent(\"legendItemClick\", {\n                browserEvent: e\n              }) : l && C(t, \"legendItemClick\", {\n                browserEvent: e\n              });\n            });\n          }\n        }\n      }, {\n        key: \"createCheckboxForItem\",\n        value: function createCheckboxForItem(t) {\n          t.checkbox = x(\"input\", {\n            type: \"checkbox\",\n            className: \"highcharts-legend-checkbox\",\n            checked: t.selected,\n            defaultChecked: t.selected\n          }, this.options.itemCheckboxStyle, this.chart.container), m(t.checkbox, \"click\", function (e) {\n            var i = e.target;\n            C(t.series || t, \"checkboxClick\", {\n              checked: i.checked,\n              item: t\n            }, function () {\n              t.select();\n            });\n          });\n        }\n      }]);\n    }();\n    return (h = O || (O = {})).compose = function (t) {\n      A(p, \"Core.Legend\") && m(t, \"beforeMargins\", function () {\n        this.legend = new h(this, this.options.legend);\n      });\n    }, O;\n  }), i(e, \"Core/Chart/Chart.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Defaults.js\"], e[\"Core/Templating.js\"], e[\"Core/Foundation.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/SVGRenderer.js\"], e[\"Core/Time.js\"], e[\"Core/Utilities.js\"], e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Axis/Tick.js\"]], function (t, e, i, s, r, o, n, a, h, l, d, c, p, u) {\n    var g = t.animate,\n      f = t.animObject,\n      m = t.setAnimation,\n      x = i.defaultOptions,\n      y = i.defaultTime,\n      b = s.numberFormat,\n      v = r.registerEventOptions,\n      S = o.charts,\n      C = o.doc,\n      k = o.marginNames,\n      M = o.svg,\n      w = o.win,\n      A = h.seriesTypes,\n      T = c.addEvent,\n      P = c.attr,\n      L = c.createElement,\n      O = c.css,\n      D = c.defined,\n      E = c.diffObjects,\n      I = c.discardElement,\n      j = c.erase,\n      B = c.error,\n      R = c.extend,\n      z = c.find,\n      N = c.fireEvent,\n      W = c.getStyle,\n      G = c.isArray,\n      H = c.isNumber,\n      X = c.isObject,\n      F = c.isString,\n      Y = c.merge,\n      U = c.objectEach,\n      V = c.pick,\n      $ = c.pInt,\n      Z = c.relativeLength,\n      _ = c.removeEvent,\n      q = c.splat,\n      K = c.syncTimeout,\n      J = c.uniqueKey;\n    var Q = /*#__PURE__*/function () {\n      function Q(t, e, i) {\n        _classCallCheck(this, Q);\n        this.sharedClips = {};\n        var s = Array.prototype.slice.call(arguments);\n        (F(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]);\n      }\n      return _createClass(Q, [{\n        key: \"setZoomOptions\",\n        value: function setZoomOptions() {\n          var t = this.options.chart,\n            e = t.zooming;\n          this.zooming = _objectSpread(_objectSpread({}, e), {}, {\n            type: V(t.zoomType, e.type),\n            key: V(t.zoomKey, e.key),\n            pinchType: V(t.pinchType, e.pinchType),\n            singleTouch: V(t.zoomBySingleTouch, e.singleTouch, !1),\n            resetButton: Y(e.resetButton, t.resetZoomButton)\n          });\n        }\n      }, {\n        key: \"init\",\n        value: function init(t, e) {\n          N(this, \"init\", {\n            args: arguments\n          }, function () {\n            var i = Y(x, t),\n              s = i.chart;\n            this.userOptions = R({}, t), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.time = t.time && Object.keys(t.time).length ? new d(t.time) : o.time, this.numberFormatter = s.numberFormatter || b, this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = S.length, S.push(this), o.chartCount++, v(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), N(this, \"afterInit\"), this.firstRender();\n          });\n        }\n      }, {\n        key: \"initSeries\",\n        value: function initSeries(t) {\n          var e = this.options.chart,\n            i = t.type || e.type,\n            s = A[i];\n          s || B(17, !0, this, {\n            missingModuleFor: i\n          });\n          var r = new s();\n          return \"function\" == typeof r.init && r.init(this, t), r;\n        }\n      }, {\n        key: \"setSortedData\",\n        value: function setSortedData() {\n          this.getSeriesOrderByLinks().forEach(function (t) {\n            t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);\n          });\n        }\n      }, {\n        key: \"getSeriesOrderByLinks\",\n        value: function getSeriesOrderByLinks() {\n          return this.series.concat().sort(function (t, e) {\n            return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;\n          });\n        }\n      }, {\n        key: \"orderItems\",\n        value: function orderItems(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var i = this[t],\n            s = this.options[t] = q(this.options[t]).slice(),\n            r = this.userOptions[t] = this.userOptions[t] ? q(this.userOptions[t]).slice() : [];\n          if (this.hasRendered && (s.splice(e), r.splice(e)), i) for (var _t71 = e, _o23 = i.length; _t71 < _o23; ++_t71) {\n            var _e40 = i[_t71];\n            _e40 && (_e40.index = _t71, _e40 instanceof a && (_e40.name = _e40.getName()), _e40.options.isInternal || (s[_t71] = _e40.options, r[_t71] = _e40.userOptions));\n          }\n        }\n      }, {\n        key: \"isInsidePlot\",\n        value: function isInsidePlot(t, e) {\n          var _this$scrollablePlotA;\n          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          var s = this.inverted,\n            r = this.plotBox,\n            o = this.plotLeft,\n            n = this.plotTop,\n            a = this.scrollablePlotBox,\n            _ref12 = i.visiblePlotOnly && ((_this$scrollablePlotA = this.scrollablePlotArea) === null || _this$scrollablePlotA === void 0 ? void 0 : _this$scrollablePlotA.scrollingContainer) || {},\n            _ref12$scrollLeft = _ref12.scrollLeft,\n            h = _ref12$scrollLeft === void 0 ? 0 : _ref12$scrollLeft,\n            _ref12$scrollTop = _ref12.scrollTop,\n            l = _ref12$scrollTop === void 0 ? 0 : _ref12$scrollTop,\n            d = i.series,\n            c = i.visiblePlotOnly && a || r,\n            p = i.inverted ? e : t,\n            u = i.inverted ? t : e,\n            g = {\n              x: p,\n              y: u,\n              isInsidePlot: !0,\n              options: i\n            };\n          if (!i.ignoreX) {\n            var _t72 = d && (s && !this.polar ? d.yAxis : d.xAxis) || {\n                pos: o,\n                len: 1 / 0\n              },\n              _e41 = i.paneCoordinates ? _t72.pos + p : o + p;\n            _e41 >= Math.max(h + o, _t72.pos) && _e41 <= Math.min(h + o + c.width, _t72.pos + _t72.len) || (g.isInsidePlot = !1);\n          }\n          if (!i.ignoreY && g.isInsidePlot) {\n            var _t73 = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {\n                pos: n,\n                len: 1 / 0\n              },\n              _e42 = i.paneCoordinates ? _t73.pos + u : n + u;\n            _e42 >= Math.max(l + n, _t73.pos) && _e42 <= Math.min(l + n + c.height, _t73.pos + _t73.len) || (g.isInsidePlot = !1);\n          }\n          return N(this, \"afterIsInsidePlot\", g), g.isInsidePlot;\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw(t) {\n          N(this, \"beforeRedraw\");\n          var e = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n            i = this.series,\n            s = this.pointer,\n            r = this.legend,\n            o = this.userOptions.legend,\n            n = this.renderer,\n            a = n.isHidden(),\n            h = [],\n            l,\n            d,\n            c,\n            p = this.isDirtyBox,\n            u = this.isDirtyLegend,\n            g;\n          for (n.rootFontSize = n.boxWrapper.getStyle(\"font-size\"), this.setResponsive && this.setResponsive(!1), m(!!this.hasRendered && t, this), a && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;) if (((g = i[c]).options.stacking || g.options.centerInCategory) && (d = !0, g.isDirty)) {\n            l = !0;\n            break;\n          }\n          if (l) for (c = i.length; c--;) (g = i[c]).options.stacking && (g.isDirty = !0);\n          i.forEach(function (t) {\n            t.isDirty && (\"point\" === t.options.legendType ? (\"function\" == typeof t.updateTotals && t.updateTotals(), u = !0) : o && (o.labelFormatter || o.labelFormat) && (u = !0)), t.isDirtyData && N(t, \"updatedData\");\n          }), u && r && r.options.enabled && (r.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function (t) {\n            t.updateNames(), t.setScale();\n          }), this.getMargins(), e.forEach(function (t) {\n            t.isDirty && (p = !0);\n          }), e.forEach(function (t) {\n            var e = t.min + \",\" + t.max;\n            t.extKey !== e && (t.extKey = e, h.push(function () {\n              N(t, \"afterSetExtremes\", R(t.eventArgs, t.getExtremes())), delete t.eventArgs;\n            })), (p || d) && t.redraw();\n          }), p && this.drawChartBox(), N(this, \"predraw\"), i.forEach(function (t) {\n            (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;\n          }), s && s.reset(!0), n.draw(), N(this, \"redraw\"), N(this, \"render\"), a && this.temporaryDisplay(!0), h.forEach(function (t) {\n            t.call();\n          });\n        }\n      }, {\n        key: \"get\",\n        value: function get(t) {\n          var e = this.series;\n          function i(e) {\n            return e.id === t || e.options && e.options.id === t;\n          }\n          var s = z(this.axes, i) || z(this.series, i);\n          for (var _t74 = 0; !s && _t74 < e.length; _t74++) s = z(e[_t74].points || [], i);\n          return s;\n        }\n      }, {\n        key: \"getAxes\",\n        value: function getAxes() {\n          var t = this.userOptions;\n          for (var _i39 = 0, _arr4 = (N(this, \"getAxes\"), [\"xAxis\", \"yAxis\"]); _i39 < _arr4.length; _i39++) {\n            var _i40 = _arr4[_i39];\n            var _iterator11 = _createForOfIteratorHelper(t[_i40] = q(t[_i40] || {})),\n              _step11;\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var _s34 = _step11.value;\n                new e(this, _s34, _i40);\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n          }\n          N(this, \"afterGetAxes\");\n        }\n      }, {\n        key: \"getSelectedPoints\",\n        value: function getSelectedPoints() {\n          return this.series.reduce(function (t, e) {\n            return e.getPointsCollection().forEach(function (e) {\n              V(e.selectedStaging, e.selected) && t.push(e);\n            }), t;\n          }, []);\n        }\n      }, {\n        key: \"getSelectedSeries\",\n        value: function getSelectedSeries() {\n          return this.series.filter(function (t) {\n            return t.selected;\n          });\n        }\n      }, {\n        key: \"setTitle\",\n        value: function setTitle(t, e, i) {\n          this.applyDescription(\"title\", t), this.applyDescription(\"subtitle\", e), this.applyDescription(\"caption\", void 0), this.layOutTitles(i);\n        }\n      }, {\n        key: \"applyDescription\",\n        value: function applyDescription(t, e) {\n          var i = this,\n            s = this.options[t] = Y(this.options[t], e),\n            r = this[t];\n          r && e && (this[t] = r = r.destroy()), s && !r && ((r = this.renderer.text(s.text, 0, 0, s.useHTML).attr({\n            align: s.align,\n            \"class\": \"highcharts-\" + t,\n            zIndex: s.zIndex || 4\n          }).add()).update = function (e, s) {\n            i.applyDescription(t, e), i.layOutTitles(s);\n          }, this.styledMode || r.css(R(\"title\" === t ? {\n            fontSize: this.options.isStock ? \"1em\" : \"1.2em\"\n          } : {}, s.style)), this[t] = r);\n        }\n      }, {\n        key: \"layOutTitles\",\n        value: function layOutTitles() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n          var e = [0, 0, 0],\n            i = this.renderer,\n            s = this.spacingBox;\n          [\"title\", \"subtitle\", \"caption\"].forEach(function (t) {\n            var r = this[t],\n              o = this.options[t],\n              n = o.verticalAlign || \"top\",\n              a = \"title\" === t ? \"top\" === n ? -3 : 0 : \"top\" === n ? e[0] + 2 : 0;\n            if (r) {\n              r.css({\n                width: (o.width || s.width + (o.widthAdjust || 0)) + \"px\"\n              });\n              var _t75 = i.fontMetrics(r).b,\n                _h9 = Math.round(r.getBBox(o.useHTML).height);\n              r.align(R({\n                y: \"bottom\" === n ? _t75 : a + _t75,\n                height: _h9\n              }, o), !1, \"spacingBox\"), o.floating || (\"top\" === n ? e[0] = Math.ceil(e[0] + _h9) : \"bottom\" === n && (e[2] = Math.ceil(e[2] + _h9)));\n            }\n          }, this), e[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (e[0] += this.options.title.margin), e[2] && \"bottom\" === this.options.caption.verticalAlign && (e[2] += this.options.caption.margin);\n          var r = !this.titleOffset || this.titleOffset.join(\",\") !== e.join(\",\");\n          this.titleOffset = e, N(this, \"afterLayOutTitles\"), !this.isDirtyBox && r && (this.isDirtyBox = this.isDirtyLegend = r, this.hasRendered && t && this.isDirtyBox && this.redraw());\n        }\n      }, {\n        key: \"getContainerBox\",\n        value: function getContainerBox() {\n          return {\n            width: W(this.renderTo, \"width\", !0) || 0,\n            height: W(this.renderTo, \"height\", !0) || 0\n          };\n        }\n      }, {\n        key: \"getChartSize\",\n        value: function getChartSize() {\n          var t = this.options.chart,\n            e = t.width,\n            i = t.height,\n            s = this.getContainerBox();\n          this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, Z(i, this.chartWidth) || (s.height > 1 ? s.height : 400)), this.containerBox = s;\n        }\n      }, {\n        key: \"temporaryDisplay\",\n        value: function temporaryDisplay(t) {\n          var e = this.renderTo,\n            i;\n          if (t) for (; e && e.style;) e.hcOrigStyle && (O(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (C.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;else for (; e && e.style && (C.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, C.body.appendChild(e)), (\"none\" === W(e, \"display\", !1) || e.hcOricDetached) && (e.hcOrigStyle = {\n            display: e.style.display,\n            height: e.style.height,\n            overflow: e.style.overflow\n          }, i = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, e !== this.renderTo && (i.height = 0), O(e, i), e.offsetWidth || e.style.setProperty(\"display\", \"block\", \"important\")), (e = e.parentNode) !== C.body););\n        }\n      }, {\n        key: \"setClassName\",\n        value: function setClassName(t) {\n          this.container.className = \"highcharts-container \" + (t || \"\");\n        }\n      }, {\n        key: \"getContainer\",\n        value: function getContainer() {\n          var _e$style;\n          var t = this.options,\n            e = t.chart,\n            i = \"data-highcharts-chart\",\n            s = J(),\n            r,\n            o = this.renderTo;\n          o || (this.renderTo = o = e.renderTo), F(o) && (this.renderTo = o = C.getElementById(o)), o || B(13, !0, this);\n          var a = $(P(o, i));\n          H(a) && S[a] && S[a].hasRendered && S[a].destroy(), P(o, i, this.index), o.innerHTML = p.emptyHTML, e.skipClone || o.offsetWidth || this.temporaryDisplay(), this.getChartSize();\n          var h = this.chartHeight,\n            d = this.chartWidth;\n          O(o, {\n            overflow: \"hidden\"\n          }), this.styledMode || (r = R({\n            position: \"relative\",\n            overflow: \"hidden\",\n            width: d + \"px\",\n            height: h + \"px\",\n            textAlign: \"left\",\n            lineHeight: \"normal\",\n            zIndex: 0,\n            \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n            userSelect: \"none\",\n            \"touch-action\": \"manipulation\",\n            outline: \"none\"\n          }, e.style || {}));\n          var c = L(\"div\", {\n            id: s\n          }, r, o);\n          this.container = c, this.getChartSize(), d === this.chartWidth || (d = this.chartWidth, this.styledMode || O(c, {\n            width: V((_e$style = e.style) === null || _e$style === void 0 ? void 0 : _e$style.width, d + \"px\")\n          })), this.containerBox = this.getContainerBox(), this._cursor = c.style.cursor;\n          var u = e.renderer || !M ? n.getRendererType(e.renderer) : l;\n          if (this.renderer = new u(c, d, h, void 0, e.forExport, t.exporting && t.exporting.allowHTML, this.styledMode), m(void 0, this), this.setClassName(e.className), this.styledMode) for (var _e43 in t.defs) this.renderer.definition(t.defs[_e43]);else this.renderer.setStyle(e.style);\n          this.renderer.chartIndex = this.index, N(this, \"afterGetContainer\");\n        }\n      }, {\n        key: \"getMargins\",\n        value: function getMargins(t) {\n          var e = this.spacing,\n            i = this.margin,\n            s = this.titleOffset;\n          this.resetMargins(), s[0] && !D(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !D(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), N(this, \"getMargins\"), t || this.getAxisMargins();\n        }\n      }, {\n        key: \"getAxisMargins\",\n        value: function getAxisMargins() {\n          var t = this,\n            e = t.axisOffset = [0, 0, 0, 0],\n            i = t.colorAxis,\n            s = t.margin,\n            r = function r(t) {\n              t.forEach(function (t) {\n                t.visible && t.getOffset();\n              });\n            };\n          t.hasCartesianSeries ? r(t.axes) : i && i.length && r(i), k.forEach(function (i, r) {\n            D(s[r]) || (t[i] += e[r]);\n          }), t.setChartSize();\n        }\n      }, {\n        key: \"getOptions\",\n        value: function getOptions() {\n          return E(this.userOptions, x);\n        }\n      }, {\n        key: \"reflow\",\n        value: function reflow(t) {\n          var _e$pointer2;\n          var e = this,\n            i = e.containerBox,\n            s = e.getContainerBox();\n          (_e$pointer2 = e.pointer) === null || _e$pointer2 === void 0 || delete _e$pointer2.chartPosition, !e.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (c.clearTimeout(e.reflowTimeout), e.reflowTimeout = K(function () {\n            e.container && e.setSize(void 0, void 0, !1);\n          }, t ? 100 : 0)), e.containerBox = s);\n        }\n      }, {\n        key: \"setReflow\",\n        value: function setReflow() {\n          var t = this,\n            e = function e(_e44) {\n              var _t$options2;\n              ((_t$options2 = t.options) === null || _t$options2 === void 0 ? void 0 : _t$options2.chart.reflow) && t.hasLoaded && t.reflow(_e44);\n            };\n          if (\"function\" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);else {\n            var _t76 = T(w, \"resize\", e);\n            T(this, \"destroy\", _t76);\n          }\n        }\n      }, {\n        key: \"setSize\",\n        value: function setSize(t, e, i) {\n          var s = this,\n            r = s.renderer;\n          s.isResizing += 1, m(i, s);\n          var o = r.globalAnimation;\n          s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize();\n          var n = s.chartWidth,\n            a = s.chartHeight,\n            _s$scrollablePixelsX = s.scrollablePixelsX,\n            h = _s$scrollablePixelsX === void 0 ? 0 : _s$scrollablePixelsX,\n            _s$scrollablePixelsY = s.scrollablePixelsY,\n            l = _s$scrollablePixelsY === void 0 ? 0 : _s$scrollablePixelsY;\n          (s.isDirtyBox || n !== s.oldChartWidth || a !== s.oldChartHeight) && (s.styledMode || (o ? g : O)(s.container, {\n            width: \"\".concat(n + h, \"px\"),\n            height: \"\".concat(a + l, \"px\")\n          }, o), s.setChartSize(!0), r.setSize(n, a, o), s.axes.forEach(function (t) {\n            t.isDirty = !0, t.setScale();\n          }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(o), s.oldChartHeight = void 0, N(s, \"resize\"), setTimeout(function () {\n            s && N(s, \"endResize\");\n          }, f(o).duration)), s.isResizing -= 1;\n        }\n      }, {\n        key: \"setChartSize\",\n        value: function setChartSize(t) {\n          var e, i, s, r;\n          var o = this.chartHeight,\n            n = this.chartWidth,\n            a = this.inverted,\n            h = this.spacing,\n            l = this.renderer,\n            d = this.clipOffset,\n            c = Math[a ? \"floor\" : \"round\"];\n          this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(n - e - this.marginRight)), this.plotHeight = r = Math.max(0, Math.round(o - i - this.marginBottom)), this.plotSizeX = a ? r : s, this.plotSizeY = a ? s : r, this.spacingBox = l.spacingBox = {\n            x: h[3],\n            y: h[0],\n            width: n - h[3] - h[1],\n            height: o - h[0] - h[2]\n          }, this.plotBox = l.plotBox = {\n            x: e,\n            y: i,\n            width: s,\n            height: r\n          }, d && (this.clipBox = {\n            x: c(d[3]),\n            y: c(d[0]),\n            width: c(this.plotSizeX - d[1] - d[3]),\n            height: c(this.plotSizeY - d[0] - d[2])\n          }), t || (this.axes.forEach(function (t) {\n            t.setAxisSize(), t.setAxisTranslation();\n          }), l.alignElements()), N(this, \"afterSetChartSize\", {\n            skipAxes: t\n          });\n        }\n      }, {\n        key: \"resetMargins\",\n        value: function resetMargins() {\n          N(this, \"resetMargins\");\n          var t = this,\n            e = t.options.chart,\n            i = e.plotBorderWidth || 0,\n            s = i / 2;\n          [\"margin\", \"spacing\"].forEach(function (i) {\n            var s = e[i],\n              r = X(s) ? s : [s, s, s, s];\n            [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (s, o) {\n              t[i][o] = V(e[i + s], r[o]);\n            });\n          }), k.forEach(function (e, i) {\n            t[e] = V(t.margin[i], t.spacing[i]);\n          }), t.axisOffset = [0, 0, 0, 0], t.clipOffset = [s, s, s, s], t.plotBorderWidth = i;\n        }\n      }, {\n        key: \"drawChartBox\",\n        value: function drawChartBox() {\n          var t = this.options.chart,\n            e = this.renderer,\n            i = this.chartWidth,\n            s = this.chartHeight,\n            r = this.styledMode,\n            o = this.plotBGImage,\n            n = t.backgroundColor,\n            a = t.plotBackgroundColor,\n            h = t.plotBackgroundImage,\n            l = this.plotLeft,\n            d = this.plotTop,\n            c = this.plotWidth,\n            p = this.plotHeight,\n            u = this.plotBox,\n            g = this.clipRect,\n            f = this.clipBox,\n            m = this.chartBackground,\n            x = this.plotBackground,\n            y = this.plotBorder,\n            b,\n            v,\n            S,\n            C = \"animate\";\n          m || (this.chartBackground = m = e.rect().addClass(\"highcharts-background\").add(), C = \"attr\"), r ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + (t.shadow ? 8 : 0), S = {\n            fill: n || \"none\"\n          }, (b || m[\"stroke-width\"]) && (S.stroke = t.borderColor, S[\"stroke-width\"] = b), m.attr(S).shadow(t.shadow)), m[C]({\n            x: v / 2,\n            y: v / 2,\n            width: i - v - b % 2,\n            height: s - v - b % 2,\n            r: t.borderRadius\n          }), C = \"animate\", x || (C = \"attr\", this.plotBackground = x = e.rect().addClass(\"highcharts-plot-background\").add()), x[C](u), !r && (x.attr({\n            fill: a || \"none\"\n          }).shadow(t.plotShadow), h && (o ? (h !== o.attr(\"href\") && o.attr(\"href\", h), o.animate(u)) : this.plotBGImage = e.image(h, l, d, c, p).add())), g ? g.animate({\n            width: f.width,\n            height: f.height\n          }) : this.clipRect = e.clipRect(f), C = \"animate\", y || (C = \"attr\", this.plotBorder = y = e.rect().addClass(\"highcharts-plot-border\").attr({\n            zIndex: 1\n          }).add()), r || y.attr({\n            stroke: t.plotBorderColor,\n            \"stroke-width\": t.plotBorderWidth || 0,\n            fill: \"none\"\n          }), y[C](y.crisp({\n            x: l,\n            y: d,\n            width: c,\n            height: p\n          }, -y.strokeWidth())), this.isDirtyBox = !1, N(this, \"afterDrawChartBox\");\n        }\n      }, {\n        key: \"propFromSeries\",\n        value: function propFromSeries() {\n          var t, e, i;\n          var s = this,\n            r = s.options.chart,\n            o = s.options.series;\n          [\"inverted\", \"angular\", \"polar\"].forEach(function (n) {\n            for (e = A[r.type], i = r[n] || e && e.prototype[n], t = o && o.length; !i && t--;) (e = A[o[t].type]) && e.prototype[n] && (i = !0);\n            s[n] = i;\n          });\n        }\n      }, {\n        key: \"linkSeries\",\n        value: function linkSeries(t) {\n          var e = this,\n            i = e.series;\n          i.forEach(function (t) {\n            t.linkedSeries.length = 0;\n          }), i.forEach(function (t) {\n            var i = t.options.linkedTo;\n            if (F(i)) {\n              var _s35;\n              (_s35 = \":previous\" === i ? e.series[t.index - 1] : e.get(i)) && _s35.linkedParent !== t && (_s35.linkedSeries.push(t), t.linkedParent = _s35, _s35.enabledDataSorting && t.setDataSortingOptions(), t.visible = V(t.options.visible, _s35.options.visible, t.visible));\n            }\n          }), N(this, \"afterLinkSeries\", {\n            isUpdating: t\n          });\n        }\n      }, {\n        key: \"renderSeries\",\n        value: function renderSeries() {\n          this.series.forEach(function (t) {\n            t.translate(), t.render();\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this$getStacks;\n          var t = this.axes,\n            e = this.colorAxis,\n            i = this.renderer,\n            s = this.options.chart.axisLayoutRuns || 2,\n            r = function r(t) {\n              t.forEach(function (t) {\n                t.visible && t.render();\n              });\n            },\n            o = 0,\n            n = !0,\n            a,\n            h = 0;\n          var _iterator12 = _createForOfIteratorHelper((this.setTitle(), N(this, \"beforeMargins\"), (_this$getStacks = this.getStacks) !== null && _this$getStacks !== void 0 && _this$getStacks.call(this), this.getMargins(!0), this.setChartSize(), t)),\n            _step12;\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var _e47 = _step12.value;\n              var _t77 = _e47.options,\n                _i42 = _t77.labels;\n              if (this.hasCartesianSeries && _e47.horiz && _e47.visible && _i42.enabled && _e47.series.length && \"colorAxis\" !== _e47.coll && !this.polar) {\n                o = _t77.tickLength, _e47.createGroups();\n                var _s36 = new u(_e47, 0, \"\", !0),\n                  _r19 = _s36.createLabel(\"x\", _i42);\n                if (_s36.destroy(), _r19 && V(_i42.reserveSpace, !H(_t77.crossing)) && (o = _r19.getBBox().height + _i42.distance + Math.max(_t77.offset || 0, 0)), o) {\n                  _r19 === null || _r19 === void 0 || _r19.destroy();\n                  break;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n          for (this.plotHeight = Math.max(this.plotHeight - o, 0); (n || a || s > 1) && h < s;) {\n            var _e45 = this.plotWidth,\n              _i41 = this.plotHeight;\n            var _iterator13 = _createForOfIteratorHelper(t),\n              _step13;\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var _e46 = _step13.value;\n                0 === h ? _e46.setScale() : (_e46.horiz && n || !_e46.horiz && a) && _e46.setTickInterval(!0);\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n            0 === h ? this.getAxisMargins() : this.getMargins(), n = _e45 / this.plotWidth > (h ? 1 : 1.1), a = _i41 / this.plotHeight > (h ? 1 : 1.05), h++;\n          }\n          this.drawChartBox(), this.hasCartesianSeries ? r(t) : e && e.length && r(e), this.seriesGroup || (this.seriesGroup = i.g(\"series-group\").attr({\n            zIndex: 3\n          }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;\n        }\n      }, {\n        key: \"addCredits\",\n        value: function addCredits(t) {\n          var e = this,\n            i = Y(!0, this.options.credits, t);\n          i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n            i.href && (w.location.href = i.href);\n          }).attr({\n            align: i.position.align,\n            zIndex: 8\n          }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function (t) {\n            e.credits = e.credits.destroy(), e.addCredits(t);\n          });\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var t;\n          var e = this,\n            i = e.axes,\n            s = e.series,\n            r = e.container,\n            n = r && r.parentNode;\n          for (N(e, \"destroy\"), e.renderer.forExport ? j(S, e) : S[e.index] = void 0, o.chartCount--, e.renderTo.removeAttribute(\"data-highcharts-chart\"), _(e), t = i.length; t--;) i[t] = i[t].destroy();\n          for (this.scroller && this.scroller.destroy && this.scroller.destroy(), t = s.length; t--;) s[t] = s[t].destroy();\n          [\"title\", \"subtitle\", \"chartBackground\", \"plotBackground\", \"plotBGImage\", \"plotBorder\", \"seriesGroup\", \"clipRect\", \"credits\", \"pointer\", \"rangeSelector\", \"legend\", \"resetZoomButton\", \"tooltip\", \"renderer\"].forEach(function (t) {\n            var i = e[t];\n            i && i.destroy && (e[t] = i.destroy());\n          }), r && (r.innerHTML = p.emptyHTML, _(r), n && I(r)), U(e, function (t, i) {\n            delete e[i];\n          });\n        }\n      }, {\n        key: \"firstRender\",\n        value: function firstRender() {\n          var _t$pointer;\n          var t = this,\n            e = t.options;\n          t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.getAxes();\n          var i = G(e.series) ? e.series : [];\n          e.series = [], i.forEach(function (e) {\n            t.initSeries(e);\n          }), t.linkSeries(), t.setSortedData(), N(t, \"beforeRender\"), t.render(), (_t$pointer = t.pointer) !== null && _t$pointer !== void 0 && _t$pointer.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);\n        }\n      }, {\n        key: \"onload\",\n        value: function onload() {\n          this.callbacks.concat([this.callback]).forEach(function (t) {\n            t && void 0 !== this.index && t.apply(this, [this]);\n          }, this), N(this, \"load\"), N(this, \"render\"), D(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;\n        }\n      }, {\n        key: \"warnIfA11yModuleNotLoaded\",\n        value: function warnIfA11yModuleNotLoaded() {\n          var t = this.options,\n            e = this.title;\n          !t || this.accessibility || (this.renderer.boxWrapper.attr({\n            role: \"img\",\n            \"aria-label\": (e && e.element.textContent || \"\").replace(/</g, \"&lt;\")\n          }), t.accessibility && !1 === t.accessibility.enabled || B('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n        }\n      }, {\n        key: \"addSeries\",\n        value: function addSeries(t, e, i) {\n          var s;\n          var r = this;\n          return t && (e = V(e, !0), N(r, \"addSeries\", {\n            options: t\n          }, function () {\n            s = r.initSeries(t), r.isDirtyLegend = !0, r.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), N(r, \"afterAddSeries\", {\n              series: s\n            }), e && r.redraw(i);\n          })), s;\n        }\n      }, {\n        key: \"addAxis\",\n        value: function addAxis(t, e, i, s) {\n          return this.createAxis(e ? \"xAxis\" : \"yAxis\", {\n            axis: t,\n            redraw: i,\n            animation: s\n          });\n        }\n      }, {\n        key: \"addColorAxis\",\n        value: function addColorAxis(t, e, i) {\n          return this.createAxis(\"colorAxis\", {\n            axis: t,\n            redraw: e,\n            animation: i\n          });\n        }\n      }, {\n        key: \"createAxis\",\n        value: function createAxis(t, i) {\n          var s = new e(this, i.axis, t);\n          return V(i.redraw, !0) && this.redraw(i.animation), s;\n        }\n      }, {\n        key: \"showLoading\",\n        value: function showLoading(t) {\n          var e = this,\n            i = e.options,\n            s = i.loading,\n            r = function r() {\n              o && O(o, {\n                left: e.plotLeft + \"px\",\n                top: e.plotTop + \"px\",\n                width: e.plotWidth + \"px\",\n                height: e.plotHeight + \"px\"\n              });\n            },\n            o = e.loadingDiv,\n            n = e.loadingSpan;\n          o || (e.loadingDiv = o = L(\"div\", {\n            className: \"highcharts-loading highcharts-loading-hidden\"\n          }, null, e.container)), n || (e.loadingSpan = n = L(\"span\", {\n            className: \"highcharts-loading-inner\"\n          }, null, o), T(e, \"redraw\", r)), o.className = \"highcharts-loading\", p.setElementHTML(n, V(t, i.lang.loading, \"\")), e.styledMode || (O(o, R(s.style, {\n            zIndex: 10\n          })), O(n, s.labelStyle), e.loadingShown || (O(o, {\n            opacity: 0,\n            display: \"\"\n          }), g(o, {\n            opacity: s.style.opacity || .5\n          }, {\n            duration: s.showDuration || 0\n          }))), e.loadingShown = !0, r();\n        }\n      }, {\n        key: \"hideLoading\",\n        value: function hideLoading() {\n          var t = this.options,\n            e = this.loadingDiv;\n          e && (e.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || g(e, {\n            opacity: 0\n          }, {\n            duration: t.loading.hideDuration || 100,\n            complete: function complete() {\n              O(e, {\n                display: \"none\"\n              });\n            }\n          })), this.loadingShown = !1;\n        }\n      }, {\n        key: \"update\",\n        value: function update(t, e, i, s) {\n          var r, o, n;\n          var a = this,\n            h = {\n              credits: \"addCredits\",\n              title: \"setTitle\",\n              subtitle: \"setSubtitle\",\n              caption: \"setCaption\"\n            },\n            l = t.isResponsiveOptions,\n            c = [];\n          N(a, \"update\", {\n            options: t\n          }), l || a.setResponsive(!1, !0), t = E(t, a.options), a.userOptions = Y(a.userOptions, t);\n          var p = t.chart;\n          p && (Y(!0, a.options.chart, p), this.setZoomOptions(), \"className\" in p && a.setClassName(p.className), (\"inverted\" in p || \"polar\" in p || \"type\" in p) && (a.propFromSeries(), r = !0), \"alignTicks\" in p && (r = !0), \"events\" in p && v(this, p), U(p, function (t, e) {\n            -1 !== a.propsRequireUpdateSeries.indexOf(\"chart.\" + e) && (o = !0), -1 !== a.propsRequireDirtyBox.indexOf(e) && (a.isDirtyBox = !0), -1 === a.propsRequireReflow.indexOf(e) || (a.isDirtyBox = !0, l || (n = !0));\n          }), !a.styledMode && p.style && a.renderer.setStyle(a.options.chart.style || {})), !a.styledMode && t.colors && (this.options.colors = t.colors), t.time && (this.time === y && (this.time = new d(t.time)), Y(!0, a.options.time, t.time)), U(t, function (e, i) {\n            a[i] && \"function\" == typeof a[i].update ? a[i].update(e, !1) : \"function\" == typeof a[h[i]] ? a[h[i]](e) : \"colors\" !== i && -1 === a.collectionsWithUpdate.indexOf(i) && Y(!0, a.options[i], t[i]), \"chart\" !== i && -1 !== a.propsRequireUpdateSeries.indexOf(i) && (o = !0);\n          }), this.collectionsWithUpdate.forEach(function (e) {\n            t[e] && (q(t[e]).forEach(function (t, s) {\n              var r;\n              var o = D(t.id);\n              o && (r = a.get(t.id)), !r && a[e] && (r = a[e][V(t.index, s)]) && (o && D(r.options.id) || r.options.isInternal) && (r = void 0), r && r.coll === e && (r.update(t, !1), i && (r.touched = !0)), !r && i && a.collectionsWithInit[e] && (a.collectionsWithInit[e][0].apply(a, [t].concat(a.collectionsWithInit[e][1] || []).concat([!1])).touched = !0);\n            }), i && a[e].forEach(function (t) {\n              t.touched || t.options.isInternal ? delete t.touched : c.push(t);\n            }));\n          }), c.forEach(function (t) {\n            t.chart && t.remove && t.remove(!1);\n          }), r && a.axes.forEach(function (t) {\n            t.update({}, !1);\n          }), o && a.getSeriesOrderByLinks().forEach(function (t) {\n            t.chart && t.update({}, !1);\n          }, this);\n          var u = p && p.width,\n            g = p && (F(p.height) ? Z(p.height, u || a.chartWidth) : p.height);\n          n || H(u) && u !== a.chartWidth || H(g) && g !== a.chartHeight ? a.setSize(u, g, s) : V(e, !0) && a.redraw(s), N(a, \"afterUpdate\", {\n            options: t,\n            redraw: e,\n            animation: s\n          });\n        }\n      }, {\n        key: \"setSubtitle\",\n        value: function setSubtitle(t, e) {\n          this.applyDescription(\"subtitle\", t), this.layOutTitles(e);\n        }\n      }, {\n        key: \"setCaption\",\n        value: function setCaption(t, e) {\n          this.applyDescription(\"caption\", t), this.layOutTitles(e);\n        }\n      }, {\n        key: \"showResetZoom\",\n        value: function showResetZoom() {\n          var t = this,\n            e = x.lang,\n            i = t.zooming.resetButton,\n            s = i.theme,\n            r = \"chart\" === i.relativeTo || \"spacingBox\" === i.relativeTo ? null : \"plotBox\";\n          function o() {\n            t.zoomOut();\n          }\n          N(this, \"beforeShowResetZoom\", null, function () {\n            t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, o, s).attr({\n              align: i.position.align,\n              title: e.resetZoomTitle\n            }).addClass(\"highcharts-reset-zoom\").add().align(i.position, !1, r);\n          }), N(this, \"afterShowResetZoom\");\n        }\n      }, {\n        key: \"zoomOut\",\n        value: function zoomOut() {\n          var _this18 = this;\n          N(this, \"selection\", {\n            resetSelection: !0\n          }, function () {\n            return _this18.transform({\n              reset: !0,\n              trigger: \"zoom\"\n            });\n          });\n        }\n      }, {\n        key: \"pan\",\n        value: function pan(t, e) {\n          var i = this,\n            s = \"object\" == _typeof(e) ? e : {\n              enabled: e,\n              type: \"x\"\n            },\n            r = s.type,\n            o = r && i[{\n              x: \"xAxis\",\n              xy: \"axes\",\n              y: \"yAxis\"\n            }[r]].filter(function (t) {\n              return t.options.panningEnabled && !t.options.isInternal;\n            }),\n            n = i.options.chart;\n          n !== null && n !== void 0 && n.panning && (n.panning = s), N(this, \"pan\", {\n            originalEvent: t\n          }, function () {\n            i.transform({\n              axes: o,\n              event: t,\n              to: {\n                x: t.chartX - (i.mouseDownX || 0),\n                y: t.chartY - (i.mouseDownY || 0)\n              },\n              trigger: \"pan\"\n            }), O(i.container, {\n              cursor: \"move\"\n            });\n          });\n        }\n      }, {\n        key: \"transform\",\n        value: function transform(t) {\n          var _this19 = this,\n            _this$options$chart$a,\n            _this$hoverPoints;\n          var _t$axes = t.axes,\n            e = _t$axes === void 0 ? this.axes : _t$axes,\n            i = t.event,\n            _t$from = t.from,\n            s = _t$from === void 0 ? {} : _t$from,\n            r = t.reset,\n            o = t.selection,\n            _t$to = t.to,\n            n = _t$to === void 0 ? {} : _t$to,\n            a = t.trigger,\n            h = this.inverted,\n            l = !1,\n            d,\n            c;\n          var _iterator14 = _createForOfIteratorHelper(((_this$hoverPoints = this.hoverPoints) !== null && _this$hoverPoints !== void 0 && _this$hoverPoints.forEach(function (t) {\n              return t.setState();\n            }), e)),\n            _step14;\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var _n$_x, _ref13, _g3$min, _g3$max;\n              var _t78 = _step14.value;\n              var _e48 = _t78.horiz,\n                _p8 = _t78.len,\n                _t78$minPointOffset = _t78.minPointOffset,\n                _u3 = _t78$minPointOffset === void 0 ? 0 : _t78$minPointOffset,\n                _g3 = _t78.options,\n                _f2 = _t78.reversed,\n                _m4 = _e48 ? \"width\" : \"height\",\n                _x4 = _e48 ? \"x\" : \"y\",\n                _y2 = V(n[_m4], _t78.len),\n                _b2 = V(s[_m4], _t78.len),\n                _v4 = 10 > Math.abs(_y2) ? 1 : _y2 / _b2,\n                _S4 = (s[_x4] || 0) + _b2 / 2 - _t78.pos,\n                _C = _S4 - (((_n$_x = n[_x4]) !== null && _n$_x !== void 0 ? _n$_x : _t78.pos) + _y2 / 2 - _t78.pos) / _v4,\n                _k3 = _f2 && !h || !_f2 && h ? -1 : 1;\n              if (!r && (_S4 < 0 || _S4 > _t78.len)) continue;\n              var _M2 = _t78.toValue(_C, !0) + (o ? 0 : _u3 * _k3),\n                _w2 = _t78.toValue(_C + _p8 / _v4, !0) - (o ? 0 : _u3 * _k3 || 0),\n                _A = _t78.allExtremes;\n              if (_M2 > _w2 && (_ref13 = [_w2, _M2], _M2 = _ref13[0], _w2 = _ref13[1], _ref13), 1 === _v4 && !r && \"yAxis\" === _t78.coll && !_A) {\n                var _iterator15 = _createForOfIteratorHelper(_t78.series),\n                  _step15;\n                try {\n                  for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                    var _A2;\n                    var _e49 = _step15.value;\n                    var _t79 = _e49.getExtremes(_e49.getProcessedData(!0).yData, !0);\n                    (_A2 = _A) !== null && _A2 !== void 0 ? _A2 : _A = {\n                      dataMin: Number.MAX_VALUE,\n                      dataMax: -Number.MAX_VALUE\n                    }, H(_t79.dataMin) && H(_t79.dataMax) && (_A.dataMin = Math.min(_t79.dataMin, _A.dataMin), _A.dataMax = Math.max(_t79.dataMax, _A.dataMax));\n                  }\n                } catch (err) {\n                  _iterator15.e(err);\n                } finally {\n                  _iterator15.f();\n                }\n                _t78.allExtremes = _A;\n              }\n              var _R2 = R(_t78.getExtremes(), _A || {}),\n                _T3 = _R2.dataMin,\n                _P = _R2.dataMax,\n                _L = _R2.min,\n                _O2 = _R2.max,\n                _E = _T3 !== null && _T3 !== void 0 ? _T3 : _g3.min,\n                _I2 = _P !== null && _P !== void 0 ? _P : _g3.max,\n                _j2 = _w2 - _M2,\n                _B = _t78.categories ? 0 : Math.min(_j2, _I2 - _E),\n                _z = _E - _B * (D(_g3.min) ? 0 : _g3.minPadding),\n                _N = _I2 + _B * (D(_g3.max) ? 0 : _g3.maxPadding),\n                _W = _t78.allowZoomOutside || 1 === _v4 || \"zoom\" !== a && _v4 > 1,\n                _G = Math.min((_g3$min = _g3.min) !== null && _g3$min !== void 0 ? _g3$min : _z, _z, _W ? _L : _z),\n                _X = Math.max((_g3$max = _g3.max) !== null && _g3$max !== void 0 ? _g3$max : _N, _N, _W ? _O2 : _N);\n              (!_t78.isOrdinal || 1 !== _v4 || r) && (_M2 < _G && (_M2 = _G, _v4 >= 1 && (_w2 = _M2 + _j2)), _w2 > _X && (_w2 = _X, _v4 >= 1 && (_M2 = _w2 - _j2)), (r || _t78.series.length && (_M2 !== _L || _w2 !== _O2) && _M2 >= _G && _w2 <= _X) && (o ? o[_t78.coll].push({\n                axis: _t78,\n                min: _M2,\n                max: _w2\n              }) : (_t78.isPanning = \"zoom\" !== a, _t78.isPanning && (c = !0), _t78.setExtremes(r ? void 0 : _M2, r ? void 0 : _w2, !1, !1, {\n                move: _C,\n                trigger: a,\n                scale: _v4\n              }), !r && (_M2 > _G || _w2 < _X) && \"mousewheel\" !== a && (d = !0)), l = !0), i && (this[_e48 ? \"mouseDownX\" : \"mouseDownY\"] = i[_e48 ? \"chartX\" : \"chartY\"]));\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n          return l && (o ? N(this, \"selection\", o, function () {\n            delete t.selection, t.trigger = \"zoom\", _this19.transform(t);\n          }) : (!d || c || this.resetZoomButton ? !d && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw(\"zoom\" === a && ((_this$options$chart$a = this.options.chart.animation) !== null && _this$options$chart$a !== void 0 ? _this$options$chart$a : this.pointCount < 100)))), l;\n        }\n      }], [{\n        key: \"chart\",\n        value: function chart(t, e, i) {\n          return new Q(t, e, i);\n        }\n      }]);\n    }();\n    return R(Q.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [Q.prototype.addAxis, [!0]],\n        yAxis: [Q.prototype.addAxis, [!1]],\n        series: [Q.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: [\"backgroundColor\", \"borderColor\", \"borderWidth\", \"borderRadius\", \"plotBackgroundColor\", \"plotBackgroundImage\", \"plotBorderColor\", \"plotBorderWidth\", \"plotShadow\", \"shadow\"],\n      propsRequireReflow: [\"margin\", \"marginTop\", \"marginRight\", \"marginBottom\", \"marginLeft\", \"spacing\", \"spacingTop\", \"spacingRight\", \"spacingBottom\", \"spacingLeft\"],\n      propsRequireUpdateSeries: [\"chart.inverted\", \"chart.polar\", \"chart.ignoreHiddenSeries\", \"chart.type\", \"colors\", \"plotOptions\", \"time\", \"tooltip\"]\n    }), Q;\n  }), i(e, \"Extensions/ScrollablePlotArea.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r = t.stop,\n      o = e.composed,\n      n = s.addEvent,\n      a = s.createElement,\n      h = s.css,\n      l = s.defined,\n      d = s.merge,\n      c = s.pushUnique;\n    function p() {\n      var _t80;\n      var t = this.scrollablePlotArea;\n      (this.scrollablePixelsX || this.scrollablePixelsY) && !t && (this.scrollablePlotArea = t = new g(this)), (_t80 = t) === null || _t80 === void 0 ? void 0 : _t80.applyFixed();\n    }\n    function u() {\n      this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = !0);\n    }\n    var g = /*#__PURE__*/function () {\n      function g(t) {\n        var _s$style, _o$opacity;\n        _classCallCheck(this, g);\n        var e;\n        var s = t.options.chart,\n          r = i.getRendererType(),\n          o = s.scrollablePlotArea || {},\n          l = this.moveFixedElements.bind(this),\n          d = {\n            WebkitOverflowScrolling: \"touch\",\n            overflowX: \"hidden\",\n            overflowY: \"hidden\"\n          };\n        t.scrollablePixelsX && (d.overflowX = \"auto\"), t.scrollablePixelsY && (d.overflowY = \"auto\"), this.chart = t;\n        var c = this.parentDiv = a(\"div\", {\n            className: \"highcharts-scrolling-parent\"\n          }, {\n            position: \"relative\"\n          }, t.renderTo),\n          p = this.scrollingContainer = a(\"div\", {\n            className: \"highcharts-scrolling\"\n          }, d, c),\n          u = this.innerContainer = a(\"div\", {\n            className: \"highcharts-inner-container\"\n          }, void 0, p),\n          _g4 = this.fixedDiv = a(\"div\", {\n            className: \"highcharts-fixed\"\n          }, {\n            position: \"absolute\",\n            overflow: \"hidden\",\n            pointerEvents: \"none\",\n            zIndex: (((_s$style = s.style) === null || _s$style === void 0 ? void 0 : _s$style.zIndex) || 0) + 2,\n            top: 0\n          }, void 0, !0),\n          f = this.fixedRenderer = new r(_g4, t.chartWidth, t.chartHeight, s.style);\n        this.mask = f.path().attr({\n          fill: s.backgroundColor || \"#fff\",\n          \"fill-opacity\": (_o$opacity = o.opacity) !== null && _o$opacity !== void 0 ? _o$opacity : .85,\n          zIndex: -1\n        }).addClass(\"highcharts-scrollable-mask\").add(), p.parentNode.insertBefore(_g4, p), h(t.renderTo, {\n          overflow: \"visible\"\n        }), n(t, \"afterShowResetZoom\", l), n(t, \"afterApplyDrilldown\", l), n(t, \"afterLayOutTitles\", l), n(p, \"scroll\", function () {\n          var i = t.pointer,\n            s = t.hoverPoint;\n          i && (delete i.chartPosition, s && (e = s), i.runPointActions(void 0, e, !0));\n        }), u.appendChild(t.container);\n      }\n      return _createClass(g, [{\n        key: \"applyFixed\",\n        value: function applyFixed() {\n          var _t$chartBackground;\n          var t = this.chart,\n            e = this.fixedRenderer,\n            i = this.isDirty,\n            s = this.scrollingContainer,\n            o = t.axisOffset,\n            n = t.chartWidth,\n            a = t.chartHeight,\n            d = t.container,\n            c = t.plotHeight,\n            p = t.plotLeft,\n            u = t.plotTop,\n            _g5 = t.plotWidth,\n            _t$scrollablePixelsX = t.scrollablePixelsX,\n            f = _t$scrollablePixelsX === void 0 ? 0 : _t$scrollablePixelsX,\n            _t$scrollablePixelsY = t.scrollablePixelsY,\n            m = _t$scrollablePixelsY === void 0 ? 0 : _t$scrollablePixelsY,\n            _ref14 = t.options.chart.scrollablePlotArea || {},\n            _ref14$scrollPosition = _ref14.scrollPositionX,\n            x = _ref14$scrollPosition === void 0 ? 0 : _ref14$scrollPosition,\n            _ref14$scrollPosition2 = _ref14.scrollPositionY,\n            y = _ref14$scrollPosition2 === void 0 ? 0 : _ref14$scrollPosition2,\n            b = n + f,\n            v = a + m;\n          e.setSize(n, a), (i !== null && i !== void 0 ? i : !0) && (this.isDirty = !1, this.moveFixedElements()), r(t.container), h(d, {\n            width: \"\".concat(b, \"px\"),\n            height: \"\".concat(v, \"px\")\n          }), t.renderer.boxWrapper.attr({\n            width: b,\n            height: v,\n            viewBox: [0, 0, b, v].join(\" \")\n          }), (_t$chartBackground = t.chartBackground) !== null && _t$chartBackground !== void 0 && _t$chartBackground.attr({\n            width: b,\n            height: v\n          }), h(s, {\n            width: \"\".concat(n, \"px\"),\n            height: \"\".concat(a, \"px\")\n          }), l(i) || (s.scrollLeft = f * x, s.scrollTop = m * y);\n          var S = u - o[0] - 1,\n            C = p - o[3] - 1,\n            k = u + c + o[2] + 1,\n            M = p + _g5 + o[1] + 1,\n            w = p + _g5 - f,\n            A = u + c - m,\n            T = [[\"M\", 0, 0]];\n          f ? T = [[\"M\", 0, S], [\"L\", p - 1, S], [\"L\", p - 1, k], [\"L\", 0, k], [\"Z\"], [\"M\", w, S], [\"L\", n, S], [\"L\", n, k], [\"L\", w, k], [\"Z\"]] : m && (T = [[\"M\", C, 0], [\"L\", C, u - 1], [\"L\", M, u - 1], [\"L\", M, 0], [\"Z\"], [\"M\", C, A], [\"L\", C, a], [\"L\", M, a], [\"L\", M, A], [\"Z\"]]), \"adjustHeight\" !== t.redrawTrigger && this.mask.attr({\n            d: T\n          });\n        }\n      }, {\n        key: \"moveFixedElements\",\n        value: function moveFixedElements() {\n          var t;\n          var _this$chart = this.chart,\n            e = _this$chart.container,\n            i = _this$chart.inverted,\n            s = _this$chart.scrollablePixelsX,\n            r = _this$chart.scrollablePixelsY,\n            o = this.fixedRenderer,\n            n = g.fixedSelectors;\n          var _iterator16 = _createForOfIteratorHelper((s && !i ? t = \".highcharts-yaxis\" : s && i ? t = \".highcharts-xaxis\" : r && !i ? t = \".highcharts-xaxis\" : r && i && (t = \".highcharts-yaxis\"), t && n.push(\"\".concat(t, \":not(.highcharts-radial-axis)\"), \"\".concat(t, \"-labels:not(.highcharts-radial-axis-labels)\")), n)),\n            _step16;\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var _a15 = _step16.value;\n              [].forEach.call(e.querySelectorAll(_a15), function (t) {\n                (t.namespaceURI === o.SVG_NS ? o.box : o.box.parentNode).appendChild(t), t.style.pointerEvents = \"auto\";\n              });\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(t, e, i) {\n          var _this20 = this;\n          c(o, this.compose) && (n(t, \"afterInit\", u), n(e, \"afterSetChartSize\", function (t) {\n            return _this20.afterSetSize(t.target, t);\n          }), n(e, \"render\", p), n(i, \"show\", u));\n        }\n      }, {\n        key: \"afterSetSize\",\n        value: function afterSetSize(t, e) {\n          var i, s, r;\n          var _ref15 = t.options.chart.scrollablePlotArea || {},\n            o = _ref15.minWidth,\n            n = _ref15.minHeight,\n            a = t.clipBox,\n            h = t.plotBox,\n            c = t.inverted,\n            p = t.renderer;\n          if (!p.forExport && (o ? (t.scrollablePixelsX = i = Math.max(0, o - t.chartWidth), i && (t.scrollablePlotBox = d(t.plotBox), h.width = t.plotWidth += i, a[c ? \"height\" : \"width\"] += i, r = !0)) : n && (t.scrollablePixelsY = s = Math.max(0, n - t.chartHeight), l(s) && (t.scrollablePlotBox = d(t.plotBox), h.height = t.plotHeight += s, a[c ? \"width\" : \"height\"] += s, r = !1)), l(r) && !e.skipAxes)) {\n            var _iterator17 = _createForOfIteratorHelper(t.axes),\n              _step17;\n            try {\n              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                var _e50 = _step17.value;\n                _e50.horiz === r && (_e50.setAxisSize(), _e50.setAxisTranslation());\n              }\n            } catch (err) {\n              _iterator17.e(err);\n            } finally {\n              _iterator17.f();\n            }\n          }\n        }\n      }]);\n    }();\n    return g.fixedSelectors = [\".highcharts-breadcrumbs-group\", \".highcharts-contextbutton\", \".highcharts-caption\", \".highcharts-credits\", \".highcharts-drillup-button\", \".highcharts-legend\", \".highcharts-legend-checkbox\", \".highcharts-navigator-series\", \".highcharts-navigator-xaxis\", \".highcharts-navigator-yaxis\", \".highcharts-navigator\", \".highcharts-range-selector-group\", \".highcharts-reset-zoom\", \".highcharts-scrollbar\", \".highcharts-subtitle\", \".highcharts-title\"], g;\n  }), i(e, \"Core/Axis/Stacking/StackItem.js\", [e[\"Core/Templating.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.format,\n      r = e.series,\n      o = i.destroyObjectProperties,\n      n = i.fireEvent,\n      a = i.isNumber,\n      h = i.pick;\n    return /*#__PURE__*/function () {\n      function _class3(t, e, i, s, r) {\n        _classCallCheck(this, _class3);\n        var o = t.chart.inverted,\n          n = t.reversed;\n        this.axis = t;\n        var a = this.isNegative = !!i != !!n;\n        this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = r, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {\n          align: e.align || (o ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: e.verticalAlign || (o ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: e.y,\n          x: e.x\n        }, this.textAlign = e.textAlign || (o ? a ? \"right\" : \"left\" : \"center\");\n      }\n      return _createClass(_class3, [{\n        key: \"destroy\",\n        value: function destroy() {\n          o(this, this.axis);\n        }\n      }, {\n        key: \"render\",\n        value: function render(t) {\n          var e = this.axis.chart,\n            i = this.options,\n            r = i.format,\n            o = r ? s(r, this, e) : i.formatter.call(this);\n          if (this.label) this.label.attr({\n            text: o,\n            visibility: \"hidden\"\n          });else {\n            this.label = e.renderer.label(o, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, \"stack-labels\");\n            var _s37 = {\n              r: i.borderRadius || 0,\n              text: o,\n              padding: h(i.padding, 5),\n              visibility: \"hidden\"\n            };\n            e.styledMode || (_s37.fill = i.backgroundColor, _s37.stroke = i.borderColor, _s37[\"stroke-width\"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(_s37), this.label.added || this.label.add(t);\n          }\n          this.label.labelrank = e.plotSizeY, n(this, \"afterRender\");\n        }\n      }, {\n        key: \"setOffset\",\n        value: function setOffset(t, e, i, s, o, l) {\n          var d = this.alignOptions,\n            c = this.axis,\n            p = this.label,\n            u = this.options,\n            g = this.textAlign,\n            f = c.chart,\n            m = this.getStackBox({\n              xOffset: t,\n              width: e,\n              boxBottom: i,\n              boxTop: s,\n              defaultX: o,\n              xAxis: l\n            }),\n            x = d.verticalAlign;\n          if (p && m) {\n            var _t81 = p.getBBox(void 0, 0),\n              _e51 = p.padding,\n              _i43 = \"justify\" === h(u.overflow, \"justify\"),\n              _s38;\n            d.x = u.x || 0, d.y = u.y || 0;\n            var _this$adjustStackPosi = this.adjustStackPosition({\n                labelBox: _t81,\n                verticalAlign: x,\n                textAlign: g\n              }),\n              _o24 = _this$adjustStackPosi.x,\n              _n12 = _this$adjustStackPosi.y;\n            m.x -= _o24, m.y -= _n12, p.align(d, !1, m), (_s38 = f.isInsidePlot(p.alignAttr.x + d.x + _o24, p.alignAttr.y + d.y + _n12)) || (_i43 = !1), _i43 && r.prototype.justifyDataLabel.call(c, p, d, p.alignAttr, _t81, m), p.attr({\n              x: p.alignAttr.x,\n              y: p.alignAttr.y,\n              rotation: u.rotation,\n              rotationOriginX: _t81.width * {\n                left: 0,\n                center: .5,\n                right: 1\n              }[u.textAlign || \"center\"],\n              rotationOriginY: _t81.height / 2\n            }), h(!_i43 && u.crop, !0) && (_s38 = a(p.x) && a(p.y) && f.isInsidePlot(p.x - _e51 + (p.width || 0), p.y) && f.isInsidePlot(p.x + _e51, p.y)), p[_s38 ? \"show\" : \"hide\"]();\n          }\n          n(this, \"afterSetOffset\", {\n            xOffset: t,\n            width: e\n          });\n        }\n      }, {\n        key: \"adjustStackPosition\",\n        value: function adjustStackPosition(_ref16) {\n          var t = _ref16.labelBox,\n            e = _ref16.verticalAlign,\n            i = _ref16.textAlign;\n          var s = {\n              bottom: 0,\n              middle: 1,\n              top: 2,\n              right: 1,\n              center: 0,\n              left: -1\n            },\n            r = s[e],\n            o = s[i];\n          return {\n            x: t.width / 2 + t.width / 2 * o,\n            y: t.height / 2 * r\n          };\n        }\n      }, {\n        key: \"getStackBox\",\n        value: function getStackBox(t) {\n          var e = this.axis,\n            i = e.chart,\n            s = t.boxTop,\n            r = t.defaultX,\n            o = t.xOffset,\n            n = t.width,\n            l = t.boxBottom,\n            d = e.stacking.usePercentage ? 100 : h(s, this.total, 0),\n            c = e.toPixels(d),\n            p = t.xAxis || i.xAxis[0],\n            u = h(r, p.translate(this.x)) + o,\n            g = Math.abs(c - e.toPixels(l || a(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0)),\n            f = i.inverted,\n            m = this.isNegative;\n          return f ? {\n            x: (m ? c : c - g) - i.plotLeft,\n            y: p.height - u - n + p.top - i.plotTop,\n            width: g,\n            height: n\n          } : {\n            x: u + p.transB - i.plotLeft,\n            y: (m ? c - g : c) - i.plotTop,\n            width: n,\n            height: g\n          };\n        }\n      }]);\n    }();\n  }), i(e, \"Core/Axis/Stacking/StackingAxis.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r) {\n    var o;\n    var n = t.getDeferredAnimation,\n      a = i.series.prototype,\n      h = r.addEvent,\n      l = r.correctFloat,\n      d = r.defined,\n      c = r.destroyObjectProperties,\n      p = r.fireEvent,\n      u = r.isArray,\n      g = r.isNumber,\n      f = r.objectEach,\n      m = r.pick;\n    function x() {\n      var t = this.inverted;\n      this.axes.forEach(function (t) {\n        t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);\n      }), this.series.forEach(function (e) {\n        var i = e.xAxis && e.xAxis.options || {};\n        e.options.stacking && e.reserveSpace() && (e.stackKey = [e.type, m(e.options.stack, \"\"), t ? i.top : i.left, t ? i.height : i.width].join(\",\"));\n      });\n    }\n    function y() {\n      var t = this.stacking;\n      if (t) {\n        var _t$stackTotalGroup;\n        var _e52 = t.stacks;\n        f(_e52, function (t, i) {\n          c(t), delete _e52[i];\n        }), (_t$stackTotalGroup = t.stackTotalGroup) === null || _t$stackTotalGroup === void 0 ? void 0 : _t$stackTotalGroup.destroy();\n      }\n    }\n    function b() {\n      this.stacking || (this.stacking = new w(this));\n    }\n    function v(t, e, i, s) {\n      return !d(t) || t.x !== e || s && t.stackKey !== s ? t = {\n        x: e,\n        index: 0,\n        key: s,\n        stackKey: s\n      } : t.index++, t.key = [i, e, t.index].join(\",\"), t;\n    }\n    function S() {\n      var t;\n      var e = this,\n        i = e.yAxis,\n        s = e.stackKey || \"\",\n        r = i.stacking.stacks,\n        o = e.processedXData,\n        n = e.options.stacking,\n        a = e[n + \"Stacker\"];\n      a && [s, \"-\" + s].forEach(function (i) {\n        var s = o.length,\n          n,\n          h,\n          l;\n        for (; s--;) {\n          var _r$i, _h10;\n          n = o[s], t = e.getStackIndicator(t, n, e.index, i), h = (_r$i = r[i]) === null || _r$i === void 0 ? void 0 : _r$i[n], (l = (_h10 = h) === null || _h10 === void 0 ? void 0 : _h10.points[t.key || \"\"]) && a.call(e, l, h, s);\n        }\n      });\n    }\n    function C(t, e, i) {\n      var s = e.total ? 100 / e.total : 0;\n      t[0] = l(t[0] * s), t[1] = l(t[1] * s), this.stackedYData[i] = t[1];\n    }\n    function k(t) {\n      (this.is(\"column\") || this.is(\"columnrange\")) && (this.options.centerInCategory && !this.options.stacking && this.chart.series.length > 1 ? a.setStackedPoints.call(this, t, \"group\") : t.stacking.resetStacks());\n    }\n    function M(t, e) {\n      var i, r, o, n, a, h, c, p, g;\n      var f = e || this.options.stacking;\n      if (!f || !this.reserveSpace() || ({\n        group: \"xAxis\"\n      }[f] || \"yAxis\") !== t.coll) return;\n      var x = this.processedXData,\n        y = this.processedYData,\n        b = [],\n        v = y.length,\n        S = this.options,\n        C = S.threshold || 0,\n        k = S.startFromThreshold ? C : 0,\n        M = S.stack,\n        w = e ? \"\".concat(this.type, \",\").concat(f) : this.stackKey || \"\",\n        A = \"-\" + w,\n        T = this.negStacks,\n        P = t.stacking,\n        L = P.stacks,\n        O = P.oldStacks;\n      for (P.stacksTouched += 1, c = 0; c < v; c++) {\n        var _O$a, _L$n;\n        p = x[c], g = y[c], h = (i = this.getStackIndicator(i, p, this.index)).key || \"\", L[a = (r = T && g < (k ? 0 : C)) ? A : w] || (L[a] = {}), L[a][p] || ((_O$a = O[a]) !== null && _O$a !== void 0 && _O$a[p] ? (L[a][p] = O[a][p], L[a][p].total = null) : L[a][p] = new s(t, t.options.stackLabels, !!r, p, M)), o = L[a][p], null !== g ? (o.points[h] = o.points[this.index] = [m(o.cumulative, k)], d(o.cumulative) || (o.base = h), o.touched = P.stacksTouched, i.index > 0 && !1 === this.singleStacks && (o.points[h][0] = o.points[this.index + \",\" + p + \",0\"][0])) : (delete o.points[h], delete o.points[this.index]);\n        var _e53 = o.total || 0;\n        \"percent\" === f ? (n = r ? w : A, _e53 = T && (_L$n = L[n]) !== null && _L$n !== void 0 && _L$n[p] ? (n = L[n][p]).total = Math.max(n.total || 0, _e53) + Math.abs(g) || 0 : l(_e53 + (Math.abs(g) || 0))) : \"group\" === f ? (u(g) && (g = g[0]), null !== g && _e53++) : _e53 = l(_e53 + (g || 0)), \"group\" === f ? o.cumulative = (_e53 || 1) - 1 : o.cumulative = l(m(o.cumulative, k) + (g || 0)), o.total = _e53, null !== g && (o.points[h].push(o.cumulative), b[c] = o.cumulative, o.hasValidPoints = !0);\n      }\n      \"percent\" === f && (P.usePercentage = !0), \"group\" !== f && (this.stackedYData = b), P.oldStacks = {};\n    }\n    var w = /*#__PURE__*/function () {\n      function w(t) {\n        _classCallCheck(this, w);\n        this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;\n      }\n      return _createClass(w, [{\n        key: \"buildStacks\",\n        value: function buildStacks() {\n          var t, e;\n          var i = this.axis,\n            s = i.series,\n            r = \"xAxis\" === i.coll,\n            o = i.options.reversedStacks,\n            n = s.length;\n          for (this.resetStacks(), this.usePercentage = !1, e = n; e--;) t = s[o ? e : n - e - 1], r && t.setGroupedPoints(i), t.setStackedPoints(i);\n          if (!r) for (e = 0; e < n; e++) s[e].modifyStacks();\n          p(i, \"afterBuildStacks\");\n        }\n      }, {\n        key: \"cleanStacks\",\n        value: function cleanStacks() {\n          this.oldStacks && (this.stacks = this.oldStacks, f(this.stacks, function (t) {\n            f(t, function (t) {\n              t.cumulative = t.total;\n            });\n          }));\n        }\n      }, {\n        key: \"resetStacks\",\n        value: function resetStacks() {\n          var _this21 = this;\n          f(this.stacks, function (t) {\n            f(t, function (e, i) {\n              g(e.touched) && e.touched < _this21.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);\n            });\n          });\n        }\n      }, {\n        key: \"renderStackTotals\",\n        value: function renderStackTotals() {\n          var _t$options$stackLabel;\n          var t = this.axis,\n            e = t.chart,\n            i = e.renderer,\n            s = this.stacks,\n            r = n(e, ((_t$options$stackLabel = t.options.stackLabels) === null || _t$options$stackLabel === void 0 ? void 0 : _t$options$stackLabel.animation) || !1),\n            o = this.stackTotalGroup = this.stackTotalGroup || i.g(\"stack-labels\").attr({\n              zIndex: 6,\n              opacity: 0\n            }).add();\n          o.translate(e.plotLeft, e.plotTop), f(s, function (t) {\n            f(t, function (t) {\n              t.render(o);\n            });\n          }), o.animate({\n            opacity: 1\n          }, r);\n        }\n      }]);\n    }();\n    return (o || (o = {})).compose = function (t, e, i) {\n      var s = e.prototype,\n        r = i.prototype;\n      s.getStacks || (h(t, \"init\", b), h(t, \"destroy\", y), s.getStacks = x, r.getStackIndicator = v, r.modifyStacks = S, r.percentStacker = C, r.setGroupedPoints = k, r.setStackedPoints = M);\n    }, o;\n  }), i(e, \"Series/Line/LineSeries.js\", [e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = i.defined,\n      r = i.merge,\n      o = i.isObject;\n    var n = /*#__PURE__*/function (_t82) {\n      function n() {\n        _classCallCheck(this, n);\n        return _callSuper(this, n, arguments);\n      }\n      _inherits(n, _t82);\n      return _createClass(n, [{\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          var _this22 = this;\n          var t = this.options,\n            e = (this.gappedPath || this.getGraphPath).call(this),\n            i = this.chart.styledMode;\n          [this].concat(_toConsumableArray(this.zones)).forEach(function (s, _n13) {\n            var a,\n              h = s.graph,\n              l = h ? \"animate\" : \"attr\",\n              d = s.dashStyle || t.dashStyle;\n            h ? (h.endX = _this22.preventGraphAnimation ? null : e.xMap, h.animate({\n              d: e\n            })) : e.length && (s.graph = h = _this22.chart.renderer.path(e).addClass(\"highcharts-graph\" + (_n13 ? \" highcharts-zone-graph-\".concat(_n13 - 1, \" \") : \" \") + (_n13 && s.className || \"\")).attr({\n              zIndex: 1\n            }).add(_this22.group)), h && !i && (a = {\n              stroke: !_n13 && t.lineColor || s.color || _this22.color || \"#cccccc\",\n              \"stroke-width\": t.lineWidth || 0,\n              fill: _this22.fillGraph && _this22.color || \"none\"\n            }, d ? a.dashstyle = d : \"square\" !== t.linecap && (a[\"stroke-linecap\"] = a[\"stroke-linejoin\"] = \"round\"), h[l](a).shadow(_n13 < 2 && t.shadow && r({\n              filterUnits: \"userSpaceOnUse\"\n            }, o(t.shadow) ? t.shadow : {}))), h && (h.startX = e.xMap, h.isArea = e.isArea);\n          });\n        }\n      }, {\n        key: \"getGraphPath\",\n        value: function getGraphPath(t, e, i) {\n          var r = this,\n            o = r.options,\n            _n14 = [],\n            a = [],\n            h,\n            l = o.step,\n            d = (t = t || r.points).reversed;\n          return d && t.reverse(), (l = {\n            right: 1,\n            center: 2\n          }[l] || l && 3) && d && (l = 4 - l), (t = this.getValidPoints(t, !1, !(o.connectNulls && !e && !i))).forEach(function (d, c) {\n            var p;\n            var u = d.plotX,\n              g = d.plotY,\n              f = t[c - 1],\n              m = d.isNull || \"number\" != typeof g;\n            (d.leftCliff || f && f.rightCliff) && !i && (h = !0), m && !s(e) && c > 0 ? h = !o.connectNulls : m && !e ? h = !0 : (0 === c || h ? p = [[\"M\", d.plotX, d.plotY]] : r.getPointSpline ? p = [r.getPointSpline(t, d, c)] : l ? (p = 1 === l ? [[\"L\", f.plotX, g]] : 2 === l ? [[\"L\", (f.plotX + u) / 2, f.plotY], [\"L\", (f.plotX + u) / 2, g]] : [[\"L\", u, f.plotY]]).push([\"L\", u, g]) : p = [[\"L\", u, g]], a.push(d.x), l && (a.push(d.x), 2 === l && a.push(d.x)), _n14.push.apply(_n14, p), h = !1);\n          }), _n14.xMap = a, r.graphPath = _n14, _n14;\n        }\n      }]);\n    }(t);\n    return n.defaultOptions = r(t.defaultOptions, {\n      legendSymbol: \"lineMarker\"\n    }), e.registerSeriesType(\"line\", n), n;\n  }), i(e, \"Series/Area/AreaSeriesDefaults.js\", [], function () {\n    return {\n      threshold: 0,\n      legendSymbol: \"areaMarker\"\n    };\n  }), i(e, \"Series/Area/AreaSeries.js\", [e[\"Series/Area/AreaSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = e.seriesTypes.line,\n      r = i.extend,\n      o = i.merge,\n      n = i.objectEach,\n      a = i.pick;\n    var h = /*#__PURE__*/function (_s39) {\n      function h() {\n        _classCallCheck(this, h);\n        return _callSuper(this, h, arguments);\n      }\n      _inherits(h, _s39);\n      return _createClass(h, [{\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          var _this23 = this;\n          this.areaPath = [], _superPropGet(h, \"drawGraph\", this, 1).apply(this);\n          var t = this.areaPath,\n            e = this.options;\n          [this].concat(_toConsumableArray(this.zones)).forEach(function (i, s) {\n            var _e$fillOpacity;\n            var r = {},\n              o = i.fillColor || e.fillColor,\n              n = i.area,\n              a = n ? \"animate\" : \"attr\";\n            n ? (n.endX = _this23.preventGraphAnimation ? null : t.xMap, n.animate({\n              d: t\n            })) : (r.zIndex = 0, (n = i.area = _this23.chart.renderer.path(t).addClass(\"highcharts-area\" + (s ? \" highcharts-zone-area-\".concat(s - 1, \" \") : \" \") + (s && i.className || \"\")).add(_this23.group)).isArea = !0), _this23.chart.styledMode || (r.fill = o || i.color || _this23.color, r[\"fill-opacity\"] = o ? 1 : (_e$fillOpacity = e.fillOpacity) !== null && _e$fillOpacity !== void 0 ? _e$fillOpacity : .75, n.css({\n              pointerEvents: _this23.stickyTracking ? \"none\" : \"auto\"\n            })), n[a](r), n.startX = t.xMap, n.shiftUnit = e.step ? 2 : 1;\n          });\n        }\n      }, {\n        key: \"getGraphPath\",\n        value: function getGraphPath(t) {\n          var e, i, r;\n          var o = s.prototype.getGraphPath,\n            n = this.options,\n            _h11 = n.stacking,\n            l = this.yAxis,\n            d = [],\n            c = [],\n            p = this.index,\n            u = l.stacking.stacks[this.stackKey],\n            g = n.threshold,\n            f = Math.round(l.getThreshold(n.threshold)),\n            m = a(n.connectNulls, \"percent\" === _h11),\n            x = function x(i, s, r) {\n              var o = t[i],\n                n = _h11 && u[o.x].points[p],\n                a = o[r + \"Null\"] || 0,\n                m = o[r + \"Cliff\"] || 0,\n                x,\n                y,\n                b = !0;\n              m || a ? (x = (a ? n[0] : n[1]) + m, y = n[0] + m, b = !!a) : !_h11 && t[s] && t[s].isNull && (x = y = g), void 0 !== x && (c.push({\n                plotX: e,\n                plotY: null === x ? f : l.getThreshold(x),\n                isNull: b,\n                isCliff: !0\n              }), d.push({\n                plotX: e,\n                plotY: null === y ? f : l.getThreshold(y),\n                doCurve: !1\n              }));\n            };\n          t = t || this.points, _h11 && (t = this.getStackPoints(t));\n          for (var _s40 = 0, _o25 = t.length; _s40 < _o25; ++_s40) _h11 || (t[_s40].leftCliff = t[_s40].rightCliff = t[_s40].leftNull = t[_s40].rightNull = void 0), i = t[_s40].isNull, e = a(t[_s40].rectPlotX, t[_s40].plotX), r = _h11 ? a(t[_s40].yBottom, f) : f, i && !m || (m || x(_s40, _s40 - 1, \"left\"), i && !_h11 && m || (c.push(t[_s40]), d.push({\n            x: _s40,\n            plotX: e,\n            plotY: r\n          })), m || x(_s40, _s40 + 1, \"right\"));\n          var y = o.call(this, c, !0, !0);\n          d.reversed = !0;\n          var b = o.call(this, d, !0, !0),\n            v = b[0];\n          v && \"M\" === v[0] && (b[0] = [\"L\", v[1], v[2]]);\n          var S = y.concat(b);\n          S.length && S.push([\"Z\"]);\n          var C = o.call(this, c, !1, m);\n          return this.chart.series.length > 1 && _h11 && c.some(function (t) {\n            return t.isCliff;\n          }) && (S.hasStackedCliffs = C.hasStackedCliffs = !0), S.xMap = y.xMap, this.areaPath = S, C;\n        }\n      }, {\n        key: \"getStackPoints\",\n        value: function getStackPoints(t) {\n          var e = this,\n            i = [],\n            s = [],\n            r = this.xAxis,\n            o = this.yAxis,\n            _h12 = o.stacking.stacks[this.stackKey],\n            l = {},\n            d = o.series,\n            c = d.length,\n            p = o.options.reversedStacks ? 1 : -1,\n            u = d.indexOf(e);\n          if (t = t || this.points, this.options.stacking) {\n            for (var _e54 = 0; _e54 < t.length; _e54++) t[_e54].leftNull = t[_e54].rightNull = void 0, l[t[_e54].x] = t[_e54];\n            n(_h12, function (t, e) {\n              null !== t.total && s.push(e);\n            }), s.sort(function (t, e) {\n              return t - e;\n            });\n            var g = d.map(function (t) {\n              return t.visible;\n            });\n            s.forEach(function (t, n) {\n              var f = 0,\n                m,\n                x;\n              if (l[t] && !l[t].isNull) i.push(l[t]), [-1, 1].forEach(function (i) {\n                var r = 1 === i ? \"rightNull\" : \"leftNull\",\n                  o = _h12[s[n + i]],\n                  a = 0;\n                if (o) {\n                  var _i44 = u;\n                  for (; _i44 >= 0 && _i44 < c;) {\n                    var _s41 = d[_i44].index;\n                    !(m = o.points[_s41]) && (_s41 === e.index ? l[t][r] = !0 : g[_i44] && (x = _h12[t].points[_s41]) && (a -= x[1] - x[0])), _i44 += p;\n                  }\n                }\n                l[t][1 === i ? \"rightCliff\" : \"leftCliff\"] = a;\n              });else {\n                var _e55 = u;\n                for (; _e55 >= 0 && _e55 < c;) {\n                  var _i45 = d[_e55].index;\n                  if (m = _h12[t].points[_i45]) {\n                    f = m[1];\n                    break;\n                  }\n                  _e55 += p;\n                }\n                f = a(f, 0), f = o.translate(f, 0, 1, 0, 1), i.push({\n                  isNull: !0,\n                  plotX: r.translate(t, 0, 0, 0, 1),\n                  x: t,\n                  plotY: f,\n                  yBottom: f\n                });\n              }\n            });\n          }\n          return i;\n        }\n      }]);\n    }(s);\n    return h.defaultOptions = o(s.defaultOptions, t), r(h.prototype, {\n      singleStacks: !1\n    }), e.registerSeriesType(\"area\", h), h;\n  }), i(e, \"Series/Spline/SplineSeries.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.seriesTypes.line,\n      s = e.merge,\n      r = e.pick;\n    var o = /*#__PURE__*/function (_i46) {\n      function o() {\n        _classCallCheck(this, o);\n        return _callSuper(this, o, arguments);\n      }\n      _inherits(o, _i46);\n      return _createClass(o, [{\n        key: \"getPointSpline\",\n        value: function getPointSpline(t, e, i) {\n          var s, _o26, n, a;\n          var h = e.plotX || 0,\n            l = e.plotY || 0,\n            d = t[i - 1],\n            c = t[i + 1];\n          function p(t) {\n            return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;\n          }\n          if (p(d) && p(c)) {\n            var _t83 = d.plotX || 0,\n              _i47 = d.plotY || 0,\n              _r20 = c.plotX || 0,\n              _p9 = c.plotY || 0,\n              _u4 = 0;\n            s = (1.5 * h + _t83) / 2.5, _o26 = (1.5 * l + _i47) / 2.5, n = (1.5 * h + _r20) / 2.5, a = (1.5 * l + _p9) / 2.5, n !== s && (_u4 = (a - _o26) * (n - h) / (n - s) + l - a), _o26 += _u4, a += _u4, _o26 > _i47 && _o26 > l ? (_o26 = Math.max(_i47, l), a = 2 * l - _o26) : _o26 < _i47 && _o26 < l && (_o26 = Math.min(_i47, l), a = 2 * l - _o26), a > _p9 && a > l ? (a = Math.max(_p9, l), _o26 = 2 * l - a) : a < _p9 && a < l && (a = Math.min(_p9, l), _o26 = 2 * l - a), e.rightContX = n, e.rightContY = a, e.controlPoints = {\n              low: [s, _o26],\n              high: [n, a]\n            };\n          }\n          var u = [\"C\", r(d.rightContX, d.plotX, 0), r(d.rightContY, d.plotY, 0), r(s, h, 0), r(_o26, l, 0), h, l];\n          return d.rightContX = d.rightContY = void 0, u;\n        }\n      }]);\n    }(i);\n    return o.defaultOptions = s(i.defaultOptions), t.registerSeriesType(\"spline\", o), o;\n  }), i(e, \"Series/AreaSpline/AreaSplineSeries.js\", [e[\"Series/Spline/SplineSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var _e$seriesTypes = e.seriesTypes,\n      s = _e$seriesTypes.area,\n      r = _e$seriesTypes.area.prototype,\n      o = i.extend,\n      n = i.merge;\n    var a = /*#__PURE__*/function (_t84) {\n      function a() {\n        _classCallCheck(this, a);\n        return _callSuper(this, a, arguments);\n      }\n      _inherits(a, _t84);\n      return _createClass(a);\n    }(t);\n    return a.defaultOptions = n(t.defaultOptions, s.defaultOptions), o(a.prototype, {\n      getGraphPath: r.getGraphPath,\n      getStackPoints: r.getStackPoints,\n      drawGraph: r.drawGraph\n    }), e.registerSeriesType(\"areaspline\", a), a;\n  }), i(e, \"Series/Column/ColumnSeriesDefaults.js\", [], function () {\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    };\n  }), i(e, \"Series/Column/ColumnSeries.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Color/Color.js\"], e[\"Series/Column/ColumnSeriesDefaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n) {\n    var a = t.animObject,\n      h = e.parse,\n      l = s.noop,\n      d = n.clamp,\n      c = n.crisp,\n      p = n.defined,\n      u = n.extend,\n      g = n.fireEvent,\n      f = n.isArray,\n      m = n.isNumber,\n      x = n.merge,\n      y = n.pick,\n      b = n.objectEach;\n    var v = /*#__PURE__*/function (_r21) {\n      function v() {\n        _classCallCheck(this, v);\n        return _callSuper(this, v, arguments);\n      }\n      _inherits(v, _r21);\n      return _createClass(v, [{\n        key: \"animate\",\n        value: function animate(t) {\n          var e, i;\n          var s = this,\n            r = this.yAxis,\n            o = r.pos,\n            n = r.reversed,\n            h = s.options,\n            _this$chart2 = this.chart,\n            l = _this$chart2.clipOffset,\n            c = _this$chart2.inverted,\n            p = {},\n            g = c ? \"translateX\" : \"translateY\";\n          t && l ? (p.scaleY = .001, i = d(r.toPixels(h.threshold), o, o + r.len), c ? (i += n ? -Math.floor(l[0]) : Math.ceil(l[2]), p.translateX = i - r.len) : (i += n ? Math.ceil(l[0]) : -Math.floor(l[2]), p.translateY = i), s.clipBox && s.setClip(), s.group.attr(p)) : (e = Number(s.group.attr(g)), s.group.animate({\n            scaleY: 1\n          }, u(a(s.options.animation), {\n            step: function step(t, i) {\n              s.group && (p[g] = e + i.pos * (o - e), s.group.attr(p));\n            }\n          })));\n        }\n      }, {\n        key: \"init\",\n        value: function init(t, e) {\n          _superPropGet(v, \"init\", this, 1).apply(this, arguments);\n          var i = this;\n          (t = i.chart).hasRendered && t.series.forEach(function (t) {\n            t.type === i.type && (t.isDirty = !0);\n          });\n        }\n      }, {\n        key: \"getColumnMetrics\",\n        value: function getColumnMetrics() {\n          var _i$brokenAxis, _i$ordinal;\n          var t = this,\n            e = t.options,\n            i = t.xAxis,\n            s = t.yAxis,\n            r = i.options.reversedStacks,\n            o = i.reversed && !r || !i.reversed && r,\n            n = {},\n            a,\n            h = 0;\n          !1 === e.grouping ? h = 1 : t.chart.series.forEach(function (e) {\n            var i;\n            var r = e.yAxis,\n              o = e.options;\n            e.type === t.type && e.reserveSpace() && s.len === r.len && s.pos === r.pos && (o.stacking && \"group\" !== o.stacking ? (void 0 === n[a = e.stackKey] && (n[a] = h++), i = n[a]) : !1 !== o.grouping && (i = h++), e.columnIndex = i);\n          });\n          var l = Math.min(Math.abs(i.transA) * (!((_i$brokenAxis = i.brokenAxis) !== null && _i$brokenAxis !== void 0 && _i$brokenAxis.hasBreaks) && ((_i$ordinal = i.ordinal) === null || _i$ordinal === void 0 ? void 0 : _i$ordinal.slope) || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len),\n            d = l * e.groupPadding,\n            c = (l - 2 * d) / (h || 1),\n            p = Math.min(e.maxPointWidth || i.len, y(e.pointWidth, c * (1 - 2 * e.pointPadding))),\n            u = (t.columnIndex || 0) + (o ? 1 : 0);\n          return t.columnMetrics = {\n            width: p,\n            offset: (c - p) / 2 + (d + u * c - l / 2) * (o ? -1 : 1),\n            paddedWidth: c,\n            columnCount: h\n          }, t.columnMetrics;\n        }\n      }, {\n        key: \"crispCol\",\n        value: function crispCol(t, e, i, s) {\n          var r = this.borderWidth,\n            o = this.chart.inverted;\n          return s = c(e + s, r, o) - (e = c(e, r, o)), this.options.crisp && (i = c(t + i, r) - (t = c(t, r))), {\n            x: t,\n            y: e,\n            width: i,\n            height: s\n          };\n        }\n      }, {\n        key: \"adjustForMissingColumns\",\n        value: function adjustForMissingColumns(t, e, i, s) {\n          var _this24 = this;\n          if (!i.isNull && s.columnCount > 1) {\n            var _this$xAxis$stacking;\n            var _r22 = this.xAxis.series.filter(function (t) {\n                return t.visible;\n              }).map(function (t) {\n                return t.index;\n              }),\n              _o27 = 0,\n              _n15 = 0;\n            b((_this$xAxis$stacking = this.xAxis.stacking) === null || _this$xAxis$stacking === void 0 ? void 0 : _this$xAxis$stacking.stacks, function (t) {\n              if (\"number\" == typeof i.x) {\n                var _e56 = t[i.x.toString()];\n                if (_e56 && f(_e56.points[_this24.index])) {\n                  var _t85 = Object.keys(_e56.points).filter(function (t) {\n                    return !t.match(\",\") && _e56.points[t] && _e56.points[t].length > 1;\n                  }).map(parseFloat).filter(function (t) {\n                    return -1 !== _r22.indexOf(t);\n                  }).sort(function (t, e) {\n                    return e - t;\n                  });\n                  _o27 = _t85.indexOf(_this24.index), _n15 = _t85.length;\n                }\n              }\n            }), _o27 = this.xAxis.reversed ? _n15 - 1 - _o27 : _o27;\n            var _a16 = (_n15 - 1) * s.paddedWidth + e;\n            t = (i.plotX || 0) + _a16 / 2 - e - _o27 * s.paddedWidth;\n          }\n          return t;\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          var t = this,\n            e = t.chart,\n            i = t.options,\n            s = t.dense = t.closestPointRange * t.xAxis.transA < 2,\n            o = t.borderWidth = y(i.borderWidth, s ? 0 : 1),\n            n = t.xAxis,\n            a = t.yAxis,\n            h = i.threshold,\n            l = y(i.minPointLength, 5),\n            c = t.getColumnMetrics(),\n            u = c.width,\n            f = t.pointXOffset = c.offset,\n            x = t.dataMin,\n            b = t.dataMax,\n            _v5 = t.translatedThreshold = a.getThreshold(h),\n            S = t.barW = Math.max(u, 1 + 2 * o);\n          i.pointPadding && (S = Math.ceil(S)), r.prototype.translate.apply(t), t.points.forEach(function (s) {\n            var r = y(s.yBottom, _v5),\n              o = 999 + Math.abs(r),\n              g = s.plotX || 0,\n              C = d(s.plotY, -o, a.len + o),\n              k,\n              M = Math.min(C, r),\n              w = Math.max(C, r) - M,\n              A = u,\n              T = g + f,\n              P = S;\n            l && Math.abs(w) < l && (w = l, k = !a.reversed && !s.negative || a.reversed && s.negative, m(h) && m(b) && s.y === h && b <= h && (a.min || 0) < h && (x !== b || (a.max || 0) <= h) && (k = !k, s.negative = !s.negative), M = Math.abs(M - _v5) > l ? r - l : _v5 - (k ? l : 0)), p(s.options.pointWidth) && (T -= Math.round(((A = P = Math.ceil(s.options.pointWidth)) - u) / 2)), i.centerInCategory && !i.stacking && (T = t.adjustForMissingColumns(T, A, s, c)), s.barX = T, s.pointWidth = A, s.tooltipPos = e.inverted ? [d(a.len + a.pos - e.plotLeft - C, a.pos - e.plotLeft, a.len + a.pos - e.plotLeft), n.len + n.pos - e.plotTop - T - P / 2, w] : [n.left - e.plotLeft + T + P / 2, d(C + a.pos - e.plotTop, a.pos - e.plotTop, a.len + a.pos - e.plotTop), w], s.shapeType = t.pointClass.prototype.shapeType || \"roundedRect\", s.shapeArgs = t.crispCol(T, s.isNull ? _v5 : M, P, s.isNull ? 0 : w);\n          }), g(this, \"afterColumnTranslate\");\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(t, e) {\n          var i = this.options,\n            s = this.pointAttrToOptions || {},\n            r = s.stroke || \"borderColor\",\n            o = s[\"stroke-width\"] || \"borderWidth\",\n            n,\n            a,\n            l,\n            d = t && t.color || this.color,\n            c = t && t[r] || i[r] || d,\n            p = t && t.options.dashStyle || i.dashStyle,\n            u = t && t[o] || i[o] || this[o] || 0,\n            g = y(t && t.opacity, i.opacity, 1);\n          t && this.zones.length && (a = t.getZone(), d = t.options.color || a && (a.color || t.nonZonedColor) || this.color, a && (c = a.borderColor || c, p = a.dashStyle || p, u = a.borderWidth || u)), e && t && (l = (n = x(i.states[e], t.options.states && t.options.states[e] || {})).brightness, d = n.color || void 0 !== l && h(d).brighten(n.brightness).get() || d, c = n[r] || c, u = n[o] || u, p = n.dashStyle || p, g = y(n.opacity, g));\n          var f = {\n            fill: d,\n            stroke: c,\n            \"stroke-width\": u,\n            opacity: g\n          };\n          return p && (f.dashstyle = p), f;\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var e;\n          var i = this,\n            s = this.chart,\n            r = i.options,\n            o = s.renderer,\n            n = r.animationLimit || 250;\n          t.forEach(function (t) {\n            var a = t.plotY,\n              h = t.graphic,\n              l = !!h,\n              d = h && s.pointCount < n ? \"animate\" : \"attr\";\n            m(a) && null !== t.y ? (e = t.shapeArgs, h && t.hasNewShapeType() && (h = h.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !h && (t.graphic = h = o[t.shapeType](e).add(t.group || i.group), h && i.enabledDataSorting && s.hasRendered && s.pointCount < n && (h.attr({\n              x: t.startXPos\n            }), l = !0, d = \"animate\")), h && l && h[d](x(e)), s.styledMode || h[d](i.pointAttribs(t, t.selected && \"select\")).shadow(!1 !== t.allowShadow && r.shadow), h && (h.addClass(t.getClassName(), !0), h.attr({\n              visibility: t.visible ? \"inherit\" : \"hidden\"\n            }))) : h && (t.graphic = h.destroy());\n          });\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var e;\n          var i = this,\n            s = i.chart,\n            r = s.pointer,\n            o = function o(t) {\n              var e = r === null || r === void 0 ? void 0 : r.getPointFromEvent(t);\n              r && e && i.options.enableMouseTracking && (r.isDirectTouch = !0, e.onMouseOver(t));\n            };\n          t.forEach(function (t) {\n            e = f(t.dataLabels) ? t.dataLabels : t.dataLabel ? [t.dataLabel] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function (e) {\n              (e.div || e.element).point = t;\n            });\n          }), i._hasTracking || (i.trackerGroups.forEach(function (t) {\n            i[t] && (i[t].addClass(\"highcharts-tracker\").on(\"mouseover\", o).on(\"mouseout\", function (t) {\n              r === null || r === void 0 || r.onTrackerMouseOut(t);\n            }).on(\"touchstart\", o), !s.styledMode && i.options.cursor && i[t].css({\n              cursor: i.options.cursor\n            }));\n          }), i._hasTracking = !0), g(this, \"afterDrawTracker\");\n        }\n      }, {\n        key: \"remove\",\n        value: function remove() {\n          var t = this,\n            e = t.chart;\n          e.hasRendered && e.series.forEach(function (e) {\n            e.type === t.type && (e.isDirty = !0);\n          }), r.prototype.remove.apply(t, arguments);\n        }\n      }]);\n    }(r);\n    return v.defaultOptions = x(r.defaultOptions, i), u(v.prototype, {\n      directTouch: !0,\n      getSymbol: l,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    }), o.registerSeriesType(\"column\", v), v;\n  }), i(e, \"Core/Series/DataLabel.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Templating.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s;\n    var r = t.getDeferredAnimation,\n      o = e.format,\n      n = i.defined,\n      a = i.extend,\n      h = i.fireEvent,\n      l = i.isArray,\n      d = i.isString,\n      c = i.merge,\n      p = i.objectEach,\n      u = i.pick,\n      g = i.pInt,\n      f = i.splat;\n    return function (t) {\n      function e() {\n        return v(this).some(function (t) {\n          return t === null || t === void 0 ? void 0 : t.enabled;\n        });\n      }\n      function i(t, e, i, s, r) {\n        var o = this.chart,\n          h = this.enabledDataSorting,\n          l = this.isCartesian && o.inverted,\n          d = t.plotX,\n          p = t.plotY,\n          g = i.rotation || 0,\n          f = n(d) && n(p) && o.isInsidePlot(d, Math.round(p), {\n            inverted: l,\n            paneCoordinates: !0,\n            series: this\n          }),\n          m = 0 === g && \"justify\" === u(i.overflow, h ? \"none\" : \"justify\"),\n          x = this.visible && !1 !== t.visible && n(d) && (t.series.forceDL || h && !m || f || u(i.inside, !!this.options.stacking) && s && o.isInsidePlot(d, l ? s.x + 1 : s.y + s.height - 1, {\n            inverted: l,\n            paneCoordinates: !0,\n            series: this\n          })),\n          y = t.pos();\n        if (x && y) {\n          var _this$yAxis;\n          var b;\n          var _n16 = e.getBBox(),\n            _d8 = e.getBBox(void 0, 0),\n            _p10 = {\n              right: 1,\n              center: .5\n            }[i.align || 0] || 0,\n            _v6 = {\n              bottom: 1,\n              middle: .5\n            }[i.verticalAlign || 0] || 0;\n          if (s = a({\n            x: y[0],\n            y: Math.round(y[1]),\n            width: 0,\n            height: 0\n          }, s || {}), \"plotEdges\" === i.alignTo && this.isCartesian && (s[l ? \"x\" : \"y\"] = 0, s[l ? \"width\" : \"height\"] = ((_this$yAxis = this.yAxis) === null || _this$yAxis === void 0 ? void 0 : _this$yAxis.len) || 0), a(i, {\n            width: _n16.width,\n            height: _n16.height\n          }), b = s, h && this.xAxis && !m && this.setDataLabelStartPos(t, e, r, f, b), e.align(c(i, {\n            width: _d8.width,\n            height: _d8.height\n          }), !1, s, !1), e.alignAttr.x += _p10 * (_d8.width - _n16.width), e.alignAttr.y += _v6 * (_d8.height - _n16.height), e[e.placed ? \"animate\" : \"attr\"]({\n            x: e.alignAttr.x + (_n16.width - _d8.width) / 2,\n            y: e.alignAttr.y + (_n16.height - _d8.height) / 2,\n            rotationOriginX: (e.width || 0) / 2,\n            rotationOriginY: (e.height || 0) / 2\n          }), m && s.height >= 0) this.justifyDataLabel(e, i, e.alignAttr, _n16, s, r);else if (u(i.crop, !0)) {\n            var _e$alignAttr = e.alignAttr,\n              _t86 = _e$alignAttr.x,\n              _i48 = _e$alignAttr.y;\n            x = o.isInsidePlot(_t86, _i48, {\n              paneCoordinates: !0,\n              series: this\n            }) && o.isInsidePlot(_t86 + _n16.width - 1, _i48 + _n16.height - 1, {\n              paneCoordinates: !0,\n              series: this\n            });\n          }\n          i.shape && !g && e[r ? \"attr\" : \"animate\"]({\n            anchorX: y[0],\n            anchorY: y[1]\n          });\n        }\n        r && h && (e.placed = !1), x || h && !m ? (e.show(), e.placed = !0) : (e.hide(), e.placed = !1);\n      }\n      function s() {\n        return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n      }\n      function m(t) {\n        var e = this.hasRendered || 0,\n          i = this.initDataLabelsGroup().attr({\n            opacity: +e\n          });\n        return !e && i && (this.visible && i.show(), this.options.animation ? i.animate({\n          opacity: 1\n        }, t) : i.attr({\n          opacity: 1\n        })), i;\n      }\n      function x(t) {\n        var _i$hasDataLabels2;\n        var e;\n        t = t || this.points;\n        var i = this,\n          s = i.chart,\n          a = i.options,\n          l = s.renderer,\n          _s$options$chart = s.options.chart,\n          c = _s$options$chart.backgroundColor,\n          m = _s$options$chart.plotBackgroundColor,\n          x = l.getContrast(d(m) && m || d(c) && c || \"#000000\"),\n          y = v(i),\n          _y$ = y[0],\n          S = _y$.animation,\n          C = _y$.defer,\n          k = C ? r(s, S, i) : {\n            defer: 0,\n            duration: 0\n          };\n        h(this, \"drawDataLabels\"), (_i$hasDataLabels2 = i.hasDataLabels) !== null && _i$hasDataLabels2 !== void 0 && _i$hasDataLabels2.call(i) && (e = this.initDataLabels(k), t.forEach(function (t) {\n          var _t$options3;\n          var r = t.dataLabels || [];\n          f(b(y, t.dlOptions || ((_t$options3 = t.options) === null || _t$options3 === void 0 ? void 0 : _t$options3.dataLabels))).forEach(function (c, f) {\n            var m = c.enabled && (t.visible || t.dataLabelOnHidden) && (!t.isNull || t.dataLabelOnNull) && function (t, e) {\n                var i = e.filter;\n                if (i) {\n                  var _e57 = i.operator,\n                    _s42 = t[i.property],\n                    _r23 = i.value;\n                  return \">\" === _e57 && _s42 > _r23 || \"<\" === _e57 && _s42 < _r23 || \">=\" === _e57 && _s42 >= _r23 || \"<=\" === _e57 && _s42 <= _r23 || \"==\" === _e57 && _s42 == _r23 || \"===\" === _e57 && _s42 === _r23 || \"!=\" === _e57 && _s42 != _r23 || \"!==\" === _e57 && _s42 !== _r23;\n                }\n                return !0;\n              }(t, c),\n              y = c.backgroundColor,\n              b = c.borderColor,\n              v = c.distance,\n              _c$style = c.style,\n              S = _c$style === void 0 ? {} : _c$style,\n              C,\n              k,\n              M,\n              w,\n              A = {},\n              T = r[f],\n              P = !T,\n              L;\n            m && (k = u(c[t.formatPrefix + \"Format\"], c.format), C = t.getLabelConfig(), M = n(k) ? o(k, C, s) : (c[t.formatPrefix + \"Formatter\"] || c.formatter).call(C, c), w = c.rotation, !s.styledMode && (S.color = u(c.color, S.color, d(i.color) ? i.color : void 0, \"#000000\"), \"contrast\" === S.color ? (\"none\" !== y && (L = y), t.contrastColor = l.getContrast(\"auto\" !== L && L || t.color || i.color), S.color = L || !n(v) && c.inside || 0 > g(v || 0) || a.stacking ? t.contrastColor : x) : delete t.contrastColor, a.cursor && (S.cursor = a.cursor)), A = {\n              r: c.borderRadius || 0,\n              rotation: w,\n              padding: c.padding,\n              zIndex: 1\n            }, s.styledMode || (A.fill = \"auto\" === y ? t.color : y, A.stroke = \"auto\" === b ? t.color : b, A[\"stroke-width\"] = c.borderWidth), p(A, function (t, e) {\n              void 0 === t && delete A[e];\n            })), !T || m && n(M) && !!T.div == !!c.useHTML && (T.rotation && c.rotation || T.rotation === c.rotation) || (T = void 0, P = !0), m && n(M) && (T ? A.text = M : (T = l.label(M, 0, 0, c.shape, void 0, void 0, c.useHTML, void 0, \"data-label\")).addClass(\" highcharts-data-label-color-\" + t.colorIndex + \" \" + (c.className || \"\") + (c.useHTML ? \" highcharts-tracker\" : \"\")), T && (T.options = c, T.attr(A), s.styledMode || T.css(S).shadow(c.shadow), h(T, \"beforeAddingDataLabel\", {\n              labelOptions: c,\n              point: t\n            }), T.added || T.add(e), i.alignDataLabel(t, T, c, void 0, P), T.isActive = !0, r[f] && r[f] !== T && r[f].destroy(), r[f] = T));\n          });\n          var c = r.length;\n          for (; c--;) {\n            var _r$c;\n            r[c] && r[c].isActive ? r[c].isActive = !1 : ((_r$c = r[c]) !== null && _r$c !== void 0 && _r$c.destroy(), r.splice(c, 1));\n          }\n          t.dataLabel = r[0], t.dataLabels = r;\n        })), h(this, \"afterDrawDataLabels\");\n      }\n      function y(t, e, i, s, r, o) {\n        var n = this.chart,\n          a = e.align,\n          h = e.verticalAlign,\n          l = t.box ? 0 : t.padding || 0,\n          d = n.inverted ? this.yAxis : this.xAxis,\n          c = d ? d.left - n.plotLeft : 0,\n          p = n.inverted ? this.xAxis : this.yAxis,\n          u = p ? p.top - n.plotTop : 0,\n          _e$x = e.x,\n          g = _e$x === void 0 ? 0 : _e$x,\n          _e$y = e.y,\n          f = _e$y === void 0 ? 0 : _e$y,\n          m,\n          x;\n        return (m = (i.x || 0) + l + c) < 0 && (\"right\" === a && g >= 0 ? (e.align = \"left\", e.inside = !0) : g -= m, x = !0), (m = (i.x || 0) + s.width - l + c) > n.plotWidth && (\"left\" === a && g <= 0 ? (e.align = \"right\", e.inside = !0) : g += n.plotWidth - m, x = !0), (m = i.y + l + u) < 0 && (\"bottom\" === h && f >= 0 ? (e.verticalAlign = \"top\", e.inside = !0) : f -= m, x = !0), (m = (i.y || 0) + s.height - l + u) > n.plotHeight && (\"top\" === h && f <= 0 ? (e.verticalAlign = \"bottom\", e.inside = !0) : f += n.plotHeight - m, x = !0), x && (e.x = g, e.y = f, t.placed = !o, t.align(e, void 0, r)), x;\n      }\n      function b(t, e) {\n        var i = [],\n          s;\n        if (l(t) && !l(e)) i = t.map(function (t) {\n          return c(t, e);\n        });else if (l(e) && !l(t)) i = e.map(function (e) {\n          return c(t, e);\n        });else if (l(t) || l(e)) {\n          if (l(t) && l(e)) for (s = Math.max(t.length, e.length); s--;) i[s] = c(t[s], e[s]);\n        } else i = c(t, e);\n        return i;\n      }\n      function v(t) {\n        var _e$series, _e$t$type;\n        var e = t.chart.options.plotOptions;\n        return f(b(b(e === null || e === void 0 || (_e$series = e.series) === null || _e$series === void 0 ? void 0 : _e$series.dataLabels, e === null || e === void 0 || (_e$t$type = e[t.type]) === null || _e$t$type === void 0 ? void 0 : _e$t$type.dataLabels), t.options.dataLabels));\n      }\n      function S(t, e, i, s, r) {\n        var o = this.chart,\n          n = o.inverted,\n          a = this.xAxis,\n          h = a.reversed,\n          l = ((n ? e.height : e.width) || 0) / 2,\n          d = t.pointWidth,\n          c = d ? d / 2 : 0;\n        e.startXPos = n ? r.x : h ? -l - c : a.width - l + c, e.startYPos = n ? h ? this.yAxis.height - l + c : -l - c : r.y, s ? \"hidden\" === e.visibility && (e.show(), e.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : e.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, e.hide), o.hasRendered && (i && e.attr({\n          x: e.startXPos,\n          y: e.startYPos\n        }), e.placed = !0);\n      }\n      t.compose = function (t) {\n        var r = t.prototype;\n        r.initDataLabels || (r.initDataLabels = m, r.initDataLabelsGroup = s, r.alignDataLabel = i, r.drawDataLabels = x, r.justifyDataLabel = y, r.setDataLabelStartPos = S, r.hasDataLabels = e);\n      };\n    }(s || (s = {})), s;\n  }), i(e, \"Series/Column/ColumnDataLabel.js\", [e[\"Core/Series/DataLabel.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var r;\n    var o = e.composed,\n      n = i.series,\n      a = s.merge,\n      h = s.pick,\n      l = s.pushUnique;\n    return function (e) {\n      function i(t, e, i, s, r) {\n        var o = this.chart.inverted,\n          l = t.series,\n          d = (l.xAxis ? l.xAxis.len : this.chart.plotSizeX) || 0,\n          c = (l.yAxis ? l.yAxis.len : this.chart.plotSizeY) || 0,\n          p = t.dlBox || t.shapeArgs,\n          u = h(t.below, t.plotY > h(this.translatedThreshold, c)),\n          g = h(i.inside, !!this.options.stacking);\n        if (p) {\n          if (s = a(p), !(\"allow\" === i.overflow && !1 === i.crop)) {\n            s.y < 0 && (s.height += s.y, s.y = 0);\n            var _t87 = s.y + s.height - c;\n            _t87 > 0 && _t87 < s.height - 1 && (s.height -= _t87);\n          }\n          o && (s = {\n            x: c - s.y - s.height,\n            y: d - s.x - s.width,\n            width: s.height,\n            height: s.width\n          }), g || (o ? (s.x += u ? 0 : s.width, s.width = 0) : (s.y += u ? s.height : 0, s.height = 0));\n        }\n        i.align = h(i.align, !o || g ? \"center\" : u ? \"right\" : \"left\"), i.verticalAlign = h(i.verticalAlign, o || g ? \"middle\" : u ? \"top\" : \"bottom\"), n.prototype.alignDataLabel.call(this, t, e, i, s, r), i.inside && t.contrastColor && e.css({\n          color: t.contrastColor\n        });\n      }\n      e.compose = function (e) {\n        t.compose(n), l(o, \"ColumnDataLabel\") && (e.prototype.alignDataLabel = i);\n      };\n    }(r || (r = {})), r;\n  }), i(e, \"Series/Bar/BarSeries.js\", [e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = i.extend,\n      r = i.merge;\n    var o = /*#__PURE__*/function (_t88) {\n      function o() {\n        _classCallCheck(this, o);\n        return _callSuper(this, o, arguments);\n      }\n      _inherits(o, _t88);\n      return _createClass(o);\n    }(t);\n    return o.defaultOptions = r(t.defaultOptions, {}), s(o.prototype, {\n      inverted: !0\n    }), e.registerSeriesType(\"bar\", o), o;\n  }), i(e, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">●</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    };\n  }), i(e, \"Series/Scatter/ScatterSeries.js\", [e[\"Series/Scatter/ScatterSeriesDefaults.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var _e$seriesTypes2 = e.seriesTypes,\n      s = _e$seriesTypes2.column,\n      r = _e$seriesTypes2.line,\n      o = i.addEvent,\n      n = i.extend,\n      a = i.merge;\n    var h = /*#__PURE__*/function (_r24) {\n      function h() {\n        _classCallCheck(this, h);\n        return _callSuper(this, h, arguments);\n      }\n      _inherits(h, _r24);\n      return _createClass(h, [{\n        key: \"applyJitter\",\n        value: function applyJitter() {\n          var t = this,\n            e = this.options.jitter,\n            i = this.points.length;\n          e && this.points.forEach(function (s, r) {\n            [\"x\", \"y\"].forEach(function (o, n) {\n              if (e[o] && !s.isNull) {\n                var _a17 = \"plot\".concat(o.toUpperCase()),\n                  _h13 = t[\"\".concat(o, \"Axis\")],\n                  l = e[o] * _h13.transA;\n                if (_h13 && !_h13.logarithmic) {\n                  var _t89 = Math.max(0, (s[_a17] || 0) - l),\n                    _e58 = Math.min(_h13.len, (s[_a17] || 0) + l);\n                  s[_a17] = _t89 + (_e58 - _t89) * function (t) {\n                    var e = 1e4 * Math.sin(t);\n                    return e - Math.floor(e);\n                  }(r + n * i), \"x\" === o && (s.clientX = s.plotX);\n                }\n              }\n            });\n          });\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          this.options.lineWidth ? _superPropGet(h, \"drawGraph\", this, 3)([]) : this.graph && (this.graph = this.graph.destroy());\n        }\n      }]);\n    }(r);\n    return h.defaultOptions = a(r.defaultOptions, t), n(h.prototype, {\n      drawTracker: s.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"]\n    }), o(h, \"afterTranslate\", function () {\n      this.applyJitter();\n    }), e.registerSeriesType(\"scatter\", h), h;\n  }), i(e, \"Series/CenteredUtilities.js\", [e[\"Core/Globals.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s, r;\n    var o = t.deg2rad,\n      n = i.fireEvent,\n      a = i.isNumber,\n      h = i.pick,\n      l = i.relativeLength;\n    return (r = s || (s = {})).getCenter = function () {\n      var t = this.options,\n        i = this.chart,\n        s = 2 * (t.slicedOffset || 0),\n        r = i.plotWidth - 2 * s,\n        o = i.plotHeight - 2 * s,\n        d = t.center,\n        c = Math.min(r, o),\n        p = t.thickness,\n        u,\n        g = t.size,\n        f = t.innerSize || 0,\n        m,\n        x;\n      \"string\" == typeof g && (g = parseFloat(g)), \"string\" == typeof f && (f = parseFloat(f));\n      var y = [h(d[0], \"50%\"), h(d[1], \"50%\"), h(g && g < 0 ? void 0 : t.size, \"100%\"), h(f && f < 0 ? void 0 : t.innerSize || 0, \"0%\")];\n      for (!i.angular || this instanceof e || (y[3] = 0), m = 0; m < 4; ++m) x = y[m], u = m < 2 || 2 === m && /%$/.test(x), y[m] = l(x, [r, o, c, y[2]][m]) + (u ? s : 0);\n      return y[3] > y[2] && (y[3] = y[2]), a(p) && 2 * p < y[2] && p > 0 && (y[3] = y[2] - 2 * p), n(this, \"afterGetCenter\", {\n        positions: y\n      }), y;\n    }, r.getStartAndEndRadians = function (t, e) {\n      var i = a(t) ? t : 0,\n        s = a(e) && e > i && e - i < 360 ? e : i + 360;\n      return {\n        start: o * (i + -90),\n        end: o * (s + -90)\n      };\n    }, s;\n  }), i(e, \"Series/Pie/PiePoint.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.setAnimation,\n      r = i.addEvent,\n      o = i.defined,\n      n = i.extend,\n      a = i.isNumber,\n      h = i.pick,\n      l = i.relativeLength;\n    var d = /*#__PURE__*/function (_e59) {\n      function d(t, e, i) {\n        var _this25$name;\n        var _this25;\n        _classCallCheck(this, d);\n        _this25 = _callSuper(this, d, [t, e, i]), _this25.half = 0, (_this25$name = _this25.name) !== null && _this25$name !== void 0 ? _this25$name : _this25.name = \"Slice\";\n        var s = function s(t) {\n          _this25.slice(\"select\" === t.type);\n        };\n        r(_this25, \"select\", s), r(_this25, \"unselect\", s);\n        return _this25;\n      }\n      _inherits(d, _e59);\n      return _createClass(d, [{\n        key: \"getConnectorPath\",\n        value: function getConnectorPath(t) {\n          var e = t.dataLabelPosition,\n            i = t.options || {},\n            s = i.connectorShape,\n            r = this.connectorShapes[s] || s;\n          return e && r.call(this, _objectSpread(_objectSpread({}, e.computed), {}, {\n            alignment: e.alignment\n          }), e.connectorPosition, i) || [];\n        }\n      }, {\n        key: \"getTranslate\",\n        value: function getTranslate() {\n          return this.sliced && this.slicedTranslation || {\n            translateX: 0,\n            translateY: 0\n          };\n        }\n      }, {\n        key: \"haloPath\",\n        value: function haloPath(t) {\n          var e = this.shapeArgs;\n          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {\n            innerR: e.r - 1,\n            start: e.start,\n            end: e.end,\n            borderRadius: e.borderRadius\n          });\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return a(this.y) && this.y >= 0;\n        }\n      }, {\n        key: \"setVisible\",\n        value: function setVisible(t) {\n          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          t !== this.visible && this.update({\n            visible: t !== null && t !== void 0 ? t : !this.visible\n          }, e, void 0, !1);\n        }\n      }, {\n        key: \"slice\",\n        value: function slice(t, e, i) {\n          var r = this.series;\n          s(i, r.chart), e = h(e, !0), this.sliced = this.options.sliced = t = o(t) ? t : !this.sliced, r.options.data[r.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());\n        }\n      }]);\n    }(e);\n    return n(d.prototype, {\n      connectorShapes: {\n        fixedOffset: function fixedOffset(t, e, i) {\n          var s = e.breakAt,\n            r = e.touchingSliceAt,\n            o = i.softConnector ? [\"C\", t.x + (\"left\" === t.alignment ? -5 : 5), t.y, 2 * s.x - r.x, 2 * s.y - r.y, s.x, s.y] : [\"L\", s.x, s.y];\n          return [[\"M\", t.x, t.y], o, [\"L\", r.x, r.y]];\n        },\n        straight: function straight(t, e) {\n          var i = e.touchingSliceAt;\n          return [[\"M\", t.x, t.y], [\"L\", i.x, i.y]];\n        },\n        crookedLine: function crookedLine(t, e, i) {\n          var s = e.breakAt,\n            r = e.touchingSliceAt,\n            o = this.series,\n            _o$center = _slicedToArray(o.center, 3),\n            n = _o$center[0],\n            a = _o$center[1],\n            h = _o$center[2],\n            d = h / 2,\n            _o$chart = o.chart,\n            c = _o$chart.plotLeft,\n            p = _o$chart.plotWidth,\n            u = \"left\" === t.alignment,\n            g = t.x,\n            f = t.y,\n            m = s.x;\n          if (i.crookDistance) {\n            var _t90 = l(i.crookDistance, 1);\n            m = u ? n + d + (p + c - n - d) * (1 - _t90) : c + (n - d) * _t90;\n          } else m = n + (a - f) * Math.tan((this.angle || 0) - Math.PI / 2);\n          var x = [[\"M\", g, f]];\n          return (u ? m <= g && m >= s.x : m >= g && m <= s.x) && x.push([\"L\", m, f]), x.push([\"L\", s.x, s.y], [\"L\", r.x, r.y]), x;\n        }\n      }\n    }), d;\n  }), i(e, \"Series/Pie/PieSeriesDefaults.js\", [], function () {\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        connectorPadding: 5,\n        connectorShape: \"crookedLine\",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  }), i(e, \"Series/Pie/PieSeries.js\", [e[\"Series/CenteredUtilities.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Globals.js\"], e[\"Series/Pie/PiePoint.js\"], e[\"Series/Pie/PieSeriesDefaults.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Renderer/SVG/Symbols.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r, o, n, a, h) {\n    var l = t.getStartAndEndRadians,\n      d = i.noop,\n      c = h.clamp,\n      p = h.extend,\n      u = h.fireEvent,\n      g = h.merge,\n      f = h.pick;\n    var m = /*#__PURE__*/function (_o28) {\n      function m() {\n        _classCallCheck(this, m);\n        return _callSuper(this, m, arguments);\n      }\n      _inherits(m, _o28);\n      return _createClass(m, [{\n        key: \"animate\",\n        value: function animate(t) {\n          var e = this,\n            i = e.points,\n            s = e.startAngleRad;\n          t || i.forEach(function (t) {\n            var i = t.graphic,\n              r = t.shapeArgs;\n            i && r && (i.attr({\n              r: f(t.startR, e.center && e.center[3] / 2),\n              start: s,\n              end: s\n            }), i.animate({\n              r: r.r,\n              start: r.start,\n              end: r.end\n            }, e.options.animation));\n          });\n        }\n      }, {\n        key: \"drawEmpty\",\n        value: function drawEmpty() {\n          var t, e;\n          var i = this.startAngleRad,\n            s = this.endAngleRad,\n            r = this.options;\n          0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n            d: a.arc(t, e, this.center[2] / 2, 0, {\n              start: i,\n              end: s,\n              innerR: this.center[3] / 2\n            })\n          }), this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": r.borderWidth,\n            fill: r.fillColor || \"none\",\n            stroke: r.color || \"#cccccc\"\n          })) : this.graph && (this.graph = this.graph.destroy());\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var t = this.chart.renderer;\n          this.points.forEach(function (e) {\n            e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n          });\n        }\n      }, {\n        key: \"generatePoints\",\n        value: function generatePoints() {\n          _superPropGet(m, \"generatePoints\", this, 3)([]), this.updateTotals();\n        }\n      }, {\n        key: \"getX\",\n        value: function getX(t, e, i, s) {\n          var r = this.center,\n            o = this.radii ? this.radii[i.index] || 0 : r[2] / 2,\n            n = s.dataLabelPosition,\n            a = (n === null || n === void 0 ? void 0 : n.distance) || 0,\n            h = Math.asin(c((t - r[1]) / (o + a), -1, 1));\n          return r[0] + Math.cos(h) * (o + a) * (e ? -1 : 1) + (a > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return !!this.processedXData.length;\n        }\n      }, {\n        key: \"redrawPoints\",\n        value: function redrawPoints() {\n          var t, e, i, s;\n          var r = this,\n            o = r.chart;\n          this.drawEmpty(), r.group && !o.styledMode && r.group.shadow(r.options.shadow), r.points.forEach(function (n) {\n            var a = {};\n            e = n.graphic, !n.isNull && e ? (s = n.shapeArgs, t = n.getTranslate(), o.styledMode || (i = r.pointAttribs(n, n.selected && \"select\")), n.delayedRendering ? (e.setRadialReference(r.center).attr(s).attr(t), o.styledMode || e.attr(i).attr({\n              \"stroke-linejoin\": \"round\"\n            }), n.delayedRendering = !1) : (e.setRadialReference(r.center), o.styledMode || g(!0, a, i), g(!0, a, s, t), e.animate(a)), e.attr({\n              visibility: n.visible ? \"inherit\" : \"hidden\"\n            }), e.addClass(n.getClassName(), !0)) : e && (n.graphic = e.destroy());\n          });\n        }\n      }, {\n        key: \"sortByAngle\",\n        value: function sortByAngle(t, e) {\n          t.sort(function (t, i) {\n            return void 0 !== t.angle && (i.angle - t.angle) * e;\n          });\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(t) {\n          u(this, \"translate\"), this.generatePoints();\n          var e = this.options,\n            i = e.slicedOffset,\n            s = l(e.startAngle, e.endAngle),\n            r = this.startAngleRad = s.start,\n            o = (this.endAngleRad = s.end) - r,\n            n = this.points,\n            a = e.ignoreHiddenPoint,\n            h = n.length,\n            d,\n            c,\n            p,\n            g,\n            f,\n            _m5,\n            x,\n            y = 0;\n          for (t || (this.center = t = this.getCenter()), _m5 = 0; _m5 < h; _m5++) {\n            x = n[_m5], d = r + y * o, x.isValid() && (!a || x.visible) && (y += x.percentage / 100), c = r + y * o;\n            var _e60 = {\n              x: t[0],\n              y: t[1],\n              r: t[2] / 2,\n              innerR: t[3] / 2,\n              start: Math.round(1e3 * d) / 1e3,\n              end: Math.round(1e3 * c) / 1e3\n            };\n            x.shapeType = \"arc\", x.shapeArgs = _e60, (p = (c + d) / 2) > 1.5 * Math.PI ? p -= 2 * Math.PI : p < -Math.PI / 2 && (p += 2 * Math.PI), x.slicedTranslation = {\n              translateX: Math.round(Math.cos(p) * i),\n              translateY: Math.round(Math.sin(p) * i)\n            }, g = Math.cos(p) * t[2] / 2, f = Math.sin(p) * t[2] / 2, x.tooltipPos = [t[0] + .7 * g, t[1] + .7 * f], x.half = p < -Math.PI / 2 || p > Math.PI / 2 ? 1 : 0, x.angle = p;\n          }\n          u(this, \"afterTranslate\");\n        }\n      }, {\n        key: \"updateTotals\",\n        value: function updateTotals() {\n          var t = this.points,\n            e = t.length,\n            i = this.options.ignoreHiddenPoint,\n            s,\n            r,\n            o = 0;\n          for (s = 0; s < e; s++) (r = t[s]).isValid() && (!i || r.visible) && (o += r.y);\n          for (s = 0, this.total = o; s < e; s++) (r = t[s]).percentage = o > 0 && (r.visible || !i) ? r.y / o * 100 : 0, r.total = o;\n        }\n      }]);\n    }(o);\n    return m.defaultOptions = g(o.defaultOptions, r), p(m.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: e.prototype.drawTracker,\n      getCenter: t.getCenter,\n      getSymbol: d,\n      invertible: !1,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: e.prototype.pointAttribs,\n      pointClass: s,\n      requireSorting: !1,\n      searchPoint: d,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    }), n.registerSeriesType(\"pie\", m), m;\n  }), i(e, \"Series/Pie/PieDataLabel.js\", [e[\"Core/Series/DataLabel.js\"], e[\"Core/Globals.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, r) {\n    var o;\n    var n = e.composed,\n      a = e.noop,\n      h = i.distribute,\n      l = s.series,\n      d = r.arrayMax,\n      c = r.clamp,\n      p = r.defined,\n      u = r.pick,\n      g = r.pushUnique,\n      f = r.relativeLength;\n    return function (e) {\n      var i = {\n        radialDistributionY: function radialDistributionY(t, e) {\n          var _e$dataLabelPosition;\n          return (((_e$dataLabelPosition = e.dataLabelPosition) === null || _e$dataLabelPosition === void 0 ? void 0 : _e$dataLabelPosition.top) || 0) + t.distributeBox.pos;\n        },\n        radialDistributionX: function radialDistributionX(t, e, i, s, r) {\n          var o = r.dataLabelPosition;\n          return t.getX(i < ((o === null || o === void 0 ? void 0 : o.top) || 0) + 2 || i > ((o === null || o === void 0 ? void 0 : o.bottom) || 0) - 2 ? s : i, e.half, e, r);\n        },\n        justify: function justify(t, e, i, s) {\n          var _e$dataLabelPosition2;\n          return s[0] + (t.half ? -1 : 1) * (i + (((_e$dataLabelPosition2 = e.dataLabelPosition) === null || _e$dataLabelPosition2 === void 0 ? void 0 : _e$dataLabelPosition2.distance) || 0));\n        },\n        alignToPlotEdges: function alignToPlotEdges(t, e, i, s) {\n          var r = t.getBBox().width;\n          return e ? r + s : i - r - s;\n        },\n        alignToConnectors: function alignToConnectors(t, e, i, s) {\n          var r = 0,\n            o;\n          return t.forEach(function (t) {\n            (o = t.dataLabel.getBBox().width) > r && (r = o);\n          }), e ? r + s : i - r - s;\n        }\n      };\n      function s(t, e) {\n        var i = this.center,\n          s = this.options,\n          r = i[2] / 2,\n          o = t.angle || 0,\n          n = Math.cos(o),\n          a = Math.sin(o),\n          h = i[0] + n * r,\n          l = i[1] + a * r,\n          d = Math.min((s.slicedOffset || 0) + (s.borderWidth || 0), e / 5);\n        return {\n          natural: {\n            x: h + n * e,\n            y: l + a * e\n          },\n          computed: {},\n          alignment: e < 0 ? \"center\" : t.half ? \"right\" : \"left\",\n          connectorPosition: {\n            breakAt: {\n              x: h + n * d,\n              y: l + a * d\n            },\n            touchingSliceAt: {\n              x: h,\n              y: l\n            }\n          },\n          distance: e\n        };\n      }\n      function r() {\n        var _t$hasDataLabels,\n          _this26 = this;\n        var t = this,\n          e = t.points,\n          i = t.chart,\n          s = i.plotWidth,\n          r = i.plotHeight,\n          o = i.plotLeft,\n          n = Math.round(i.chartWidth / 3),\n          a = t.center,\n          c = a[2] / 2,\n          g = a[1],\n          m = [[], []],\n          x = [0, 0, 0, 0],\n          y = t.dataLabelPositioners,\n          b,\n          v,\n          S,\n          C = 0;\n        t.visible && ((_t$hasDataLabels = t.hasDataLabels) === null || _t$hasDataLabels === void 0 ? void 0 : _t$hasDataLabels.call(t)) && (e.forEach(function (t) {\n          (t.dataLabels || []).forEach(function (t) {\n            t.shortened && (t.attr({\n              width: \"auto\"\n            }).css({\n              width: \"auto\",\n              textOverflow: \"clip\"\n            }), t.shortened = !1);\n          });\n        }), l.prototype.drawDataLabels.apply(t), e.forEach(function (t) {\n          (t.dataLabels || []).forEach(function (e, i) {\n            var _r$style;\n            var s = a[2] / 2,\n              r = e.options,\n              o = f((r === null || r === void 0 ? void 0 : r.distance) || 0, s);\n            0 === i && m[t.half].push(t), !p(r === null || r === void 0 || (_r$style = r.style) === null || _r$style === void 0 ? void 0 : _r$style.width) && e.getBBox().width > n && (e.css({\n              width: Math.round(.7 * n) + \"px\"\n            }), e.shortened = !0), e.dataLabelPosition = _this26.getDataLabelPosition(t, o), C = Math.max(C, o);\n          });\n        }), m.forEach(function (e, n) {\n          var l = e.length,\n            d = [],\n            f,\n            m,\n            b = 0,\n            k;\n          l && (t.sortByAngle(e, n - .5), C > 0 && (f = Math.max(0, g - c - C), m = Math.min(g + c + C, i.plotHeight), e.forEach(function (t) {\n            (t.dataLabels || []).forEach(function (e) {\n              var _e$dataLabelPosition3;\n              var s = e.dataLabelPosition;\n              s && s.distance > 0 && (s.top = Math.max(0, g - c - s.distance), s.bottom = Math.min(g + c + s.distance, i.plotHeight), b = e.getBBox().height || 21, e.lineHeight = i.renderer.fontMetrics(e.text || e).h + 2 * e.padding, t.distributeBox = {\n                target: (((_e$dataLabelPosition3 = e.dataLabelPosition) === null || _e$dataLabelPosition3 === void 0 ? void 0 : _e$dataLabelPosition3.natural.y) || 0) - s.top + e.lineHeight / 2,\n                size: b,\n                rank: t.y\n              }, d.push(t.distributeBox));\n            });\n          }), h(d, k = m + b - f, k / 5)), e.forEach(function (i) {\n            (i.dataLabels || []).forEach(function (h) {\n              var l = h.options || {},\n                g = i.distributeBox,\n                f = h.dataLabelPosition,\n                m = (f === null || f === void 0 ? void 0 : f.natural.y) || 0,\n                b = l.connectorPadding || 0,\n                C = h.lineHeight || 21,\n                k = (C - h.getBBox().height) / 2,\n                M = 0,\n                w = m,\n                A = \"inherit\";\n              if (f) {\n                if (d && p(g) && f.distance > 0 && (void 0 === g.pos ? A = \"hidden\" : (S = g.size, w = y.radialDistributionY(i, h))), l.justify) M = y.justify(i, h, c, a);else switch (l.alignTo) {\n                  case \"connectors\":\n                    M = y.alignToConnectors(e, n, s, o);\n                    break;\n                  case \"plotEdges\":\n                    M = y.alignToPlotEdges(h, n, s, o);\n                    break;\n                  default:\n                    M = y.radialDistributionX(t, i, w - k, m, h);\n                }\n                if (f.attribs = {\n                  visibility: A,\n                  align: f.alignment\n                }, f.posAttribs = {\n                  x: M + (l.x || 0) + ({\n                    left: b,\n                    right: -b\n                  }[f.alignment] || 0),\n                  y: w + (l.y || 0) - C / 2\n                }, f.computed.x = M, f.computed.y = w - k, u(l.crop, !0)) {\n                  var _t91;\n                  M - (v = h.getBBox().width) < b && 1 === n ? (_t91 = Math.round(v - M + b), x[3] = Math.max(_t91, x[3])) : M + v > s - b && 0 === n && (_t91 = Math.round(M + v - s + b), x[1] = Math.max(_t91, x[1])), w - S / 2 < 0 ? x[0] = Math.max(Math.round(-w + S / 2), x[0]) : w + S / 2 > r && (x[2] = Math.max(Math.round(w + S / 2 - r), x[2])), f.sideOverflow = _t91;\n                }\n              }\n            });\n          }));\n        }), (0 === d(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach(function (e) {\n          (e.dataLabels || []).forEach(function (s) {\n            var _ref17 = s.options || {},\n              r = _ref17.connectorColor,\n              _ref17$connectorWidth = _ref17.connectorWidth,\n              o = _ref17$connectorWidth === void 0 ? 1 : _ref17$connectorWidth,\n              n = s.dataLabelPosition;\n            if (o) {\n              var _n$attribs;\n              var _a18;\n              b = s.connector, n && n.distance > 0 ? (_a18 = !b, b || (s.connector = b = i.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + e.colorIndex + (e.className ? \" \" + e.className : \"\")).add(t.dataLabelsGroup)), i.styledMode || b.attr({\n                \"stroke-width\": o,\n                stroke: r || e.color || \"#666666\"\n              }), b[_a18 ? \"attr\" : \"animate\"]({\n                d: e.getConnectorPath(s)\n              }), b.attr({\n                visibility: (_n$attribs = n.attribs) === null || _n$attribs === void 0 ? void 0 : _n$attribs.visibility\n              })) : b && (s.connector = b.destroy());\n            }\n          });\n        })));\n      }\n      function o() {\n        this.points.forEach(function (t) {\n          (t.dataLabels || []).forEach(function (t) {\n            var _t$options4;\n            var e = t.dataLabelPosition;\n            e ? (e.sideOverflow && (t.css({\n              width: Math.max(t.getBBox().width - e.sideOverflow, 0) + \"px\",\n              textOverflow: (((_t$options4 = t.options) === null || _t$options4 === void 0 ? void 0 : _t$options4.style) || {}).textOverflow || \"ellipsis\"\n            }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? \"animate\" : \"attr\"](e.posAttribs), t.moved = !0) : t && t.attr({\n              y: -9999\n            });\n          }), delete t.distributeBox;\n        }, this);\n      }\n      function m(t) {\n        var e = this.center,\n          i = this.options,\n          s = i.center,\n          r = i.minSize || 80,\n          o = r,\n          n = null !== i.size;\n        return !n && (null !== s[0] ? o = Math.max(e[2] - Math.max(t[1], t[3]), r) : (o = Math.max(e[2] - t[1] - t[3], r), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? o = c(o, r, e[2] - Math.max(t[0], t[2])) : (o = c(o, r, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), o < e[2] ? (e[2] = o, e[3] = Math.min(i.thickness ? Math.max(0, o - 2 * i.thickness) : Math.max(0, f(i.innerSize || 0, o)), o), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : n = !0), n;\n      }\n      e.compose = function (e) {\n        if (t.compose(l), g(n, \"PieDataLabel\")) {\n          var _t92 = e.prototype;\n          _t92.dataLabelPositioners = i, _t92.alignDataLabel = a, _t92.drawDataLabels = r, _t92.getDataLabelPosition = s, _t92.placeDataLabels = o, _t92.verifyDataLabelOverflow = m;\n        }\n      };\n    }(o || (o = {})), o;\n  }), i(e, \"Core/Geometry/GeometryUtilities.js\", [], function () {\n    var t, e;\n    return (e = t || (t = {})).getCenterOfPoints = function (t) {\n      var e = t.reduce(function (t, e) {\n        return t.x += e.x, t.y += e.y, t;\n      }, {\n        x: 0,\n        y: 0\n      });\n      return {\n        x: e.x / t.length,\n        y: e.y / t.length\n      };\n    }, e.getDistanceBetweenPoints = function (t, e) {\n      return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n    }, e.getAngleBetweenPoints = function (t, e) {\n      return Math.atan2(e.x - t.x, e.y - t.y);\n    }, e.pointInPolygon = function (_ref18, i) {\n      var t = _ref18.x,\n        e = _ref18.y;\n      var s = i.length,\n        r,\n        o,\n        n = !1;\n      for (r = 0, o = s - 1; r < s; o = r++) {\n        var _i$r = _slicedToArray(i[r], 2),\n          _s43 = _i$r[0],\n          a = _i$r[1],\n          _i$o = _slicedToArray(i[o], 2),\n          h = _i$o[0],\n          l = _i$o[1];\n        a > e != l > e && t < (h - _s43) * (e - a) / (l - a) + _s43 && (n = !n);\n      }\n      return n;\n    }, t;\n  }), i(e, \"Extensions/OverlappingDataLabels.js\", [e[\"Core/Geometry/GeometryUtilities.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    var i = t.pointInPolygon,\n      s = e.addEvent,\n      r = e.fireEvent,\n      o = e.objectEach,\n      n = e.pick;\n    function a(t) {\n      var e = t.length,\n        s = function s(t, e) {\n          return !(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y);\n        },\n        o = function o(t, e) {\n          var _iterator18 = _createForOfIteratorHelper(t),\n            _step18;\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var _s44 = _step18.value;\n              if (i({\n                x: _s44[0],\n                y: _s44[1]\n              }, e)) return !0;\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n          return !1;\n        },\n        n,\n        a,\n        l,\n        d,\n        c,\n        p = !1;\n      for (var _i49 = 0; _i49 < e; _i49++) (n = t[_i49]) && (n.oldOpacity = n.opacity, n.newOpacity = 1, n.absoluteBox = function (t) {\n        if (t && (!t.alignAttr || t.placed)) {\n          var _t$parentGroup2, _t$parentGroup3;\n          var _e61 = t.box ? 0 : t.padding || 0,\n            _i50 = t.alignAttr || {\n              x: t.attr(\"x\"),\n              y: t.attr(\"y\")\n            },\n            _s45 = t.getBBox();\n          return t.width = _s45.width, t.height = _s45.height, {\n            x: _i50.x + (((_t$parentGroup2 = t.parentGroup) === null || _t$parentGroup2 === void 0 ? void 0 : _t$parentGroup2.translateX) || 0) + _e61,\n            y: _i50.y + (((_t$parentGroup3 = t.parentGroup) === null || _t$parentGroup3 === void 0 ? void 0 : _t$parentGroup3.translateY) || 0) + _e61,\n            width: (t.width || 0) - 2 * _e61,\n            height: (t.height || 0) - 2 * _e61,\n            polygon: _s45 === null || _s45 === void 0 ? void 0 : _s45.polygon\n          };\n        }\n      }(n));\n      t.sort(function (t, e) {\n        return (e.labelrank || 0) - (t.labelrank || 0);\n      });\n      for (var _i51 = 0; _i51 < e; ++_i51) {\n        var _d9;\n        d = (a = t[_i51]) && a.absoluteBox;\n        var _r25 = (_d9 = d) === null || _d9 === void 0 ? void 0 : _d9.polygon;\n        for (var _n17 = _i51 + 1; _n17 < e; ++_n17) {\n          c = (l = t[_n17]) && l.absoluteBox;\n          var _e62 = !1;\n          if (d && c && a !== l && 0 !== a.newOpacity && 0 !== l.newOpacity && \"hidden\" !== a.visibility && \"hidden\" !== l.visibility) {\n            var _t93 = c.polygon;\n            if (_r25 && _t93 && _r25 !== _t93 ? o(_r25, _t93) && (_e62 = !0) : s(d, c) && (_e62 = !0), _e62) {\n              var _t94 = a.labelrank < l.labelrank ? a : l,\n                _e63 = _t94.text;\n              _t94.newOpacity = 0, (_e63 === null || _e63 === void 0 ? void 0 : _e63.element.querySelector(\"textPath\")) && _e63.hide();\n            }\n          }\n        }\n      }\n      var _iterator19 = _createForOfIteratorHelper(t),\n        _step19;\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var _e64 = _step19.value;\n          h(_e64, this) && (p = !0);\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n      p && r(this, \"afterHideAllOverlappingLabels\");\n    }\n    function h(t, e) {\n      var i,\n        s,\n        o = !1;\n      return t && (s = t.newOpacity, t.oldOpacity !== s && (t.hasClass(\"highcharts-data-label\") ? (t[s ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), i = function i() {\n        e.styledMode || t.css({\n          pointerEvents: s ? \"auto\" : \"none\"\n        });\n      }, o = !0, t[t.isOld ? \"animate\" : \"attr\"]({\n        opacity: s\n      }, void 0, i), r(e, \"afterHideOverlappingLabel\")) : t.attr({\n        opacity: s\n      })), t.isOld = !0), o;\n    }\n    function l() {\n      var t = this,\n        e = [];\n      var _iterator20 = _createForOfIteratorHelper(t.labelCollectors || []),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var _i52 = _step20.value;\n          e = e.concat(_i52());\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      var _iterator21 = _createForOfIteratorHelper(t.yAxis || []),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var _i53 = _step21.value;\n          _i53.stacking && _i53.options.stackLabels && !_i53.options.stackLabels.allowOverlap && o(_i53.stacking.stacks, function (t) {\n            o(t, function (t) {\n              t.label && e.push(t.label);\n            });\n          });\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      var _iterator22 = _createForOfIteratorHelper(t.series || []),\n        _step22;\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var _i54$hasDataLabels;\n          var _i54 = _step22.value;\n          if (_i54.visible && (_i54$hasDataLabels = _i54.hasDataLabels) !== null && _i54$hasDataLabels !== void 0 && _i54$hasDataLabels.call(_i54)) {\n            var _s46 = function _s46(i) {\n              var _iterator23 = _createForOfIteratorHelper(i),\n                _step23;\n              try {\n                var _loop = function _loop() {\n                  var s = _step23.value;\n                  s.visible && (s.dataLabels || []).forEach(function (i) {\n                    var _s$shapeArgs, _r$allowOverlap;\n                    var r = i.options || {};\n                    i.labelrank = n(r.labelrank, s.labelrank, (_s$shapeArgs = s.shapeArgs) === null || _s$shapeArgs === void 0 ? void 0 : _s$shapeArgs.height), ((_r$allowOverlap = r.allowOverlap) !== null && _r$allowOverlap !== void 0 ? _r$allowOverlap : Number(r.distance) > 0) ? (i.oldOpacity = i.opacity, i.newOpacity = 1, h(i, t)) : e.push(i);\n                  });\n                };\n                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                  _loop();\n                }\n              } catch (err) {\n                _iterator23.e(err);\n              } finally {\n                _iterator23.f();\n              }\n            };\n            _s46(_i54.nodes || []), _s46(_i54.points);\n          }\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n      this.hideOverlappingLabels(e);\n    }\n    return {\n      compose: function compose(t) {\n        var e = t.prototype;\n        e.hideOverlappingLabels || (e.hideOverlappingLabels = a, s(t, \"render\", l));\n      }\n    };\n  }), i(e, \"Extensions/BorderRadius.js\", [e[\"Core/Defaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    var s = t.defaultOptions,\n      r = e.noop,\n      o = i.addEvent,\n      n = i.extend,\n      a = i.isObject,\n      h = i.merge,\n      l = i.relativeLength,\n      d = {\n        radius: 0,\n        scope: \"stack\",\n        where: void 0\n      },\n      c = r,\n      p = r;\n    function u(t, e, i, s) {\n      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var o = c(t, e, i, s, r),\n        _r$innerR = r.innerR,\n        n = _r$innerR === void 0 ? 0 : _r$innerR,\n        _r$r = r.r,\n        a = _r$r === void 0 ? i : _r$r,\n        _r$start = r.start,\n        h = _r$start === void 0 ? 0 : _r$start,\n        _r$end = r.end,\n        d = _r$end === void 0 ? 0 : _r$end;\n      if (r.open || !r.borderRadius) return o;\n      var p = d - h,\n        g = Math.sin(p / 2),\n        f = Math.max(Math.min(l(r.borderRadius || 0, a - n), (a - n) / 2, a * g / (1 + g)), 0),\n        m = Math.min(f, p / Math.PI * 2 * n),\n        x = o.length - 1;\n      for (; x--;) !function (t, e, i) {\n        var s, r, o;\n        var n = t[e],\n          a = t[e + 1];\n        if (\"Z\" === a[0] && (a = t[0]), (\"M\" === n[0] || \"L\" === n[0]) && \"A\" === a[0] ? (s = n, r = a, o = !0) : \"A\" === n[0] && (\"M\" === a[0] || \"L\" === a[0]) && (s = a, r = n), s && r && r.params) {\n          var _n18 = r[1],\n            _a19 = r[5],\n            _h14 = r.params,\n            _l7 = _h14.start,\n            _d10 = _h14.end,\n            _c8 = _h14.cx,\n            _p11 = _h14.cy,\n            _u5 = _a19 ? _n18 - i : _n18 + i,\n            _g6 = _u5 ? Math.asin(i / _u5) : 0,\n            _f3 = _a19 ? _g6 : -_g6,\n            _m6 = Math.cos(_g6) * _u5;\n          o ? (_h14.start = _l7 + _f3, s[1] = _c8 + _m6 * Math.cos(_l7), s[2] = _p11 + _m6 * Math.sin(_l7), t.splice(e + 1, 0, [\"A\", i, i, 0, 0, 1, _c8 + _n18 * Math.cos(_h14.start), _p11 + _n18 * Math.sin(_h14.start)])) : (_h14.end = _d10 - _f3, r[6] = _c8 + _n18 * Math.cos(_h14.end), r[7] = _p11 + _n18 * Math.sin(_h14.end), t.splice(e + 1, 0, [\"A\", i, i, 0, 0, 1, _c8 + _m6 * Math.cos(_d10), _p11 + _m6 * Math.sin(_d10)])), r[4] = Math.abs(_h14.end - _h14.start) < Math.PI ? 0 : 1;\n        }\n      }(o, x, x > 1 ? m : f);\n      return o;\n    }\n    function g() {\n      if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {\n        var _s$plotOptions;\n        var _t95 = this.options,\n          _e65 = this.yAxis,\n          _i55 = \"percent\" === _t95.stacking,\n          _r26 = (_s$plotOptions = s.plotOptions) === null || _s$plotOptions === void 0 || (_s$plotOptions = _s$plotOptions[this.type]) === null || _s$plotOptions === void 0 ? void 0 : _s$plotOptions.borderRadius,\n          _o29 = f(_t95.borderRadius, a(_r26) ? _r26 : {}),\n          _h15 = _e65.options.reversed;\n        var _iterator24 = _createForOfIteratorHelper(this.points),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var _s47 = _step24.value;\n            var _r27 = _s47.shapeArgs;\n            if (\"roundedRect\" === _s47.shapeType && _r27) {\n              var _r27$width = _r27.width,\n                _a20 = _r27$width === void 0 ? 0 : _r27$width,\n                _r27$height = _r27.height,\n                _d11 = _r27$height === void 0 ? 0 : _r27$height,\n                _r27$y = _r27.y,\n                _c9 = _r27$y === void 0 ? 0 : _r27$y,\n                _p12 = _c9,\n                _u6 = _d11;\n              if (\"stack\" === _o29.scope && _s47.stackTotal) {\n                var _r28 = _e65.translate(_i55 ? 100 : _s47.stackTotal, !1, !0, !1, !0),\n                  _o30 = _e65.translate(_t95.threshold || 0, !1, !0, !1, !0),\n                  _n19 = this.crispCol(0, Math.min(_r28, _o30), 0, Math.abs(_r28 - _o30));\n                _p12 = _n19.y, _u6 = _n19.height;\n              }\n              var _g7 = (_s47.negative ? -1 : 1) * (_h15 ? -1 : 1) == -1,\n                _f4 = _o29.where;\n              !_f4 && this.is(\"waterfall\") && Math.abs((_s47.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (_f4 = \"all\"), _f4 || (_f4 = \"end\");\n              var _m7 = Math.min(l(_o29.radius, _a20), _a20 / 2, \"all\" === _f4 ? _d11 / 2 : 1 / 0) || 0;\n              \"end\" === _f4 && (_g7 && (_p12 -= _m7), _u6 += _m7), n(_r27, {\n                brBoxHeight: _u6,\n                brBoxY: _p12,\n                r: _m7\n              });\n            }\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      }\n    }\n    function f(t, e) {\n      return a(t) || (t = {\n        radius: t || 0\n      }), h(d, e, t);\n    }\n    function m() {\n      var t = f(this.options.borderRadius);\n      var _iterator25 = _createForOfIteratorHelper(this.points),\n        _step25;\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var _e66 = _step25.value;\n          var _i56 = _e66.shapeArgs;\n          _i56 && (_i56.borderRadius = l(t.radius, (_i56.r || 0) - (_i56.innerR || 0)));\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n    }\n    function x(t, e, i, s) {\n      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var o = p(t, e, i, s, r),\n        _r$r2 = r.r,\n        n = _r$r2 === void 0 ? 0 : _r$r2,\n        _r$brBoxHeight = r.brBoxHeight,\n        a = _r$brBoxHeight === void 0 ? s : _r$brBoxHeight,\n        _r$brBoxY = r.brBoxY,\n        h = _r$brBoxY === void 0 ? e : _r$brBoxY,\n        l = e - h,\n        d = h + a - (e + s),\n        c = l - n > -.1 ? 0 : n,\n        u = d - n > -.1 ? 0 : n,\n        g = Math.max(c && l, 0),\n        f = Math.max(u && d, 0),\n        m = [t + c, e],\n        y = [t + i - c, e],\n        b = [t + i, e + c],\n        v = [t + i, e + s - u],\n        S = [t + i - u, e + s],\n        C = [t + u, e + s],\n        k = [t, e + s - u],\n        M = [t, e + c],\n        w = function w(t, e) {\n          return Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));\n        };\n      if (g) {\n        var _t96 = w(c, c - g);\n        m[0] -= _t96, y[0] += _t96, b[1] = M[1] = e + c - g;\n      }\n      if (s < c - g) {\n        var _r29 = w(c, c - g - s);\n        b[0] = v[0] = t + i - c + _r29, S[0] = Math.min(b[0], S[0]), C[0] = Math.max(v[0], C[0]), k[0] = M[0] = t + c - _r29, b[1] = M[1] = e + s;\n      }\n      if (f) {\n        var _t97 = w(u, u - f);\n        S[0] += _t97, C[0] -= _t97, v[1] = k[1] = e + s - u + f;\n      }\n      if (s < u - f) {\n        var _r30 = w(u, u - f - s);\n        b[0] = v[0] = t + i - u + _r30, y[0] = Math.min(b[0], y[0]), m[0] = Math.max(v[0], m[0]), k[0] = M[0] = t + u - _r30, v[1] = k[1] = e;\n      }\n      return o.length = 0, o.push([\"M\"].concat(m), [\"L\"].concat(y), [\"A\", c, c, 0, 0, 1].concat(b), [\"L\"].concat(v), [\"A\", u, u, 0, 0, 1].concat(S), [\"L\"].concat(C), [\"A\", u, u, 0, 0, 1].concat(k), [\"L\"].concat(M), [\"A\", c, c, 0, 0, 1].concat(m), [\"Z\"]), o;\n    }\n    return {\n      compose: function compose(t, e, i) {\n        var s = t.types.pie;\n        if (!e.symbolCustomAttribs.includes(\"borderRadius\")) {\n          var _r31 = i.prototype.symbols;\n          o(t, \"afterColumnTranslate\", g, {\n            order: 9\n          }), o(s, \"afterTranslate\", m), e.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\"), c = _r31.arc, p = _r31.roundedRect, _r31.arc = u, _r31.roundedRect = x;\n        }\n      },\n      optionsToObject: f\n    };\n  }), i(e, \"Core/Responsive.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    var e;\n    var i = t.diffObjects,\n      s = t.extend,\n      r = t.find,\n      o = t.merge,\n      n = t.pick,\n      a = t.uniqueKey;\n    return function (t) {\n      function e(t, e) {\n        var i = t.condition;\n        (i.callback || function () {\n          return this.chartWidth <= n(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= n(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= n(i.minWidth, 0) && this.chartHeight >= n(i.minHeight, 0);\n        }).call(this) && e.push(t._id);\n      }\n      function h(t, e) {\n        var _this27 = this;\n        var s = this.options.responsive,\n          n = this.currentResponsive,\n          h = [],\n          l;\n        !e && s && s.rules && s.rules.forEach(function (t) {\n          void 0 === t._id && (t._id = a()), _this27.matchResponsiveRule(t, h);\n        }, this);\n        var d = o.apply(void 0, _toConsumableArray(h.map(function (t) {\n          return r((s || {}).rules || [], function (e) {\n            return e._id === t;\n          });\n        }).map(function (t) {\n          return t && t.chartOptions;\n        })));\n        d.isResponsiveOptions = !0, h = h.toString() || void 0;\n        var c = n && n.ruleIds;\n        h === c || (n && (this.currentResponsive = void 0, this.updatingResponsive = !0, this.update(n.undoOptions, t, !0), this.updatingResponsive = !1), h ? ((l = i(d, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: h,\n          mergedOptions: d,\n          undoOptions: l\n        }, this.updatingResponsive || this.update(d, t, !0)) : this.currentResponsive = void 0);\n      }\n      t.compose = function (t) {\n        var i = t.prototype;\n        return i.matchResponsiveRule || s(i, {\n          matchResponsiveRule: e,\n          setResponsive: h\n        }), t;\n      };\n    }(e || (e = {})), e;\n  }), i(e, \"masters/highcharts.src.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"], e[\"Core/Defaults.js\"], e[\"Core/Animation/Fx.js\"], e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Renderer/HTML/AST.js\"], e[\"Core/Templating.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Renderer/RendererUtilities.js\"], e[\"Core/Renderer/SVG/SVGElement.js\"], e[\"Core/Renderer/SVG/SVGRenderer.js\"], e[\"Core/Renderer/HTML/HTMLElement.js\"], e[\"Core/Axis/Axis.js\"], e[\"Core/Axis/DateTimeAxis.js\"], e[\"Core/Axis/LogarithmicAxis.js\"], e[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], e[\"Core/Axis/Tick.js\"], e[\"Core/Tooltip.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Pointer.js\"], e[\"Core/Legend/Legend.js\"], e[\"Core/Legend/LegendSymbol.js\"], e[\"Core/Chart/Chart.js\"], e[\"Extensions/ScrollablePlotArea.js\"], e[\"Core/Axis/Stacking/StackingAxis.js\"], e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Series/Column/ColumnDataLabel.js\"], e[\"Series/Pie/PieDataLabel.js\"], e[\"Core/Series/DataLabel.js\"], e[\"Extensions/OverlappingDataLabels.js\"], e[\"Extensions/BorderRadius.js\"], e[\"Core/Responsive.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Time.js\"]], function (t, e, i, s, r, o, n, a, h, l, d, c, p, u, g, f, m, x, y, b, v, S, C, k, M, w, A, T, P, L, O, D, E, I, j, B) {\n    return t.AST = o, t.Axis = p, t.Chart = C, t.Color = j, t.DataLabel = O, t.Fx = s, t.HTMLElement = c, t.Legend = v, t.LegendSymbol = S, t.OverlappingDataLabels = t.OverlappingDataLabels || D, t.PlotLineOrBand = f, t.Point = y, t.Pointer = b, t.RendererRegistry = a, t.Series = A, t.SeriesRegistry = T, t.StackItem = w, t.SVGElement = l, t.SVGRenderer = d, t.Templating = n, t.Tick = m, t.Time = B, t.Tooltip = x, t.animate = r.animate, t.animObject = r.animObject, t.chart = C.chart, t.color = j.parse, t.dateFormat = n.dateFormat, t.defaultOptions = i.defaultOptions, t.distribute = h.distribute, t.format = n.format, t.getDeferredAnimation = r.getDeferredAnimation, t.getOptions = i.getOptions, t.numberFormat = n.numberFormat, t.seriesType = T.seriesType, t.setAnimation = r.setAnimation, t.setOptions = i.setOptions, t.stop = r.stop, t.time = i.defaultTime, t.timers = s.timers, E.compose(t.Series, t.SVGElement, t.SVGRenderer), P.compose(t.Series.types.column), O.compose(t.Series), u.compose(t.Axis), c.compose(t.SVGRenderer), v.compose(t.Chart), g.compose(t.Axis), D.compose(t.Chart), L.compose(t.Series.types.pie), f.compose(t.Axis), b.compose(t.Chart), I.compose(t.Chart), k.compose(t.Axis, t.Chart, t.Series), M.compose(t.Axis, t.Chart, t.Series), x.compose(t.Pointer), e.extend(t, e), t;\n  }), e[\"masters/highcharts.src.js\"]._modules = e, e[\"masters/highcharts.src.js\"];\n});\n\n//# sourceURL=webpack://medaxion-custom-visualizations/./node_modules/highcharts/highcharts.js?");

/***/ }),

/***/ "./src/common/utils.ts":
/*!*****************************!*\
  !*** ./src/common/utils.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMinMaxDatetimes = exports.processQueryResponse = exports.handleErrors = exports.formatType = void 0;\nconst formatType = (valueFormat, value) => {\n    if (value === 0)\n        return 0;\n    if (!value || !valueFormat) {\n        return 0;\n    }\n    ;\n    switch (valueFormat) {\n        case \"date_time\":\n        case \"date_date\":\n        case \"date_month\":\n        case \"date_quarter\":\n        case \"date_week\":\n        case \"date_year\":\n            return new Date(value).valueOf();\n        default:\n            return parseInt(value);\n    }\n};\nexports.formatType = formatType;\nconst handleErrors = (vis, res, options) => {\n    const check = (group, noun, count, min, max) => {\n        if (!vis.addError || !vis.clearErrors)\n            return false;\n        if (count < min) {\n            vis.addError({\n                title: `Not Enough ${noun}s`,\n                message: `This visualization requires ${min === max ? \"exactly\" : \"at least\"} ${min} ${noun.toLowerCase()}${min === 1 ? \"\" : \"s\"}.`,\n                group,\n            });\n            return false;\n        }\n        if (count > max) {\n            vis.addError({\n                title: `Too Many ${noun}s`,\n                message: `This visualization requires ${min === max ? \"exactly\" : \"no more than\"} ${max} ${noun.toLowerCase()}${min === 1 ? \"\" : \"s\"}.`,\n                group,\n            });\n            return false;\n        }\n        vis.clearErrors(group);\n        return true;\n    };\n    const { pivots, dimensions, measure_like: measures } = res.fields;\n    return (check(\"pivot-req\", \"Pivot\", pivots.length, options.min_pivots, options.max_pivots) &&\n        check(\"dim-req\", \"Dimension\", dimensions.length, options.min_dimensions, options.max_dimensions) &&\n        check(\"mes-req\", \"Measure\", measures.length, options.min_measures, options.max_measures));\n};\nexports.handleErrors = handleErrors;\n// const calculateExtremes = (extremes) => {\n//   const { dataMin, dataMax } = extremes;\n//   if (dataMin && dataMax && dataMin === dataMax) {\n//     // Single sensor value or sensors readings all same\n//     // Set reasonable min for range where values may be negative\n//     return { dataMin: 0 - Math.abs(dataMin), dataMax: dataMax };\n//   } else {\n//     return extremes;\n//   }\n// };\n/**\n * Returns tuple in the order [pivotKey[], dimensions[], measures[]]\n * @param queryResponse\n */\nconst processQueryResponse = (queryResponse) => {\n    var _a;\n    let pivots = (_a = queryResponse.pivots) === null || _a === void 0 ? void 0 : _a.map((pivot) => pivot.key);\n    let dimensions = queryResponse.fields.dimensions.map((dimension) => {\n        return {\n            name: dimension === null || dimension === void 0 ? void 0 : dimension.name,\n            type: dimension === null || dimension === void 0 ? void 0 : dimension.type,\n            title: dimension.label_short.trim().replace(/\\r?\\n/g, \"\"),\n        };\n    });\n    let measures = queryResponse.fields.measures.map((measure) => {\n        return {\n            name: measure.name,\n            type: measure.type,\n            title: measure.view_label.trim().replace(/\\r?\\n/g, \"\"),\n        };\n    });\n    return [pivots, dimensions, measures];\n};\nexports.processQueryResponse = processQueryResponse;\nconst getMinMaxDatetimes = (data, timeSeries) => {\n    let minTime = 0;\n    let maxTime = 0;\n    let maxIndex = 0;\n    data.map((datum, i) => {\n        var _a, _b, _c, _d;\n        let timePoint = (0, exports.formatType)((_a = timeSeries[0]) === null || _a === void 0 ? void 0 : _a.type, (_c = datum[(_b = timeSeries[0]) === null || _b === void 0 ? void 0 : _b.name]) === null || _c === void 0 ? void 0 : _c.value);\n        if (!maxTime || timePoint > maxTime) {\n            maxTime = timePoint;\n            maxIndex = i;\n            console.log(datum[(_d = timeSeries[0]) === null || _d === void 0 ? void 0 : _d.name]);\n        }\n        else if (!minTime || timePoint < minTime) {\n            minTime = timePoint;\n        }\n    });\n    return [minTime, maxTime, maxIndex];\n};\nexports.getMinMaxDatetimes = getMinMaxDatetimes;\n\n\n//# sourceURL=webpack://medaxion-custom-visualizations/./src/common/utils.ts?");

/***/ }),

/***/ "./src/visualizations/line-area-overlap.ts":
/*!*************************************************!*\
  !*** ./src/visualizations/line-area-overlap.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../common/utils */ \"./src/common/utils.ts\");\nconst Highcharts = __importStar(__webpack_require__(/*! highcharts */ \"./node_modules/highcharts/highcharts.js\"));\nconst highcharts_more_1 = __importDefault(__webpack_require__(/*! highcharts/highcharts-more */ \"./node_modules/highcharts/highcharts-more.js\"));\n(0, highcharts_more_1.default)(Highcharts);\nconst vis = {\n    id: \"gauge-chart\", // id/label not required, but nice for testing and keeping manifests in sync\n    label: \"gauge-chart\",\n    //  These are the Looker Viz Config menu options.\n    options: {\n        actualColor: {\n            type: \"array\",\n            label: \"Avg Actuals Color\",\n            display: \"color\",\n            section: \"Colors\",\n        },\n        coverageColor: {\n            type: \"array\",\n            label: \"Coverage Color\",\n            display: \"color\",\n            section: \"Colors\",\n        },\n        chartTitle: {\n            type: \"string\",\n            label: \"Chart Title\",\n            display: \"text\",\n            section: \"Style\",\n        },\n        actualMarkerType: {\n            type: \"string\",\n            label: \"Actual Point Type\",\n            display: \"select\",\n            values: [\n                { \"None\": \"none\" },\n                { \"Filled\": \"filled\" },\n                { \"Outline\": \"outline\" },\n            ],\n            section: \"Style\",\n        },\n        actualLineWidth: {\n            type: \"number\",\n            label: \"Actual Line Width\",\n            display: \"range\",\n            max: 10,\n            min: 1,\n            step: 1,\n            section: \"Style\",\n        },\n        coverageLineWidth: {\n            type: \"number\",\n            label: \"Coverage Line Width\",\n            display: \"range\",\n            max: 10,\n            min: 1,\n            step: 1,\n            section: \"Style\",\n        },\n        coverageMarkerType: {\n            type: \"string\",\n            label: \"Coverage Point Type\",\n            display: \"select\",\n            values: [\n                { \"None\": \"none\" },\n                { \"Filled\": \"filled\" },\n                { \"Outline\": \"outline\" },\n            ],\n            section: \"Style\",\n        },\n        legendAlign: {\n            type: \"string\",\n            label: \"Legend Horizontal Alignment\",\n            display: \"select\",\n            values: [\n                { \"Left\": \"left\" },\n                { \"Center\": \"center\" },\n                { \"Right\": \"right\" },\n            ],\n            section: \"Style\",\n        },\n        legendVerticalAlign: {\n            type: \"string\",\n            label: \"Legend Vertical Alignment\",\n            display: \"select\",\n            values: [\n                { \"Top\": \"top\" },\n                { \"Middle\": \"middle\" },\n                { \"Bottom\": \"bottom\" },\n            ],\n            section: \"Style\",\n        },\n        actualMarkerSymbol: {\n            type: \"string\",\n            label: \"Actual Marker Symbol\",\n            display: \"select\",\n            values: [\n                { \"Circle\": \"circle\" },\n                { \"Square\": \"square\" },\n                { \"Diamond\": \"diamond\" },\n                { \"Triangle\": \"triangle\" },\n                { \"Triangle Down\": \"triangle-down\" },\n            ],\n            section: \"Style\",\n        },\n        coverageMarkerSymbol: {\n            type: \"string\",\n            label: \"Coverage Marker Symbol\",\n            display: \"select\",\n            values: [\n                { \"Circle\": \"circle\" },\n                { \"Square\": \"square\" },\n                { \"Diamond\": \"diamond\" },\n                { \"Triangle\": \"triangle\" },\n                { \"Triangle Down\": \"triangle-down\" },\n            ],\n            section: \"Style\",\n        },\n    },\n    // Set up the initial state of the visualization\n    create(element, config) {\n        element.className = \"highcharts-custom-vis\";\n    },\n    // Render in response to the data or settings changing\n    update(data, element, config, queryResponse) {\n        var _a, _b;\n        // console.log(\"data\", data);\n        // console.log(\"element\", element);\n        // console.log(\"config\", config);\n        console.log(\"queryResponse\", queryResponse);\n        // Expect 1 time series dimension and 3 or more measures\n        const errors = (0, utils_1.handleErrors)(this, queryResponse, {\n            min_pivots: 0,\n            max_pivots: 0,\n            min_dimensions: 1,\n            max_dimensions: 1,\n            min_measures: 3,\n            max_measures: 100,\n        });\n        const { measure_like: measureLike, dimension_like: dimensionLike } = queryResponse.fields;\n        const measures1 = measureLike.map((measure) => {\n            var _a;\n            return ({\n                label: (_a = measure.label_short) !== null && _a !== void 0 ? _a : measure.label,\n                name: measure.name,\n            });\n        });\n        const updatedOptions = Object.assign({}, this.options);\n        measures1.forEach((measure, i) => {\n            updatedOptions[`${measure.name}_type`] = {\n                section: \"Metrics\",\n                type: \"string\",\n                label: `${measure.label} Type`,\n                display: \"select\",\n                order: 3 * i,\n                values: [\n                    { \"Coverage\": \"coverage\" },\n                    { \"Actual\": \"actual\" },\n                    { \"Range\": \"range\" },\n                ],\n            };\n        });\n        // if there are 2 or more measures with coverage or actual type, throw an error\n        let coverageCount = 0;\n        let actualCount = 0;\n        let rangeCount = 0;\n        let rangeMeasures = [];\n        measures1.forEach((measure) => {\n            const type = config[`${measure.name}_type`];\n            if (type === \"coverage\") {\n                coverageCount++;\n            }\n            else if (type === \"actual\") {\n                actualCount++;\n            }\n            else if (type === \"range\") {\n                rangeCount++;\n                rangeMeasures.push(measure.name);\n            }\n        });\n        if (coverageCount >= 2 || actualCount >= 2 || rangeCount <= 1) {\n            this.addError && this.addError({\n                title: `Incorrect Configuration`,\n                message: `This visualization requires only one measure of each type: coverage and actual. \n        There are ${coverageCount} coverage measures and ${actualCount} actual measures.\n        This visualization requires at least one range measure. There are ${rangeCount} range measures.`,\n                group: 'configError'\n            });\n        }\n        else {\n            this.clearErrors && this.clearErrors('configError');\n        }\n        // For each measure with the _type of range, add four configurations for the before and after outer and over-under colors\n        rangeMeasures.forEach((measure, i) => {\n            var _a, _b, _c, _d;\n            updatedOptions[`${measure}_range_color_1`] = {\n                section: \"Colors\",\n                type: \"array\",\n                label: `${(_a = measures1.find((m) => m.name === measure)) === null || _a === void 0 ? void 0 : _a.label} First Hour Range Color`,\n                display: \"color\",\n                order: 5 * i + 1,\n            };\n            updatedOptions[`${measure}_over_under_color_1`] = {\n                section: \"Colors\",\n                type: \"array\",\n                label: `${(_b = measures1.find((m) => m.name === measure)) === null || _b === void 0 ? void 0 : _b.label} First Hour Over/Under Color`,\n                display: \"color\",\n                order: 5 * i + 2,\n            };\n            updatedOptions[`${measure}_range_color_2`] = {\n                section: \"Colors\",\n                type: \"array\",\n                label: `${(_c = measures1.find((m) => m.name === measure)) === null || _c === void 0 ? void 0 : _c.label} Second Hour Range Color`,\n                display: \"color\",\n                order: 5 * i + 1,\n            };\n            updatedOptions[`${measure}_over_under_color_2`] = {\n                section: \"Colors\",\n                type: \"array\",\n                label: `${(_d = measures1.find((m) => m.name === measure)) === null || _d === void 0 ? void 0 : _d.label} Second Hour Over/Under Color`,\n                display: \"color\",\n                order: 5 * i + 2,\n            };\n        });\n        // const optionsArray: VisOption[] = Object.values(updatedOptions);\n        // @ts-ignore\n        this.trigger && this.trigger(\"registerOptions\", updatedOptions);\n        let timeSeries = dimensionLike.filter((field) => { var _a; return (_a = field.type) === null || _a === void 0 ? void 0 : _a.includes(\"date\"); });\n        if (timeSeries.length > 1) {\n            this.addError &&\n                this.addError({\n                    title: `Need a Single Date Dimension`,\n                    message: `This visualization requires only one date dimension. \n          There are ${timeSeries.length} date dimensions.`,\n                    group: 'dateError'\n                });\n        }\n        else {\n            this.clearErrors && this.clearErrors('dateError');\n        }\n        // Define the measure names for coverage and actual\n        const coverageMeasure = ((_a = measures1.find((measure) => config[`${measure.name}_type`] === \"coverage\")) === null || _a === void 0 ? void 0 : _a.name) || '';\n        const actualMeasure = ((_b = measures1.find((measure) => config[`${measure.name}_type`] === \"actual\")) === null || _b === void 0 ? void 0 : _b.name) || '';\n        const getHour = (datetimeString) => {\n            return Number(datetimeString.substring(11, 13));\n        };\n        // Create an array of range measures with color and value\n        // This comes from the first row of data\n        const rangeMeasuresData = measures1.filter((measure) => config[`${measure.name}_type`] === \"range\");\n        // Range data for the first highlighted hour\n        let rangeData = rangeMeasuresData.map((measure) => ({\n            name: measure.name + \" hr1\",\n            color: config[`${measure.name}_range_color_1`][0],\n            overUnderColor: config[`${measure.name}_over_under_color_1`][0],\n            value: data[0][measure.name].value,\n        }));\n        // Range data for the second highlighted hour\n        rangeData = rangeData.concat(rangeMeasuresData.map((measure) => ({\n            name: measure.name + \" hr2\",\n            color: config[`${measure.name}_range_color_2`][0],\n            overUnderColor: config[`${measure.name}_over_under_color_2`][0],\n            value: data[0][measure.name].value + 1,\n        })));\n        // Retrieve the marker type configurations\n        const actualMarkerType = config.actualMarkerType;\n        const coverageMarkerType = config.coverageMarkerType;\n        // Function to map marker type to Highcharts marker configuration\n        const getMarkerOptions = (markerType, color = \"#ffffff\", symbol = \"circle\") => {\n            switch (markerType) {\n                case 'none':\n                    return { enabled: false, fillColor: '#000000', lineWidth: 0 };\n                case 'filled':\n                    return { enabled: true, fillColor: color, lineWidth: 0, symbol: symbol };\n                case 'outline':\n                    return { enabled: true, fillColor: '#ffffff', lineWidth: 2, lineColor: color, symbol: symbol };\n                default:\n                    return { enabled: true, fillColor: color, lineWidth: 0, symbol: symbol };\n            }\n        };\n        // Retrieve the line width configurations\n        const actualLineWidth = config.actualLineWidth || 2; // Default to 2 if not set\n        const coverageLineWidth = config.coverageLineWidth || 2; // Default to 2 if not set\n        // Compose Highcharts Visualization options\n        const options = {\n            chart: {\n                type: 'area'\n            },\n            title: {\n                text: config.chartTitle || 'Coverage vs Actual'\n            },\n            tooltip: {\n                formatter: function () {\n                    let tooltipContent = \"\";\n                    // = `<b>${this.value}:00</b><br/>`;\n                    this.points && this.points.forEach(point => {\n                        if (point.series.name === \"Coverage\" || point.series.name === \"Avg. Actual\") {\n                            tooltipContent += `<span style=\"color:${point.color}\">\\u25CF</span> ${point.series.name}: <b>${point.y}</b><br/>`;\n                        }\n                    });\n                    return tooltipContent;\n                },\n                shared: true\n            },\n            xAxis: {\n                type: \"datetime\",\n                labels: {\n                    enabled: true,\n                    formatter: function () {\n                        // const ampm = Number(this.value) >= 12 ? 'p' : 'a';\n                        // let hours = Number(this.value) % 12;\n                        // hours = hours ? Number(this.value) : 12; // the hour '0' should be '12'\n                        return `${this.value}:00`;\n                    }\n                },\n                // Make a plotband for each range measure\n                plotBands: rangeData.map((range) => ({\n                    from: range === null || range === void 0 ? void 0 : range.value,\n                    to: (range === null || range === void 0 ? void 0 : range.value) + 1,\n                    color: range === null || range === void 0 ? void 0 : range.color,\n                }))\n            },\n            yAxis: {\n                title: {\n                    text: 'Values'\n                }\n            },\n            legend: {\n                align: config.legendAlign || 'center', // Dynamic horizontal alignment\n                verticalAlign: config.legendVerticalAlign || 'bottom', // Dynamic vertical alignment\n                layout: (config.legendAlign === 'right' && config.legendVerticalAlign === 'middle') ? 'vertical' : 'horizontal', // Set layout to vertical if legend is center-right\n            },\n            series: [{\n                    name: 'Coverage',\n                    // Pull from the first measure with the _type of coverage\n                    data: data.map((row) => { var _a; return (_a = row[coverageMeasure]) === null || _a === void 0 ? void 0 : _a.value; }),\n                    type: 'line',\n                    color: config.coverageColor && config.coverageColor[0],\n                    zIndex: 1,\n                    step: 'right',\n                    marker: getMarkerOptions(coverageMarkerType, config.coverageColor[0], config.coverageMarkerSymbol),\n                    lineWidth: coverageLineWidth\n                }, {\n                    name: 'Avg. Actual',\n                    data: data.map((row) => { var _a; return (_a = row[actualMeasure]) === null || _a === void 0 ? void 0 : _a.value; }),\n                    type: 'line',\n                    color: config.actualColor[0],\n                    zIndex: 1,\n                    marker: getMarkerOptions(actualMarkerType, config.actualColor[0], config.actualMarkerSymbol),\n                    lineWidth: actualLineWidth\n                },\n                // Make a series for each range measure\n                // This is a floating area series that only exists to create the fill between the two lines\n                // The two lines are the avg actual and coverage for the data values and the color\n                // of the fill is determined by the range measure's overUnderColor\n                ...rangeData.map((range) => {\n                    const newRange = {\n                        name: range.name,\n                        type: 'arearange',\n                        data: data.map((row, rowIndex) => {\n                            // get the x axis value and compare it with the range value\n                            // if the range value=the x axis value, return the capacity and actual values\n                            const hour = getHour(row[timeSeries[0].name].value);\n                            const isLeftPoint = hour === range.value;\n                            const isRightPoint = hour === range.value + 1;\n                            const show = isLeftPoint || isRightPoint;\n                            console.log(\"show\", show, hour, range.value);\n                            if (isLeftPoint) {\n                                const coverageStepValue = data[rowIndex + 1][coverageMeasure].value;\n                                return [coverageStepValue, row[actualMeasure].value];\n                            }\n                            else if (isRightPoint) {\n                                return [row[coverageMeasure].value, row[actualMeasure].value];\n                            }\n                            else\n                                return [null, null];\n                        }),\n                        fillOpacity: 0.5,\n                        color: range.overUnderColor,\n                        zIndex: 0,\n                        marker: { enabled: false },\n                        dataLabels: { enabled: false },\n                    };\n                    return newRange;\n                }),\n            ]\n        };\n        Highcharts.chart(element, options);\n    },\n};\nlooker.plugins.visualizations.add(vis);\n\n\n//# sourceURL=webpack://medaxion-custom-visualizations/./src/visualizations/line-area-overlap.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/visualizations/line-area-overlap.ts");
/******/ 	
/******/ })()
;